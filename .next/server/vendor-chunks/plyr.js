"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/plyr";
exports.ids = ["vendor-chunks/plyr"];
exports.modules = {

/***/ "(ssr)/./node_modules/plyr/dist/plyr.css":
/*!*****************************************!*\
  !*** ./node_modules/plyr/dist/plyr.css ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"f8a5774710ad\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGx5ci9kaXN0L3BseXIuY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXHhLb2RhICgyKVxceEtvZGFcXG5vZGVfbW9kdWxlc1xccGx5clxcZGlzdFxccGx5ci5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJmOGE1Nzc0NzEwYWRcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/plyr/dist/plyr.css\n");

/***/ }),

/***/ "(ssr)/./node_modules/plyr/dist/plyr.mjs":
/*!*****************************************!*\
  !*** ./node_modules/plyr/dist/plyr.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Plyr)\n/* harmony export */ });\nfunction _defineProperty$1(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: true,\n        configurable: true,\n        writable: true\n    }) : e[r] = t, e;\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r);\n        if (\"object\" != typeof i) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _classCallCheck(e, t) {\n    if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, t) {\n    for(var n = 0; n < t.length; n++){\n        var r = t[n];\n        r.enumerable = r.enumerable || false, r.configurable = true, \"value\" in r && (r.writable = true), Object.defineProperty(e, r.key, r);\n    }\n}\nfunction _createClass(e, t, n) {\n    return t && _defineProperties(e.prototype, t), n && _defineProperties(e, n), e;\n}\nfunction _defineProperty(e, t, n) {\n    return t in e ? Object.defineProperty(e, t, {\n        value: n,\n        enumerable: true,\n        configurable: true,\n        writable: true\n    }) : e[t] = n, e;\n}\nfunction ownKeys(e, t) {\n    var n = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var r = Object.getOwnPropertySymbols(e);\n        t && (r = r.filter(function(t) {\n            return Object.getOwnPropertyDescriptor(e, t).enumerable;\n        })), n.push.apply(n, r);\n    }\n    return n;\n}\nfunction _objectSpread2(e) {\n    for(var t = 1; t < arguments.length; t++){\n        var n = null != arguments[t] ? arguments[t] : {};\n        t % 2 ? ownKeys(Object(n), true).forEach(function(t) {\n            _defineProperty(e, t, n[t]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ownKeys(Object(n)).forEach(function(t) {\n            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));\n        });\n    }\n    return e;\n}\nvar defaults$1 = {\n    addCSS: true,\n    thumbWidth: 15,\n    watch: true\n};\nfunction matches$1(e, t) {\n    return (function() {\n        return Array.from(document.querySelectorAll(t)).includes(this);\n    }).call(e, t);\n}\nfunction trigger(e, t) {\n    if (e && t) {\n        var n = new Event(t, {\n            bubbles: true\n        });\n        e.dispatchEvent(n);\n    }\n}\nvar getConstructor$1 = function(e) {\n    return null != e ? e.constructor : null;\n}, instanceOf$1 = function(e, t) {\n    return !!(e && t && e instanceof t);\n}, isNullOrUndefined$1 = function(e) {\n    return null == e;\n}, isObject$1 = function(e) {\n    return getConstructor$1(e) === Object;\n}, isNumber$1 = function(e) {\n    return getConstructor$1(e) === Number && !Number.isNaN(e);\n}, isString$1 = function(e) {\n    return getConstructor$1(e) === String;\n}, isBoolean$1 = function(e) {\n    return getConstructor$1(e) === Boolean;\n}, isFunction$1 = function(e) {\n    return getConstructor$1(e) === Function;\n}, isArray$1 = function(e) {\n    return Array.isArray(e);\n}, isNodeList$1 = function(e) {\n    return instanceOf$1(e, NodeList);\n}, isElement$1 = function(e) {\n    return instanceOf$1(e, Element);\n}, isEvent$1 = function(e) {\n    return instanceOf$1(e, Event);\n}, isEmpty$1 = function(e) {\n    return isNullOrUndefined$1(e) || (isString$1(e) || isArray$1(e) || isNodeList$1(e)) && !e.length || isObject$1(e) && !Object.keys(e).length;\n}, is$1 = {\n    nullOrUndefined: isNullOrUndefined$1,\n    object: isObject$1,\n    number: isNumber$1,\n    string: isString$1,\n    boolean: isBoolean$1,\n    function: isFunction$1,\n    array: isArray$1,\n    nodeList: isNodeList$1,\n    element: isElement$1,\n    event: isEvent$1,\n    empty: isEmpty$1\n};\nfunction getDecimalPlaces(e) {\n    var t = \"\".concat(e).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n    return t ? Math.max(0, (t[1] ? t[1].length : 0) - (t[2] ? +t[2] : 0)) : 0;\n}\nfunction round(e, t) {\n    if (1 > t) {\n        var n = getDecimalPlaces(t);\n        return parseFloat(e.toFixed(n));\n    }\n    return Math.round(e / t) * t;\n}\nvar RangeTouch = function() {\n    function e(t, n) {\n        _classCallCheck(this, e), is$1.element(t) ? this.element = t : is$1.string(t) && (this.element = document.querySelector(t)), is$1.element(this.element) && is$1.empty(this.element.rangeTouch) && (this.config = _objectSpread2({}, defaults$1, {}, n), this.init());\n    }\n    return _createClass(e, [\n        {\n            key: \"init\",\n            value: function() {\n                e.enabled && (this.config.addCSS && (this.element.style.userSelect = \"none\", this.element.style.webKitUserSelect = \"none\", this.element.style.touchAction = \"manipulation\"), this.listeners(true), this.element.rangeTouch = this);\n            }\n        },\n        {\n            key: \"destroy\",\n            value: function() {\n                e.enabled && (this.config.addCSS && (this.element.style.userSelect = \"\", this.element.style.webKitUserSelect = \"\", this.element.style.touchAction = \"\"), this.listeners(false), this.element.rangeTouch = null);\n            }\n        },\n        {\n            key: \"listeners\",\n            value: function(e) {\n                var t = this, n = e ? \"addEventListener\" : \"removeEventListener\";\n                [\n                    \"touchstart\",\n                    \"touchmove\",\n                    \"touchend\"\n                ].forEach(function(e) {\n                    t.element[n](e, function(e) {\n                        return t.set(e);\n                    }, false);\n                });\n            }\n        },\n        {\n            key: \"get\",\n            value: function(t) {\n                if (!e.enabled || !is$1.event(t)) return null;\n                var n, r = t.target, i = t.changedTouches[0], o = parseFloat(r.getAttribute(\"min\")) || 0, s = parseFloat(r.getAttribute(\"max\")) || 100, u = parseFloat(r.getAttribute(\"step\")) || 1, c = r.getBoundingClientRect(), a = 100 / c.width * (this.config.thumbWidth / 2) / 100;\n                return 0 > (n = 100 / c.width * (i.clientX - c.left)) ? n = 0 : 100 < n && (n = 100), 50 > n ? n -= (100 - 2 * n) * a : 50 < n && (n += 2 * (n - 50) * a), o + round(n / 100 * (s - o), u);\n            }\n        },\n        {\n            key: \"set\",\n            value: function(t) {\n                e.enabled && is$1.event(t) && !t.target.disabled && (t.preventDefault(), t.target.value = this.get(t), trigger(t.target, \"touchend\" === t.type ? \"change\" : \"input\"));\n            }\n        }\n    ], [\n        {\n            key: \"setup\",\n            value: function(t) {\n                var n = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}, r = null;\n                if (is$1.empty(t) || is$1.string(t) ? r = Array.from(document.querySelectorAll(is$1.string(t) ? t : 'input[type=\"range\"]')) : is$1.element(t) ? r = [\n                    t\n                ] : is$1.nodeList(t) ? r = Array.from(t) : is$1.array(t) && (r = t.filter(is$1.element)), is$1.empty(r)) return null;\n                var i = _objectSpread2({}, defaults$1, {}, n);\n                if (is$1.string(t) && i.watch) {\n                    var o = new MutationObserver(function(n) {\n                        Array.from(n).forEach(function(n) {\n                            Array.from(n.addedNodes).forEach(function(n) {\n                                is$1.element(n) && matches$1(n, t) && new e(n, i);\n                            });\n                        });\n                    });\n                    o.observe(document.body, {\n                        childList: true,\n                        subtree: true\n                    });\n                }\n                return r.map(function(t) {\n                    return new e(t, n);\n                });\n            }\n        },\n        {\n            key: \"enabled\",\n            get: function() {\n                return \"ontouchstart\" in document.documentElement;\n            }\n        }\n    ]), e;\n}();\n// ==========================================================================\n// Type checking utils\n// ==========================================================================\nconst getConstructor = (input)=>input !== null && typeof input !== 'undefined' ? input.constructor : null;\nconst instanceOf = (input, constructor)=>Boolean(input && constructor && input instanceof constructor);\nconst isNullOrUndefined = (input)=>input === null || typeof input === 'undefined';\nconst isObject = (input)=>getConstructor(input) === Object;\nconst isNumber = (input)=>getConstructor(input) === Number && !Number.isNaN(input);\nconst isString = (input)=>getConstructor(input) === String;\nconst isBoolean = (input)=>getConstructor(input) === Boolean;\nconst isFunction = (input)=>typeof input === 'function';\nconst isArray = (input)=>Array.isArray(input);\nconst isWeakMap = (input)=>instanceOf(input, WeakMap);\nconst isNodeList = (input)=>instanceOf(input, NodeList);\nconst isTextNode = (input)=>getConstructor(input) === Text;\nconst isEvent = (input)=>instanceOf(input, Event);\nconst isKeyboardEvent = (input)=>instanceOf(input, KeyboardEvent);\nconst isCue = (input)=>instanceOf(input, window.TextTrackCue) || instanceOf(input, window.VTTCue);\nconst isTrack = (input)=>instanceOf(input, TextTrack) || !isNullOrUndefined(input) && isString(input.kind);\nconst isPromise = (input)=>instanceOf(input, Promise) && isFunction(input.then);\nfunction isElement(input) {\n    return input !== null && typeof input === 'object' && input.nodeType === 1 && typeof input.style === 'object' && typeof input.ownerDocument === 'object';\n}\nfunction isEmpty(input) {\n    return isNullOrUndefined(input) || (isString(input) || isArray(input) || isNodeList(input)) && !input.length || isObject(input) && !Object.keys(input).length;\n}\nfunction isUrl(input) {\n    // Accept a URL object\n    if (instanceOf(input, window.URL)) {\n        return true;\n    }\n    // Must be string from here\n    if (!isString(input)) {\n        return false;\n    }\n    // Add the protocol if required\n    let string = input;\n    if (!input.startsWith('http://') || !input.startsWith('https://')) {\n        string = `http://${input}`;\n    }\n    try {\n        return !isEmpty(new URL(string).hostname);\n    } catch  {\n        return false;\n    }\n}\nvar is = {\n    nullOrUndefined: isNullOrUndefined,\n    object: isObject,\n    number: isNumber,\n    string: isString,\n    boolean: isBoolean,\n    function: isFunction,\n    array: isArray,\n    weakMap: isWeakMap,\n    nodeList: isNodeList,\n    element: isElement,\n    textNode: isTextNode,\n    event: isEvent,\n    keyboardEvent: isKeyboardEvent,\n    cue: isCue,\n    track: isTrack,\n    promise: isPromise,\n    url: isUrl,\n    empty: isEmpty\n};\n// ==========================================================================\n// Animation utils\n// ==========================================================================\nconst transitionEndEvent = (()=>{\n    const element = document.createElement('span');\n    const events = {\n        WebkitTransition: 'webkitTransitionEnd',\n        MozTransition: 'transitionend',\n        OTransition: 'oTransitionEnd otransitionend',\n        transition: 'transitionend'\n    };\n    const type = Object.keys(events).find((event)=>element.style[event] !== undefined);\n    return is.string(type) ? events[type] : false;\n})();\n// Force repaint of element\nfunction repaint(element, delay) {\n    setTimeout(()=>{\n        try {\n            element.hidden = true;\n            // eslint-disable-next-line no-unused-expressions\n            element.offsetHeight;\n            element.hidden = false;\n        } catch  {}\n    }, delay);\n}\n// ==========================================================================\n// Object utils\n// ==========================================================================\n// Clone nested objects\nfunction cloneDeep(object) {\n    return JSON.parse(JSON.stringify(object));\n}\n// Get a nested value in an object\nfunction getDeep(object, path) {\n    return path.split('.').reduce((obj, key)=>obj && obj[key], object);\n}\n// Deep extend destination object with N more objects\nfunction extend(target = {}, ...sources) {\n    if (!sources.length) {\n        return target;\n    }\n    const source = sources.shift();\n    if (!is.object(source)) {\n        return target;\n    }\n    Object.keys(source).forEach((key)=>{\n        if (is.object(source[key])) {\n            if (!Object.keys(target).includes(key)) {\n                Object.assign(target, {\n                    [key]: {}\n                });\n            }\n            extend(target[key], source[key]);\n        } else {\n            Object.assign(target, {\n                [key]: source[key]\n            });\n        }\n    });\n    return extend(target, ...sources);\n}\n// ==========================================================================\n// Element utils\n// ==========================================================================\n// Wrap an element\nfunction wrap(elements, wrapper) {\n    // Convert `elements` to an array, if necessary.\n    const targets = elements.length ? elements : [\n        elements\n    ];\n    // Loops backwards to prevent having to clone the wrapper on the\n    // first element (see `child` below).\n    Array.from(targets).reverse().forEach((element, index)=>{\n        const child = index > 0 ? wrapper.cloneNode(true) : wrapper;\n        // Cache the current parent and sibling.\n        const parent = element.parentNode;\n        const sibling = element.nextSibling;\n        // Wrap the element (is automatically removed from its current\n        // parent).\n        child.appendChild(element);\n        // If the element had a sibling, insert the wrapper before\n        // the sibling to maintain the HTML structure; otherwise, just\n        // append it to the parent.\n        if (sibling) {\n            parent.insertBefore(child, sibling);\n        } else {\n            parent.appendChild(child);\n        }\n    });\n}\n// Set attributes\nfunction setAttributes(element, attributes) {\n    if (!is.element(element) || is.empty(attributes)) return;\n    // Assume null and undefined attributes should be left out,\n    // Setting them would otherwise convert them to \"null\" and \"undefined\"\n    Object.entries(attributes).filter(([, value])=>!is.nullOrUndefined(value)).forEach(([key, value])=>element.setAttribute(key, value));\n}\n// Create a DocumentFragment\nfunction createElement(type, attributes, text) {\n    // Create a new <element>\n    const element = document.createElement(type);\n    // Set all passed attributes\n    if (is.object(attributes)) {\n        setAttributes(element, attributes);\n    }\n    // Add text node\n    if (is.string(text)) {\n        element.textContent = text;\n    }\n    // Return built element\n    return element;\n}\n// Insert an element after another\nfunction insertAfter(element, target) {\n    if (!is.element(element) || !is.element(target)) return;\n    target.parentNode.insertBefore(element, target.nextSibling);\n}\n// Insert a DocumentFragment\nfunction insertElement(type, parent, attributes, text) {\n    if (!is.element(parent)) return;\n    parent.appendChild(createElement(type, attributes, text));\n}\n// Remove element(s)\nfunction removeElement(element) {\n    if (is.nodeList(element) || is.array(element)) {\n        Array.from(element).forEach(removeElement);\n        return;\n    }\n    if (!is.element(element) || !is.element(element.parentNode)) {\n        return;\n    }\n    element.parentNode.removeChild(element);\n}\n// Remove all child elements\nfunction emptyElement(element) {\n    if (!is.element(element)) return;\n    let { length } = element.childNodes;\n    while(length > 0){\n        element.removeChild(element.lastChild);\n        length -= 1;\n    }\n}\n// Replace element\nfunction replaceElement(newChild, oldChild) {\n    if (!is.element(oldChild) || !is.element(oldChild.parentNode) || !is.element(newChild)) return null;\n    oldChild.parentNode.replaceChild(newChild, oldChild);\n    return newChild;\n}\n// Get an attribute object from a string selector\nfunction getAttributesFromSelector(sel, existingAttributes) {\n    // For example:\n    // '.test' to { class: 'test' }\n    // '#test' to { id: 'test' }\n    // '[data-test=\"test\"]' to { 'data-test': 'test' }\n    if (!is.string(sel) || is.empty(sel)) return {};\n    const attributes = {};\n    const existing = extend({}, existingAttributes);\n    sel.split(',').forEach((s)=>{\n        // Remove whitespace\n        const selector = s.trim();\n        const className = selector.replace('.', '');\n        const stripped = selector.replace(/[[\\]]/g, '');\n        // Get the parts and value\n        const parts = stripped.split('=');\n        const [key] = parts;\n        const value = parts.length > 1 ? parts[1].replace(/[\"']/g, '') : '';\n        // Get the first character\n        const start = selector.charAt(0);\n        switch(start){\n            case '.':\n                // Add to existing classname\n                if (is.string(existing.class)) {\n                    attributes.class = `${existing.class} ${className}`;\n                } else {\n                    attributes.class = className;\n                }\n                break;\n            case '#':\n                // ID selector\n                attributes.id = selector.replace('#', '');\n                break;\n            case '[':\n                // Attribute selector\n                attributes[key] = value;\n                break;\n        }\n    });\n    return extend(existing, attributes);\n}\n// Toggle hidden\nfunction toggleHidden(element, hidden) {\n    if (!is.element(element)) return;\n    let hide = hidden;\n    if (!is.boolean(hide)) {\n        hide = !element.hidden;\n    }\n    element.hidden = hide;\n}\n// Mirror Element.classList.toggle, with IE compatibility for \"force\" argument\nfunction toggleClass(element, className, force) {\n    if (is.nodeList(element)) {\n        return Array.from(element).map((e)=>toggleClass(e, className, force));\n    }\n    if (is.element(element)) {\n        let method = 'toggle';\n        if (typeof force !== 'undefined') {\n            method = force ? 'add' : 'remove';\n        }\n        element.classList[method](className);\n        return element.classList.contains(className);\n    }\n    return false;\n}\n// Has class name\nfunction hasClass(element, className) {\n    return is.element(element) && element.classList.contains(className);\n}\n// Element matches selector\nfunction matches(element, selector) {\n    const { prototype } = Element;\n    function match() {\n        return Array.from(document.querySelectorAll(selector)).includes(this);\n    }\n    const method = prototype.matches || prototype.webkitMatchesSelector || prototype.mozMatchesSelector || prototype.msMatchesSelector || match;\n    return method.call(element, selector);\n}\n// Closest ancestor element matching selector (also tests element itself)\nfunction closest$1(element, selector) {\n    const { prototype } = Element;\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill\n    function closestElement() {\n        let el = this;\n        do {\n            if (matches.matches(el, selector)) return el;\n            el = el.parentElement || el.parentNode;\n        }while (el !== null && el.nodeType === 1);\n        return null;\n    }\n    const method = prototype.closest || closestElement;\n    return method.call(element, selector);\n}\n// Find all elements\nfunction getElements(selector) {\n    return this.elements.container.querySelectorAll(selector);\n}\n// Find a single element\nfunction getElement(selector) {\n    return this.elements.container.querySelector(selector);\n}\n// Set focus and tab focus class\nfunction setFocus(element = null, focusVisible = false) {\n    if (!is.element(element)) return;\n    // Set regular focus\n    element.focus({\n        preventScroll: true,\n        focusVisible\n    });\n}\n// ==========================================================================\n// Plyr support checks\n// ==========================================================================\n// Default codecs for checking mimetype support\nconst defaultCodecs = {\n    'audio/ogg': 'vorbis',\n    'audio/wav': '1',\n    'video/webm': 'vp8, vorbis',\n    'video/mp4': 'avc1.42E01E, mp4a.40.2',\n    'video/ogg': 'theora'\n};\n// Check for feature support\nconst support = {\n    // Basic support\n    audio: 'canPlayType' in document.createElement('audio'),\n    video: 'canPlayType' in document.createElement('video'),\n    // Check for support\n    // Basic functionality vs full UI\n    check (type, provider) {\n        const api = support[type] || provider !== 'html5';\n        const ui = api && support.rangeInput;\n        return {\n            api,\n            ui\n        };\n    },\n    // Picture-in-picture support\n    pip: (()=>{\n        return document.pictureInPictureEnabled && !createElement('video').disablePictureInPicture;\n    })(),\n    // Airplay support\n    // Safari only currently\n    airplay: is.function(window.WebKitPlaybackTargetAvailabilityEvent),\n    // Inline playback support\n    // https://webkit.org/blog/6784/new-video-policies-for-ios/\n    playsinline: 'playsInline' in document.createElement('video'),\n    // Check for mime type support against a player instance\n    // Credits: http://diveintohtml5.info/everything.html\n    // Related: http://www.leanbackplayer.com/test/h5mt.html\n    mime (input) {\n        if (is.empty(input)) {\n            return false;\n        }\n        const [mediaType] = input.split('/');\n        let type = input;\n        // Verify we're using HTML5 and there's no media type mismatch\n        if (!this.isHTML5 || mediaType !== this.type) {\n            return false;\n        }\n        // Add codec if required\n        if (Object.keys(defaultCodecs).includes(type)) {\n            type += `; codecs=\"${defaultCodecs[input]}\"`;\n        }\n        try {\n            return Boolean(type && this.media.canPlayType(type).replace(/no/, ''));\n        } catch  {\n            return false;\n        }\n    },\n    // Check for textTracks support\n    textTracks: 'textTracks' in document.createElement('video'),\n    // <input type=\"range\"> Sliders\n    rangeInput: (()=>{\n        const range = document.createElement('input');\n        range.type = 'range';\n        return range.type === 'range';\n    })(),\n    // Touch\n    // NOTE: Remember a device can be mouse + touch enabled so we check on first touch event\n    touch: 'ontouchstart' in document.documentElement,\n    // Detect transitions support\n    transitions: transitionEndEvent !== false,\n    // Reduced motion iOS & MacOS setting\n    // https://webkit.org/blog/7551/responsive-design-for-motion/\n    reducedMotion: 'matchMedia' in window && window.matchMedia('(prefers-reduced-motion)').matches\n};\n// ==========================================================================\n// Event utils\n// ==========================================================================\n// Check for passive event listener support\n// https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n// https://www.youtube.com/watch?v=NPM6172J22g\nconst supportsPassiveListeners = (()=>{\n    // Test via a getter in the options object to see if the passive property is accessed\n    let supported = false;\n    try {\n        const options = Object.defineProperty({}, 'passive', {\n            get () {\n                supported = true;\n                return null;\n            }\n        });\n        window.addEventListener('test', null, options);\n        window.removeEventListener('test', null, options);\n    } catch  {}\n    return supported;\n})();\n// Toggle event listener\nfunction toggleListener(element, event, callback, toggle = false, passive = true, capture = false) {\n    // Bail if no element, event, or callback\n    if (!element || !('addEventListener' in element) || is.empty(event) || !is.function(callback)) {\n        return;\n    }\n    // Allow multiple events\n    const events = event.split(' ');\n    // Build options\n    // Default to just the capture boolean for browsers with no passive listener support\n    let options = capture;\n    // If passive events listeners are supported\n    if (supportsPassiveListeners) {\n        options = {\n            // Whether the listener can be passive (i.e. default never prevented)\n            passive,\n            // Whether the listener is a capturing listener or not\n            capture\n        };\n    }\n    // If a single node is passed, bind the event listener\n    events.forEach((type)=>{\n        if (this && this.eventListeners && toggle) {\n            // Cache event listener\n            this.eventListeners.push({\n                element,\n                type,\n                callback,\n                options\n            });\n        }\n        element[toggle ? 'addEventListener' : 'removeEventListener'](type, callback, options);\n    });\n}\n// Bind event handler\nfunction on(element, events = '', callback, passive = true, capture = false) {\n    toggleListener.call(this, element, events, callback, true, passive, capture);\n}\n// Unbind event handler\nfunction off(element, events = '', callback, passive = true, capture = false) {\n    toggleListener.call(this, element, events, callback, false, passive, capture);\n}\n// Bind once-only event handler\nfunction once(element, events = '', callback, passive = true, capture = false) {\n    const onceCallback = (...args)=>{\n        off(element, events, onceCallback, passive, capture);\n        callback.apply(this, args);\n    };\n    toggleListener.call(this, element, events, onceCallback, true, passive, capture);\n}\n// Trigger event\nfunction triggerEvent(element, type = '', bubbles = false, detail = {}) {\n    // Bail if no element\n    if (!is.element(element) || is.empty(type)) {\n        return;\n    }\n    // Create and dispatch the event\n    const event = new CustomEvent(type, {\n        bubbles,\n        detail: {\n            ...detail,\n            plyr: this\n        }\n    });\n    // Dispatch the event\n    element.dispatchEvent(event);\n}\n// Unbind all cached event listeners\nfunction unbindListeners() {\n    if (this && this.eventListeners) {\n        this.eventListeners.forEach((item)=>{\n            const { element, type, callback, options } = item;\n            element.removeEventListener(type, callback, options);\n        });\n        this.eventListeners = [];\n    }\n}\n// Run method when / if player is ready\nfunction ready() {\n    return new Promise((resolve)=>this.ready ? setTimeout(resolve, 0) : on.call(this, this.elements.container, 'ready', resolve)).then(()=>{});\n}\n/**\n * Silence a Promise-like object.\n * This is useful for avoiding non-harmful, but potentially confusing \"uncaught\n * play promise\" rejection error messages.\n * @param  {object} value An object that may or may not be `Promise`-like.\n */ function silencePromise(value) {\n    if (is.promise(value)) {\n        value.then(null, ()=>{});\n    }\n}\n// ==========================================================================\n// Array utils\n// ==========================================================================\n// Remove duplicates in an array\nfunction dedupe(array) {\n    if (!is.array(array)) {\n        return array;\n    }\n    return array.filter((item, index)=>array.indexOf(item) === index);\n}\n// Get the closest value in an array\nfunction closest(array, value) {\n    if (!is.array(array) || !array.length) {\n        return null;\n    }\n    return array.reduce((prev, curr)=>Math.abs(curr - value) < Math.abs(prev - value) ? curr : prev);\n}\n// ==========================================================================\n// Style utils\n// ==========================================================================\n// Check support for a CSS declaration\nfunction supportsCSS(declaration) {\n    if (!window || !window.CSS) {\n        return false;\n    }\n    return window.CSS.supports(declaration);\n}\n// Standard/common aspect ratios\nconst standardRatios = [\n    [\n        1,\n        1\n    ],\n    [\n        4,\n        3\n    ],\n    [\n        3,\n        4\n    ],\n    [\n        5,\n        4\n    ],\n    [\n        4,\n        5\n    ],\n    [\n        3,\n        2\n    ],\n    [\n        2,\n        3\n    ],\n    [\n        16,\n        10\n    ],\n    [\n        10,\n        16\n    ],\n    [\n        16,\n        9\n    ],\n    [\n        9,\n        16\n    ],\n    [\n        21,\n        9\n    ],\n    [\n        9,\n        21\n    ],\n    [\n        32,\n        9\n    ],\n    [\n        9,\n        32\n    ]\n].reduce((out, [x, y])=>({\n        ...out,\n        [x / y]: [\n            x,\n            y\n        ]\n    }), {});\n// Validate an aspect ratio\nfunction validateAspectRatio(input) {\n    if (!is.array(input) && (!is.string(input) || !input.includes(':'))) {\n        return false;\n    }\n    const ratio = is.array(input) ? input : input.split(':');\n    return ratio.map(Number).every(is.number);\n}\n// Reduce an aspect ratio to it's lowest form\nfunction reduceAspectRatio(ratio) {\n    if (!is.array(ratio) || !ratio.every(is.number)) {\n        return null;\n    }\n    const [width, height] = ratio;\n    const getDivider = (w, h)=>h === 0 ? w : getDivider(h, w % h);\n    const divider = getDivider(width, height);\n    return [\n        width / divider,\n        height / divider\n    ];\n}\n// Calculate an aspect ratio\nfunction getAspectRatio(input) {\n    const parse = (ratio)=>validateAspectRatio(ratio) ? ratio.split(':').map(Number) : null;\n    // Try provided ratio\n    let ratio = parse(input);\n    // Get from config\n    if (ratio === null) {\n        ratio = parse(this.config.ratio);\n    }\n    // Get from embed\n    if (ratio === null && !is.empty(this.embed) && is.array(this.embed.ratio)) {\n        ({ ratio } = this.embed);\n    }\n    // Get from HTML5 video\n    if (ratio === null && this.isHTML5) {\n        const { videoWidth, videoHeight } = this.media;\n        ratio = [\n            videoWidth,\n            videoHeight\n        ];\n    }\n    return reduceAspectRatio(ratio);\n}\n// Set aspect ratio for responsive container\nfunction setAspectRatio(input) {\n    if (!this.isVideo) {\n        return {};\n    }\n    const { wrapper } = this.elements;\n    const ratio = getAspectRatio.call(this, input);\n    if (!is.array(ratio)) {\n        return {};\n    }\n    const [x, y] = reduceAspectRatio(ratio);\n    const useNative = supportsCSS(`aspect-ratio: ${x}/${y}`);\n    const padding = 100 / x * y;\n    if (useNative) {\n        wrapper.style.aspectRatio = `${x}/${y}`;\n    } else {\n        wrapper.style.paddingBottom = `${padding}%`;\n    }\n    // For Vimeo we have an extra <div> to hide the standard controls and UI\n    if (this.isVimeo && !this.config.vimeo.premium && this.supported.ui) {\n        const height = 100 / this.media.offsetWidth * Number.parseInt(window.getComputedStyle(this.media).paddingBottom, 10);\n        const offset = (height - padding) / (height / 50);\n        if (this.fullscreen.active) {\n            wrapper.style.paddingBottom = null;\n        } else {\n            this.media.style.transform = `translateY(-${offset}%)`;\n        }\n    } else if (this.isHTML5) {\n        wrapper.classList.add(this.config.classNames.videoFixedRatio);\n    }\n    return {\n        padding,\n        ratio\n    };\n}\n// Round an aspect ratio to closest standard ratio\nfunction roundAspectRatio(x, y, tolerance = 0.05) {\n    const ratio = x / y;\n    const closestRatio = closest(Object.keys(standardRatios), ratio);\n    // Check match is within tolerance\n    if (Math.abs(closestRatio - ratio) <= tolerance) {\n        return standardRatios[closestRatio];\n    }\n    // No match\n    return [\n        x,\n        y\n    ];\n}\n// Get the size of the viewport\n// https://stackoverflow.com/questions/1248081/how-to-get-the-browser-viewport-dimensions\nfunction getViewportSize() {\n    const width = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);\n    const height = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);\n    return [\n        width,\n        height\n    ];\n}\n// ==========================================================================\n// Plyr HTML5 helpers\n// ==========================================================================\nconst html5 = {\n    getSources () {\n        if (!this.isHTML5) {\n            return [];\n        }\n        const sources = Array.from(this.media.querySelectorAll('source'));\n        // Filter out unsupported sources (if type is specified)\n        return sources.filter((source)=>{\n            const type = source.getAttribute('type');\n            if (is.empty(type)) {\n                return true;\n            }\n            return support.mime.call(this, type);\n        });\n    },\n    // Get quality levels\n    getQualityOptions () {\n        // Whether we're forcing all options (e.g. for streaming)\n        if (this.config.quality.forced) {\n            return this.config.quality.options;\n        }\n        // Get sizes from <source> elements\n        return html5.getSources.call(this).map((source)=>Number(source.getAttribute('size'))).filter(Boolean);\n    },\n    setup () {\n        if (!this.isHTML5) {\n            return;\n        }\n        const player = this;\n        // Set speed options from config\n        player.options.speed = player.config.speed.options;\n        // Set aspect ratio if fixed\n        if (!is.empty(this.config.ratio)) {\n            setAspectRatio.call(player);\n        }\n        // Quality\n        Object.defineProperty(player.media, 'quality', {\n            get () {\n                // Get sources\n                const sources = html5.getSources.call(player);\n                const source = sources.find((s)=>s.getAttribute('src') === player.source);\n                // Return size, if match is found\n                return source && Number(source.getAttribute('size'));\n            },\n            set (input) {\n                if (player.quality === input) {\n                    return;\n                }\n                // If we're using an external handler...\n                if (player.config.quality.forced && is.function(player.config.quality.onChange)) {\n                    player.config.quality.onChange(input);\n                } else {\n                    // Get sources\n                    const sources = html5.getSources.call(player);\n                    // Get first match for requested size\n                    const source = sources.find((s)=>Number(s.getAttribute('size')) === input);\n                    // No matching source found\n                    if (!source) {\n                        return;\n                    }\n                    // Get current state\n                    const { currentTime, paused, preload, readyState, playbackRate } = player.media;\n                    // Set new source\n                    player.media.src = source.getAttribute('src');\n                    // Prevent loading if preload=\"none\" and the current source isn't loaded (#1044)\n                    if (preload !== 'none' || readyState) {\n                        // Restore time\n                        player.once('loadedmetadata', ()=>{\n                            player.speed = playbackRate;\n                            player.currentTime = currentTime;\n                            // Resume playing\n                            if (!paused) {\n                                silencePromise(player.play());\n                            }\n                        });\n                        // Load new source\n                        player.media.load();\n                    }\n                }\n                // Trigger change event\n                triggerEvent.call(player, player.media, 'qualitychange', false, {\n                    quality: input\n                });\n            }\n        });\n    },\n    // Cancel current network requests\n    // See https://github.com/sampotts/plyr/issues/174\n    cancelRequests () {\n        if (!this.isHTML5) {\n            return;\n        }\n        // Remove child sources\n        removeElement(html5.getSources.call(this));\n        // Set blank video src attribute\n        // This is to prevent a MEDIA_ERR_SRC_NOT_SUPPORTED error\n        // Info: http://stackoverflow.com/questions/32231579/how-to-properly-dispose-of-an-html5-video-and-close-socket-or-connection\n        this.media.setAttribute('src', this.config.blankVideo);\n        // Load the new empty source\n        // This will cancel existing requests\n        // See https://github.com/sampotts/plyr/issues/174\n        this.media.load();\n        // Debugging\n        this.debug.log('Cancelled network requests');\n    }\n};\n// ==========================================================================\n// Browser sniffing\n// Unfortunately, due to mixed support, UA sniffing is required\n// ==========================================================================\nconst isIE = Boolean(window.document.documentMode);\nconst isEdge = /Edge/.test(navigator.userAgent);\nconst isWebKit = 'WebkitAppearance' in document.documentElement.style && !/Edge/.test(navigator.userAgent);\n// navigator.platform may be deprecated but this check is still required\nconst isIPadOS = navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1;\nconst isIos = /iPad|iPhone|iPod/i.test(navigator.userAgent) && navigator.maxTouchPoints > 1;\nvar browser = {\n    isIE,\n    isEdge,\n    isWebKit,\n    isIPadOS,\n    isIos\n};\n// ==========================================================================\n// String utils\n// ==========================================================================\n// Generate a random ID\nfunction generateId(prefix) {\n    return `${prefix}-${Math.floor(Math.random() * 10000)}`;\n}\n// Format string\nfunction format(input, ...args) {\n    if (is.empty(input)) return input;\n    return input.toString().replace(/\\{(\\d+)\\}/g, (_, i)=>args[i].toString());\n}\n// Get percentage\nfunction getPercentage(current, max) {\n    if (current === 0 || max === 0 || Number.isNaN(current) || Number.isNaN(max)) {\n        return 0;\n    }\n    return (current / max * 100).toFixed(2);\n}\n// Replace all occurrences of a string in a string\nfunction replaceAll(input = '', find = '', replace = '') {\n    return input.replace(new RegExp(find.toString().replace(/([.*+?^=!:${}()|[\\]/\\\\])/g, '\\\\$1'), 'g'), replace.toString());\n}\n// Convert to title case\nfunction toTitleCase(input = '') {\n    return input.toString().replace(/\\w\\S*/g, (text)=>text.charAt(0).toUpperCase() + text.slice(1).toLowerCase());\n}\n// Convert string to pascalCase\nfunction toPascalCase(input = '') {\n    let string = input.toString();\n    // Convert kebab case\n    string = replaceAll(string, '-', ' ');\n    // Convert snake case\n    string = replaceAll(string, '_', ' ');\n    // Convert to title case\n    string = toTitleCase(string);\n    // Convert to pascal case\n    return replaceAll(string, ' ', '');\n}\n// Convert string to pascalCase\nfunction toCamelCase(input = '') {\n    let string = input.toString();\n    // Convert to pascal case\n    string = toPascalCase(string);\n    // Convert first character to lowercase\n    return string.charAt(0).toLowerCase() + string.slice(1);\n}\n// Remove HTML from a string\nfunction stripHTML(source) {\n    const fragment = document.createDocumentFragment();\n    const element = document.createElement('div');\n    fragment.appendChild(element);\n    element.innerHTML = source;\n    return fragment.firstChild.textContent;\n}\n// Like outerHTML, but also works for DocumentFragment\nfunction getHTML(element) {\n    const wrapper = document.createElement('div');\n    wrapper.appendChild(element);\n    return wrapper.innerHTML;\n}\n// ==========================================================================\n// Plyr internationalization\n// ==========================================================================\n// Skip i18n for abbreviations and brand names\nconst resources = {\n    pip: 'PIP',\n    airplay: 'AirPlay',\n    html5: 'HTML5',\n    vimeo: 'Vimeo',\n    youtube: 'YouTube'\n};\nconst i18n = {\n    get (key = '', config = {}) {\n        if (is.empty(key) || is.empty(config)) {\n            return '';\n        }\n        let string = getDeep(config.i18n, key);\n        if (is.empty(string)) {\n            if (Object.keys(resources).includes(key)) {\n                return resources[key];\n            }\n            return '';\n        }\n        const replace = {\n            '{seektime}': config.seekTime,\n            '{title}': config.title\n        };\n        Object.entries(replace).forEach(([k, v])=>{\n            string = replaceAll(string, k, v);\n        });\n        return string;\n    }\n};\nclass Storage {\n    constructor(player){\n        _defineProperty$1(this, \"get\", (key)=>{\n            if (!Storage.supported || !this.enabled) {\n                return null;\n            }\n            const store = window.localStorage.getItem(this.key);\n            if (is.empty(store)) return null;\n            const json = JSON.parse(store);\n            return is.string(key) && key.length ? json[key] : json;\n        });\n        _defineProperty$1(this, \"set\", (object)=>{\n            // Bail if we don't have localStorage support or it's disabled\n            if (!Storage.supported || !this.enabled) {\n                return;\n            }\n            // Can only store objects\n            if (!is.object(object)) {\n                return;\n            }\n            // Get current storage\n            let storage = this.get();\n            // Default to empty object\n            if (is.empty(storage)) {\n                storage = {};\n            }\n            // Update the working copy of the values\n            extend(storage, object);\n            // Update storage\n            try {\n                window.localStorage.setItem(this.key, JSON.stringify(storage));\n            } catch  {}\n        });\n        this.enabled = player.config.storage.enabled;\n        this.key = player.config.storage.key;\n    }\n    // Check for actual support (see if we can use it)\n    static get supported() {\n        try {\n            if (!('localStorage' in window)) return false;\n            const test = '___test';\n            // Try to use it (it might be disabled, e.g. user is in private mode)\n            // see: https://github.com/sampotts/plyr/issues/131\n            window.localStorage.setItem(test, test);\n            window.localStorage.removeItem(test);\n            return true;\n        } catch  {\n            return false;\n        }\n    }\n}\n// ==========================================================================\n// Fetch wrapper\n// Using XHR to avoid issues with older browsers\n// ==========================================================================\nfunction fetch(url, responseType = 'text', withCredentials = false) {\n    return new Promise((resolve, reject)=>{\n        try {\n            const request = new XMLHttpRequest();\n            // Check for CORS support\n            if (!('withCredentials' in request)) return;\n            // Set to true if needed for CORS\n            if (withCredentials) {\n                request.withCredentials = true;\n            }\n            request.addEventListener('load', ()=>{\n                if (responseType === 'text') {\n                    try {\n                        resolve(JSON.parse(request.responseText));\n                    } catch  {\n                        resolve(request.responseText);\n                    }\n                } else {\n                    resolve(request.response);\n                }\n            });\n            request.addEventListener('error', ()=>{\n                throw new Error(request.status);\n            });\n            request.open('GET', url, true);\n            request.responseType = responseType;\n            request.send();\n        } catch (error) {\n            reject(error);\n        }\n    });\n}\n// ==========================================================================\n// Sprite loader\n// ==========================================================================\n// Load an external SVG sprite\nfunction loadSprite(url, id) {\n    if (!is.string(url)) {\n        return;\n    }\n    const prefix = 'cache';\n    const hasId = is.string(id);\n    let isCached = false;\n    const exists = ()=>document.getElementById(id) !== null;\n    const update = (container, data)=>{\n        container.innerHTML = data;\n        // Check again incase of race condition\n        if (hasId && exists()) {\n            return;\n        }\n        // Inject the SVG to the body\n        document.body.insertAdjacentElement('afterbegin', container);\n    };\n    // Only load once if ID set\n    if (!hasId || !exists()) {\n        const useStorage = Storage.supported;\n        // Create container\n        const container = document.createElement('div');\n        container.setAttribute('hidden', '');\n        if (hasId) {\n            container.setAttribute('id', id);\n        }\n        // Check in cache\n        if (useStorage) {\n            const cached = window.localStorage.getItem(`${prefix}-${id}`);\n            isCached = cached !== null;\n            if (isCached) {\n                const data = JSON.parse(cached);\n                update(container, data.content);\n            }\n        }\n        // Get the sprite\n        fetch(url).then((result)=>{\n            if (is.empty(result)) {\n                return;\n            }\n            if (useStorage) {\n                try {\n                    window.localStorage.setItem(`${prefix}-${id}`, JSON.stringify({\n                        content: result\n                    }));\n                } catch  {}\n            }\n            update(container, result);\n        }).catch(()=>{});\n    }\n}\n// ==========================================================================\n// Time utils\n// ==========================================================================\n// Time helpers\nconst getHours = (value)=>Math.trunc(value / 60 / 60 % 60, 10);\nconst getMinutes = (value)=>Math.trunc(value / 60 % 60, 10);\nconst getSeconds = (value)=>Math.trunc(value % 60, 10);\n// Format time to UI friendly string\nfunction formatTime(time = 0, displayHours = false, inverted = false) {\n    // Bail if the value isn't a number\n    if (!is.number(time)) {\n        return formatTime(undefined, displayHours, inverted);\n    }\n    // Format time component to add leading zero\n    const format = (value)=>`0${value}`.slice(-2);\n    // Breakdown to hours, mins, secs\n    let hours = getHours(time);\n    const mins = getMinutes(time);\n    const secs = getSeconds(time);\n    // Do we need to display hours?\n    if (displayHours || hours > 0) {\n        hours = `${hours}:`;\n    } else {\n        hours = '';\n    }\n    // Render\n    return `${inverted && time > 0 ? '-' : ''}${hours}${format(mins)}:${format(secs)}`;\n}\n// ==========================================================================\n// Plyr controls\n// TODO: This needs to be split into smaller files and cleaned up\n// ==========================================================================\n// TODO: Don't export a massive object - break down and create class\nconst controls = {\n    // Get icon URL\n    getIconUrl () {\n        const url = new URL(this.config.iconUrl, window.location);\n        const host = window.location.host ? window.location.host : window.top.location.host;\n        const cors = url.host !== host || browser.isIE && !window.svg4everybody;\n        return {\n            url: this.config.iconUrl,\n            cors\n        };\n    },\n    // Find the UI controls\n    findElements () {\n        try {\n            this.elements.controls = getElement.call(this, this.config.selectors.controls.wrapper);\n            // Buttons\n            this.elements.buttons = {\n                play: getElements.call(this, this.config.selectors.buttons.play),\n                pause: getElement.call(this, this.config.selectors.buttons.pause),\n                restart: getElement.call(this, this.config.selectors.buttons.restart),\n                rewind: getElement.call(this, this.config.selectors.buttons.rewind),\n                fastForward: getElement.call(this, this.config.selectors.buttons.fastForward),\n                mute: getElement.call(this, this.config.selectors.buttons.mute),\n                pip: getElement.call(this, this.config.selectors.buttons.pip),\n                airplay: getElement.call(this, this.config.selectors.buttons.airplay),\n                settings: getElement.call(this, this.config.selectors.buttons.settings),\n                captions: getElement.call(this, this.config.selectors.buttons.captions),\n                fullscreen: getElement.call(this, this.config.selectors.buttons.fullscreen)\n            };\n            // Progress\n            this.elements.progress = getElement.call(this, this.config.selectors.progress);\n            // Inputs\n            this.elements.inputs = {\n                seek: getElement.call(this, this.config.selectors.inputs.seek),\n                volume: getElement.call(this, this.config.selectors.inputs.volume)\n            };\n            // Display\n            this.elements.display = {\n                buffer: getElement.call(this, this.config.selectors.display.buffer),\n                currentTime: getElement.call(this, this.config.selectors.display.currentTime),\n                duration: getElement.call(this, this.config.selectors.display.duration)\n            };\n            // Seek tooltip\n            if (is.element(this.elements.progress)) {\n                this.elements.display.seekTooltip = this.elements.progress.querySelector(`.${this.config.classNames.tooltip}`);\n            }\n            return true;\n        } catch (error) {\n            // Log it\n            this.debug.warn('It looks like there is a problem with your custom controls HTML', error);\n            // Restore native video controls\n            this.toggleNativeControls(true);\n            return false;\n        }\n    },\n    // Create <svg> icon\n    createIcon (type, attributes) {\n        const namespace = 'http://www.w3.org/2000/svg';\n        const iconUrl = controls.getIconUrl.call(this);\n        const iconPath = `${!iconUrl.cors ? iconUrl.url : ''}#${this.config.iconPrefix}`;\n        // Create <svg>\n        const icon = document.createElementNS(namespace, 'svg');\n        setAttributes(icon, extend(attributes, {\n            'aria-hidden': 'true',\n            'focusable': 'false'\n        }));\n        // Create the <use> to reference sprite\n        const use = document.createElementNS(namespace, 'use');\n        const path = `${iconPath}-${type}`;\n        // Set `href` attributes\n        // https://github.com/sampotts/plyr/issues/460\n        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/xlink:href\n        if ('href' in use) {\n            use.setAttributeNS('http://www.w3.org/1999/xlink', 'href', path);\n        }\n        // Always set the older attribute even though it's \"deprecated\" (it'll be around for ages)\n        use.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', path);\n        // Add <use> to <svg>\n        icon.appendChild(use);\n        return icon;\n    },\n    // Create hidden text label\n    createLabel (key, attr = {}) {\n        const text = i18n.get(key, this.config);\n        const attributes = {\n            ...attr,\n            class: [\n                attr.class,\n                this.config.classNames.hidden\n            ].filter(Boolean).join(' ')\n        };\n        return createElement('span', attributes, text);\n    },\n    // Create a badge\n    createBadge (text) {\n        if (is.empty(text)) {\n            return null;\n        }\n        const badge = createElement('span', {\n            class: this.config.classNames.menu.value\n        });\n        badge.appendChild(createElement('span', {\n            class: this.config.classNames.menu.badge\n        }, text));\n        return badge;\n    },\n    // Create a <button>\n    createButton (buttonType, attr) {\n        const attributes = extend({}, attr);\n        let type = toCamelCase(buttonType);\n        const props = {\n            element: 'button',\n            toggle: false,\n            label: null,\n            icon: null,\n            labelPressed: null,\n            iconPressed: null\n        };\n        [\n            'element',\n            'icon',\n            'label'\n        ].forEach((key)=>{\n            if (Object.keys(attributes).includes(key)) {\n                props[key] = attributes[key];\n                delete attributes[key];\n            }\n        });\n        // Default to 'button' type to prevent form submission\n        if (props.element === 'button' && !Object.keys(attributes).includes('type')) {\n            attributes.type = 'button';\n        }\n        // Set class name\n        if (Object.keys(attributes).includes('class')) {\n            if (!attributes.class.split(' ').includes(this.config.classNames.control)) {\n                extend(attributes, {\n                    class: `${attributes.class} ${this.config.classNames.control}`\n                });\n            }\n        } else {\n            attributes.class = this.config.classNames.control;\n        }\n        // Large play button\n        switch(buttonType){\n            case 'play':\n                props.toggle = true;\n                props.label = 'play';\n                props.labelPressed = 'pause';\n                props.icon = 'play';\n                props.iconPressed = 'pause';\n                break;\n            case 'mute':\n                props.toggle = true;\n                props.label = 'mute';\n                props.labelPressed = 'unmute';\n                props.icon = 'volume';\n                props.iconPressed = 'muted';\n                break;\n            case 'captions':\n                props.toggle = true;\n                props.label = 'enableCaptions';\n                props.labelPressed = 'disableCaptions';\n                props.icon = 'captions-off';\n                props.iconPressed = 'captions-on';\n                break;\n            case 'fullscreen':\n                props.toggle = true;\n                props.label = 'enterFullscreen';\n                props.labelPressed = 'exitFullscreen';\n                props.icon = 'enter-fullscreen';\n                props.iconPressed = 'exit-fullscreen';\n                break;\n            case 'play-large':\n                attributes.class += ` ${this.config.classNames.control}--overlaid`;\n                type = 'play';\n                props.label = 'play';\n                props.icon = 'play';\n                break;\n            default:\n                if (is.empty(props.label)) {\n                    props.label = type;\n                }\n                if (is.empty(props.icon)) {\n                    props.icon = buttonType;\n                }\n        }\n        const button = createElement(props.element);\n        // Setup toggle icon and labels\n        if (props.toggle) {\n            // Icon\n            button.appendChild(controls.createIcon.call(this, props.iconPressed, {\n                class: 'icon--pressed'\n            }));\n            button.appendChild(controls.createIcon.call(this, props.icon, {\n                class: 'icon--not-pressed'\n            }));\n            // Label/Tooltip\n            button.appendChild(controls.createLabel.call(this, props.labelPressed, {\n                class: 'label--pressed'\n            }));\n            button.appendChild(controls.createLabel.call(this, props.label, {\n                class: 'label--not-pressed'\n            }));\n        } else {\n            button.appendChild(controls.createIcon.call(this, props.icon));\n            button.appendChild(controls.createLabel.call(this, props.label));\n        }\n        // Merge and set attributes\n        extend(attributes, getAttributesFromSelector(this.config.selectors.buttons[type], attributes));\n        setAttributes(button, attributes);\n        // We have multiple play buttons\n        if (type === 'play') {\n            if (!is.array(this.elements.buttons[type])) {\n                this.elements.buttons[type] = [];\n            }\n            this.elements.buttons[type].push(button);\n        } else {\n            this.elements.buttons[type] = button;\n        }\n        return button;\n    },\n    // Create an <input type='range'>\n    createRange (type, attributes) {\n        // Seek input\n        const input = createElement('input', extend(getAttributesFromSelector(this.config.selectors.inputs[type]), {\n            'type': 'range',\n            'min': 0,\n            'max': 100,\n            'step': 0.01,\n            'value': 0,\n            'autocomplete': 'off',\n            // A11y fixes for https://github.com/sampotts/plyr/issues/905\n            'role': 'slider',\n            'aria-label': i18n.get(type, this.config),\n            'aria-valuemin': 0,\n            'aria-valuemax': 100,\n            'aria-valuenow': 0\n        }, attributes));\n        this.elements.inputs[type] = input;\n        // Set the fill for webkit now\n        controls.updateRangeFill.call(this, input);\n        // Improve support on touch devices\n        RangeTouch.setup(input);\n        return input;\n    },\n    // Create a <progress>\n    createProgress (type, attributes) {\n        const progress = createElement('progress', extend(getAttributesFromSelector(this.config.selectors.display[type]), {\n            'min': 0,\n            'max': 100,\n            'value': 0,\n            'role': 'progressbar',\n            'aria-hidden': true\n        }, attributes));\n        // Create the label inside\n        if (type !== 'volume') {\n            progress.appendChild(createElement('span', null, '0'));\n            const suffixKey = {\n                played: 'played',\n                buffer: 'buffered'\n            }[type];\n            const suffix = suffixKey ? i18n.get(suffixKey, this.config) : '';\n            progress.textContent = `% ${suffix.toLowerCase()}`;\n        }\n        this.elements.display[type] = progress;\n        return progress;\n    },\n    // Create time display\n    createTime (type, attrs) {\n        const attributes = getAttributesFromSelector(this.config.selectors.display[type], attrs);\n        const container = createElement('div', extend(attributes, {\n            'class': `${attributes.class ? attributes.class : ''} ${this.config.classNames.display.time} `.trim(),\n            'aria-label': i18n.get(type, this.config),\n            'role': 'timer'\n        }), '00:00');\n        // Reference for updates\n        this.elements.display[type] = container;\n        return container;\n    },\n    // Bind keyboard shortcuts for a menu item\n    // We have to bind to keyup otherwise Firefox triggers a click when a keydown event handler shifts focus\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143\n    bindMenuItemShortcuts (menuItem, type) {\n        // Navigate through menus via arrow keys and space\n        on.call(this, menuItem, 'keydown keyup', (event)=>{\n            // We only care about space and   \n            if (![\n                ' ',\n                'ArrowUp',\n                'ArrowDown',\n                'ArrowRight'\n            ].includes(event.key)) {\n                return;\n            }\n            // Prevent play / seek\n            event.preventDefault();\n            event.stopPropagation();\n            // We're just here to prevent the keydown bubbling\n            if (event.type === 'keydown') {\n                return;\n            }\n            const isRadioButton = matches(menuItem, '[role=\"menuitemradio\"]');\n            // Show the respective menu\n            if (!isRadioButton && [\n                ' ',\n                'ArrowRight'\n            ].includes(event.key)) {\n                controls.showMenuPanel.call(this, type, true);\n            } else {\n                let target;\n                if (event.key !== ' ') {\n                    if (event.key === 'ArrowDown' || isRadioButton && event.key === 'ArrowRight') {\n                        target = menuItem.nextElementSibling;\n                        if (!is.element(target)) {\n                            target = menuItem.parentNode.firstElementChild;\n                        }\n                    } else {\n                        target = menuItem.previousElementSibling;\n                        if (!is.element(target)) {\n                            target = menuItem.parentNode.lastElementChild;\n                        }\n                    }\n                    setFocus.call(this, target, true);\n                }\n            }\n        }, false);\n        // Enter will fire a `click` event but we still need to manage focus\n        // So we bind to keyup which fires after and set focus here\n        on.call(this, menuItem, 'keyup', (event)=>{\n            if (event.key !== 'Return') return;\n            controls.focusFirstMenuItem.call(this, null, true);\n        });\n    },\n    // Create a settings menu item\n    createMenuItem ({ value, list, type, title, badge = null, checked = false }) {\n        const attributes = getAttributesFromSelector(this.config.selectors.inputs[type]);\n        const menuItem = createElement('button', extend(attributes, {\n            'type': 'button',\n            'role': 'menuitemradio',\n            'class': `${this.config.classNames.control} ${attributes.class ? attributes.class : ''}`.trim(),\n            'aria-checked': checked,\n            value\n        }));\n        const flex = createElement('span');\n        // We have to set as HTML incase of special characters\n        flex.innerHTML = title;\n        if (is.element(badge)) {\n            flex.appendChild(badge);\n        }\n        menuItem.appendChild(flex);\n        // Replicate radio button behavior\n        Object.defineProperty(menuItem, 'checked', {\n            enumerable: true,\n            get () {\n                return menuItem.getAttribute('aria-checked') === 'true';\n            },\n            set (check) {\n                // Ensure exclusivity\n                if (check) {\n                    Array.from(menuItem.parentNode.children).filter((node)=>matches(node, '[role=\"menuitemradio\"]')).forEach((node)=>node.setAttribute('aria-checked', 'false'));\n                }\n                menuItem.setAttribute('aria-checked', check ? 'true' : 'false');\n            }\n        });\n        this.listeners.bind(menuItem, 'click keyup', (event)=>{\n            if (is.keyboardEvent(event) && event.key !== ' ') {\n                return;\n            }\n            event.preventDefault();\n            event.stopPropagation();\n            menuItem.checked = true;\n            switch(type){\n                case 'language':\n                    this.currentTrack = Number(value);\n                    break;\n                case 'quality':\n                    this.quality = value;\n                    break;\n                case 'speed':\n                    this.speed = Number.parseFloat(value);\n                    break;\n            }\n            controls.showMenuPanel.call(this, 'home', is.keyboardEvent(event));\n        }, type, false);\n        controls.bindMenuItemShortcuts.call(this, menuItem, type);\n        list.appendChild(menuItem);\n    },\n    // Format a time for display\n    formatTime (time = 0, inverted = false) {\n        // Bail if the value isn't a number\n        if (!is.number(time)) {\n            return time;\n        }\n        // Always display hours if duration is over an hour\n        const forceHours = getHours(this.duration) > 0;\n        return formatTime(time, forceHours, inverted);\n    },\n    // Update the displayed time\n    updateTimeDisplay (target = null, time = 0, inverted = false) {\n        // Bail if there's no element to display or the value isn't a number\n        if (!is.element(target) || !is.number(time)) {\n            return;\n        }\n        target.textContent = controls.formatTime(time, inverted);\n    },\n    // Update volume UI and storage\n    updateVolume () {\n        if (!this.supported.ui) {\n            return;\n        }\n        // Update range\n        if (is.element(this.elements.inputs.volume)) {\n            controls.setRange.call(this, this.elements.inputs.volume, this.muted ? 0 : this.volume);\n        }\n        // Update mute state\n        if (is.element(this.elements.buttons.mute)) {\n            this.elements.buttons.mute.pressed = this.muted || this.volume === 0;\n        }\n    },\n    // Update seek value and lower fill\n    setRange (target, value = 0) {\n        if (!is.element(target)) {\n            return;\n        }\n        target.value = value;\n        // Webkit range fill\n        controls.updateRangeFill.call(this, target);\n    },\n    // Update <progress> elements\n    updateProgress (event) {\n        if (!this.supported.ui || !is.event(event)) {\n            return;\n        }\n        let value = 0;\n        const setProgress = (target, input)=>{\n            const val = is.number(input) ? input : 0;\n            const progress = is.element(target) ? target : this.elements.display.buffer;\n            // Update value and label\n            if (is.element(progress)) {\n                progress.value = val;\n                // Update text label inside\n                const label = progress.getElementsByTagName('span')[0];\n                if (is.element(label)) {\n                    label.childNodes[0].nodeValue = val;\n                }\n            }\n        };\n        if (event) {\n            switch(event.type){\n                // Video playing\n                case 'timeupdate':\n                case 'seeking':\n                case 'seeked':\n                    value = getPercentage(this.currentTime, this.duration);\n                    // Set seek range value only if it's a 'natural' time event\n                    if (event.type === 'timeupdate') {\n                        controls.setRange.call(this, this.elements.inputs.seek, value);\n                    }\n                    break;\n                // Check buffer status\n                case 'playing':\n                case 'progress':\n                    setProgress(this.elements.display.buffer, this.buffered * 100);\n                    break;\n            }\n        }\n    },\n    // Webkit polyfill for lower fill range\n    updateRangeFill (target) {\n        // Get range from event if event passed\n        const range = is.event(target) ? target.target : target;\n        // Needs to be a valid <input type='range'>\n        if (!is.element(range) || range.getAttribute('type') !== 'range') {\n            return;\n        }\n        // Set aria values for https://github.com/sampotts/plyr/issues/905\n        if (matches(range, this.config.selectors.inputs.seek)) {\n            range.setAttribute('aria-valuenow', this.currentTime);\n            const currentTime = controls.formatTime(this.currentTime);\n            const duration = controls.formatTime(this.duration);\n            const format = i18n.get('seekLabel', this.config);\n            range.setAttribute('aria-valuetext', format.replace('{currentTime}', currentTime).replace('{duration}', duration));\n        } else if (matches(range, this.config.selectors.inputs.volume)) {\n            const percent = range.value * 100;\n            range.setAttribute('aria-valuenow', percent);\n            range.setAttribute('aria-valuetext', `${percent.toFixed(1)}%`);\n        } else {\n            range.setAttribute('aria-valuenow', range.value);\n        }\n        // WebKit only\n        if (!browser.isWebKit && !browser.isIPadOS) {\n            return;\n        }\n        // Set CSS custom property\n        range.style.setProperty('--value', `${range.value / range.max * 100}%`);\n    },\n    // Update hover tooltip for seeking\n    updateSeekTooltip (event) {\n        var _this$config$markers, _this$config$markers$;\n        // Bail if setting not true\n        if (!this.config.tooltips.seek || !is.element(this.elements.inputs.seek) || !is.element(this.elements.display.seekTooltip) || this.duration === 0) {\n            return;\n        }\n        const tipElement = this.elements.display.seekTooltip;\n        const visible = `${this.config.classNames.tooltip}--visible`;\n        const toggle = (show)=>toggleClass(tipElement, visible, show);\n        // Hide on touch\n        if (this.touch) {\n            toggle(false);\n            return;\n        }\n        // Determine percentage, if already visible\n        let percent = 0;\n        const clientRect = this.elements.progress.getBoundingClientRect();\n        if (is.event(event)) {\n            const scrollLeft = event.pageX - event.clientX;\n            percent = 100 / clientRect.width * (event.pageX - clientRect.left - scrollLeft);\n        } else if (hasClass(tipElement, visible)) {\n            percent = Number.parseFloat(tipElement.style.left, 10);\n        } else {\n            return;\n        }\n        // Set bounds\n        if (percent < 0) {\n            percent = 0;\n        } else if (percent > 100) {\n            percent = 100;\n        }\n        const time = this.duration / 100 * percent;\n        // Display the time a click would seek to\n        tipElement.textContent = controls.formatTime(time);\n        // Get marker point for time\n        const point = (_this$config$markers = this.config.markers) === null || _this$config$markers === void 0 ? void 0 : (_this$config$markers$ = _this$config$markers.points) === null || _this$config$markers$ === void 0 ? void 0 : _this$config$markers$.find(({ time: t })=>t === Math.round(time));\n        // Append the point label to the tooltip\n        if (point) {\n            tipElement.insertAdjacentHTML('afterbegin', `${point.label}<br>`);\n        }\n        // Set position\n        tipElement.style.left = `${percent}%`;\n        // Show/hide the tooltip\n        // If the event is a moues in/out and percentage is inside bounds\n        if (is.event(event) && [\n            'mouseenter',\n            'mouseleave'\n        ].includes(event.type)) {\n            toggle(event.type === 'mouseenter');\n        }\n    },\n    // Handle time change event\n    timeUpdate (event) {\n        // Only invert if only one time element is displayed and used for both duration and currentTime\n        const invert = !is.element(this.elements.display.duration) && this.config.invertTime;\n        // Duration\n        controls.updateTimeDisplay.call(this, this.elements.display.currentTime, invert ? this.duration - this.currentTime : this.currentTime, invert);\n        // Ignore updates while seeking\n        if (event && event.type === 'timeupdate' && this.media.seeking) {\n            return;\n        }\n        // Playing progress\n        controls.updateProgress.call(this, event);\n    },\n    // Show the duration on metadataloaded or durationchange events\n    durationUpdate () {\n        // Bail if no UI or durationchange event triggered after playing/seek when invertTime is false\n        if (!this.supported.ui || !this.config.invertTime && this.currentTime) {\n            return;\n        }\n        // If duration is the 2**32 (shaka), Infinity (HLS), DASH-IF (Number.MAX_SAFE_INTEGER || Number.MAX_VALUE) indicating live we hide the currentTime and progressbar.\n        // https://github.com/video-dev/hls.js/blob/5820d29d3c4c8a46e8b75f1e3afa3e68c1a9a2db/src/controller/buffer-controller.js#L415\n        // https://github.com/google/shaka-player/blob/4d889054631f4e1cf0fbd80ddd2b71887c02e232/lib/media/streaming_engine.js#L1062\n        // https://github.com/Dash-Industry-Forum/dash.js/blob/69859f51b969645b234666800d4cb596d89c602d/src/dash/models/DashManifestModel.js#L338\n        if (this.duration >= 2 ** 32) {\n            toggleHidden(this.elements.display.currentTime, true);\n            toggleHidden(this.elements.progress, true);\n            return;\n        }\n        // Update ARIA values\n        if (is.element(this.elements.inputs.seek)) {\n            this.elements.inputs.seek.setAttribute('aria-valuemax', this.duration);\n        }\n        // If there's a spot to display duration\n        const hasDuration = is.element(this.elements.display.duration);\n        // If there's only one time display, display duration there\n        if (!hasDuration && this.config.displayDuration && this.paused) {\n            controls.updateTimeDisplay.call(this, this.elements.display.currentTime, this.duration);\n        }\n        // If there's a duration element, update content\n        if (hasDuration) {\n            controls.updateTimeDisplay.call(this, this.elements.display.duration, this.duration);\n        }\n        if (this.config.markers.enabled) {\n            controls.setMarkers.call(this);\n        }\n        // Update the tooltip (if visible)\n        controls.updateSeekTooltip.call(this);\n    },\n    // Hide/show a tab\n    toggleMenuButton (setting, toggle) {\n        toggleHidden(this.elements.settings.buttons[setting], !toggle);\n    },\n    // Update the selected setting\n    updateSetting (setting, container, input) {\n        const pane = this.elements.settings.panels[setting];\n        let value = null;\n        let list = container;\n        if (setting === 'captions') {\n            value = this.currentTrack;\n        } else {\n            value = !is.empty(input) ? input : this[setting];\n            // Get default\n            if (is.empty(value)) {\n                value = this.config[setting].default;\n            }\n            // Unsupported value\n            if (!is.empty(this.options[setting]) && !this.options[setting].includes(value)) {\n                this.debug.warn(`Unsupported value of '${value}' for ${setting}`);\n                return;\n            }\n            // Disabled value\n            if (!this.config[setting].options.includes(value)) {\n                this.debug.warn(`Disabled value of '${value}' for ${setting}`);\n                return;\n            }\n        }\n        // Get the list if we need to\n        if (!is.element(list)) {\n            list = pane && pane.querySelector('[role=\"menu\"]');\n        }\n        // If there's no list it means it's not been rendered...\n        if (!is.element(list)) {\n            return;\n        }\n        // Update the label\n        const label = this.elements.settings.buttons[setting].querySelector(`.${this.config.classNames.menu.value}`);\n        label.innerHTML = controls.getLabel.call(this, setting, value);\n        // Find the radio option and check it\n        const target = list && list.querySelector(`[value=\"${value}\"]`);\n        if (is.element(target)) {\n            target.checked = true;\n        }\n    },\n    // Translate a value into a nice label\n    getLabel (setting, value) {\n        switch(setting){\n            case 'speed':\n                return value === 1 ? i18n.get('normal', this.config) : `${value}&times;`;\n            case 'quality':\n                if (is.number(value)) {\n                    const label = i18n.get(`qualityLabel.${value}`, this.config);\n                    if (!label.length) {\n                        return `${value}p`;\n                    }\n                    return label;\n                }\n                return toTitleCase(value);\n            case 'captions':\n                return captions.getLabel.call(this);\n            default:\n                return null;\n        }\n    },\n    // Set the quality menu\n    setQualityMenu (options) {\n        // Menu required\n        if (!is.element(this.elements.settings.panels.quality)) {\n            return;\n        }\n        const type = 'quality';\n        const list = this.elements.settings.panels.quality.querySelector('[role=\"menu\"]');\n        // Set options if passed and filter based on uniqueness and config\n        if (is.array(options)) {\n            this.options.quality = dedupe(options).filter((quality)=>this.config.quality.options.includes(quality));\n        }\n        // Toggle the pane and tab\n        const toggle = !is.empty(this.options.quality) && this.options.quality.length > 1;\n        controls.toggleMenuButton.call(this, type, toggle);\n        // Empty the menu\n        emptyElement(list);\n        // Check if we need to toggle the parent\n        controls.checkMenu.call(this);\n        // If we're hiding, nothing more to do\n        if (!toggle) {\n            return;\n        }\n        // Get the badge HTML for HD, 4K etc\n        const getBadge = (quality)=>{\n            const label = i18n.get(`qualityBadge.${quality}`, this.config);\n            if (!label.length) {\n                return null;\n            }\n            return controls.createBadge.call(this, label);\n        };\n        // Sort options by the config and then render options\n        this.options.quality.sort((a, b)=>{\n            const sorting = this.config.quality.options;\n            return sorting.indexOf(a) > sorting.indexOf(b) ? 1 : -1;\n        }).forEach((quality)=>{\n            controls.createMenuItem.call(this, {\n                value: quality,\n                list,\n                type,\n                title: controls.getLabel.call(this, 'quality', quality),\n                badge: getBadge(quality)\n            });\n        });\n        controls.updateSetting.call(this, type, list);\n    },\n    // Set the looping options\n    /* setLoopMenu() {\n        // Menu required\n        if (!is.element(this.elements.settings.panels.loop)) {\n            return;\n        }\n         const options = ['start', 'end', 'all', 'reset'];\n        const list = this.elements.settings.panels.loop.querySelector('[role=\"menu\"]');\n         // Show the pane and tab\n        toggleHidden(this.elements.settings.buttons.loop, false);\n        toggleHidden(this.elements.settings.panels.loop, false);\n         // Toggle the pane and tab\n        const toggle = !is.empty(this.loop.options);\n        controls.toggleMenuButton.call(this, 'loop', toggle);\n         // Empty the menu\n        emptyElement(list);\n         options.forEach(option => {\n            const item = createElement('li');\n             const button = createElement(\n                'button',\n                extend(getAttributesFromSelector(this.config.selectors.buttons.loop), {\n                    type: 'button',\n                    class: this.config.classNames.control,\n                    'data-plyr-loop-action': option,\n                }),\n                i18n.get(option, this.config)\n            );\n             if (['start', 'end'].includes(option)) {\n                const badge = controls.createBadge.call(this, '00:00');\n                button.appendChild(badge);\n            }\n             item.appendChild(button);\n            list.appendChild(item);\n        });\n    }, */ // Get current selected caption language\n    // TODO: rework this to user the getter in the API?\n    // Set a list of available captions languages\n    setCaptionsMenu () {\n        // Menu required\n        if (!is.element(this.elements.settings.panels.captions)) {\n            return;\n        }\n        // TODO: Captions or language? Currently it's mixed\n        const type = 'captions';\n        const list = this.elements.settings.panels.captions.querySelector('[role=\"menu\"]');\n        const tracks = captions.getTracks.call(this);\n        const toggle = Boolean(tracks.length);\n        // Toggle the pane and tab\n        controls.toggleMenuButton.call(this, type, toggle);\n        // Empty the menu\n        emptyElement(list);\n        // Check if we need to toggle the parent\n        controls.checkMenu.call(this);\n        // If there's no captions, bail\n        if (!toggle) {\n            return;\n        }\n        // Generate options data\n        const options = tracks.map((track, value)=>({\n                value,\n                checked: this.captions.toggled && this.currentTrack === value,\n                title: captions.getLabel.call(this, track),\n                badge: track.language && controls.createBadge.call(this, track.language.toUpperCase()),\n                list,\n                type: 'language'\n            }));\n        // Add the \"Disabled\" option to turn off captions\n        options.unshift({\n            value: -1,\n            checked: !this.captions.toggled,\n            title: i18n.get('disabled', this.config),\n            list,\n            type: 'language'\n        });\n        // Generate options\n        options.forEach(controls.createMenuItem.bind(this));\n        controls.updateSetting.call(this, type, list);\n    },\n    // Set a list of available captions languages\n    setSpeedMenu () {\n        // Menu required\n        if (!is.element(this.elements.settings.panels.speed)) {\n            return;\n        }\n        const type = 'speed';\n        const list = this.elements.settings.panels.speed.querySelector('[role=\"menu\"]');\n        // Filter out invalid speeds\n        this.options.speed = this.options.speed.filter((o)=>o >= this.minimumSpeed && o <= this.maximumSpeed);\n        // Toggle the pane and tab\n        const toggle = !is.empty(this.options.speed) && this.options.speed.length > 1;\n        controls.toggleMenuButton.call(this, type, toggle);\n        // Empty the menu\n        emptyElement(list);\n        // Check if we need to toggle the parent\n        controls.checkMenu.call(this);\n        // If we're hiding, nothing more to do\n        if (!toggle) {\n            return;\n        }\n        // Create items\n        this.options.speed.forEach((speed)=>{\n            controls.createMenuItem.call(this, {\n                value: speed,\n                list,\n                type,\n                title: controls.getLabel.call(this, 'speed', speed)\n            });\n        });\n        controls.updateSetting.call(this, type, list);\n    },\n    // Check if we need to hide/show the settings menu\n    checkMenu () {\n        const { buttons } = this.elements.settings;\n        const visible = !is.empty(buttons) && Object.values(buttons).some((button)=>!button.hidden);\n        toggleHidden(this.elements.settings.menu, !visible);\n    },\n    // Focus the first menu item in a given (or visible) menu\n    focusFirstMenuItem (pane, focusVisible = false) {\n        if (this.elements.settings.popup.hidden) {\n            return;\n        }\n        let target = pane;\n        if (!is.element(target)) {\n            target = Object.values(this.elements.settings.panels).find((p)=>!p.hidden);\n        }\n        const firstItem = target.querySelector('[role^=\"menuitem\"]');\n        setFocus.call(this, firstItem, focusVisible);\n    },\n    // Show/hide menu\n    toggleMenu (input) {\n        const { popup } = this.elements.settings;\n        const button = this.elements.buttons.settings;\n        // Menu and button are required\n        if (!is.element(popup) || !is.element(button)) {\n            return;\n        }\n        // True toggle by default\n        const { hidden } = popup;\n        let show = hidden;\n        if (is.boolean(input)) {\n            show = input;\n        } else if (is.keyboardEvent(input) && input.key === 'Escape') {\n            show = false;\n        } else if (is.event(input)) {\n            // If Plyr is in a shadowDOM, the event target is set to the component, instead of the\n            // Element in the shadowDOM. The path, if available, is complete.\n            const target = is.function(input.composedPath) ? input.composedPath()[0] : input.target;\n            const isMenuItem = popup.contains(target);\n            // If the click was inside the menu or if the click\n            // wasn't the button or menu item and we're trying to\n            // show the menu (a doc click shouldn't show the menu)\n            if (isMenuItem || !isMenuItem && input.target !== button && show) {\n                return;\n            }\n        }\n        // Set button attributes\n        button.setAttribute('aria-expanded', show);\n        // Show the actual popup\n        toggleHidden(popup, !show);\n        // Add class hook\n        toggleClass(this.elements.container, this.config.classNames.menu.open, show);\n        // Focus the first item if key interaction\n        if (show && is.keyboardEvent(input)) {\n            controls.focusFirstMenuItem.call(this, null, true);\n        } else if (!show && !hidden) {\n            // If closing, re-focus the button\n            setFocus.call(this, button, is.keyboardEvent(input));\n        }\n    },\n    // Get the natural size of a menu panel\n    getMenuSize (tab) {\n        const clone = tab.cloneNode(true);\n        clone.style.position = 'absolute';\n        clone.style.opacity = 0;\n        clone.removeAttribute('hidden');\n        // Append to parent so we get the \"real\" size\n        tab.parentNode.appendChild(clone);\n        // Get the sizes before we remove\n        const width = clone.scrollWidth;\n        const height = clone.scrollHeight;\n        // Remove from the DOM\n        removeElement(clone);\n        return {\n            width,\n            height\n        };\n    },\n    // Show a panel in the menu\n    showMenuPanel (type = '', focusVisible = false) {\n        const target = this.elements.container.querySelector(`#plyr-settings-${this.id}-${type}`);\n        // Nothing to show, bail\n        if (!is.element(target)) {\n            return;\n        }\n        // Hide all other panels\n        const container = target.parentNode;\n        const current = Array.from(container.children).find((node)=>!node.hidden);\n        // If we can do fancy animations, we'll animate the height/width\n        if (support.transitions && !support.reducedMotion) {\n            // Set the current width as a base\n            container.style.width = `${current.scrollWidth}px`;\n            container.style.height = `${current.scrollHeight}px`;\n            // Get potential sizes\n            const size = controls.getMenuSize.call(this, target);\n            // Restore auto height/width\n            const restore = (event)=>{\n                // We're only bothered about height and width on the container\n                if (event.target !== container || ![\n                    'width',\n                    'height'\n                ].includes(event.propertyName)) {\n                    return;\n                }\n                // Revert back to auto\n                container.style.width = '';\n                container.style.height = '';\n                // Only listen once\n                off.call(this, container, transitionEndEvent, restore);\n            };\n            // Listen for the transition finishing and restore auto height/width\n            on.call(this, container, transitionEndEvent, restore);\n            // Set dimensions to target\n            container.style.width = `${size.width}px`;\n            container.style.height = `${size.height}px`;\n        }\n        // Set attributes on current tab\n        toggleHidden(current, true);\n        // Set attributes on target\n        toggleHidden(target, false);\n        // Focus the first item\n        controls.focusFirstMenuItem.call(this, target, focusVisible);\n    },\n    // Set the download URL\n    setDownloadUrl () {\n        const button = this.elements.buttons.download;\n        // Bail if no button\n        if (!is.element(button)) {\n            return;\n        }\n        // Set attribute\n        button.setAttribute('href', this.download);\n    },\n    // Build the default HTML\n    create (data) {\n        const { bindMenuItemShortcuts, createButton, createProgress, createRange, createTime, setQualityMenu, setSpeedMenu, showMenuPanel } = controls;\n        this.elements.controls = null;\n        // Larger overlaid play button\n        if (is.array(this.config.controls) && this.config.controls.includes('play-large')) {\n            this.elements.container.appendChild(createButton.call(this, 'play-large'));\n        }\n        // Create the container\n        const container = createElement('div', getAttributesFromSelector(this.config.selectors.controls.wrapper));\n        this.elements.controls = container;\n        // Default item attributes\n        const defaultAttributes = {\n            class: 'plyr__controls__item'\n        };\n        // Loop through controls in order\n        dedupe(is.array(this.config.controls) ? this.config.controls : []).forEach((control)=>{\n            // Restart button\n            if (control === 'restart') {\n                container.appendChild(createButton.call(this, 'restart', defaultAttributes));\n            }\n            // Rewind button\n            if (control === 'rewind') {\n                container.appendChild(createButton.call(this, 'rewind', defaultAttributes));\n            }\n            // Play/Pause button\n            if (control === 'play') {\n                container.appendChild(createButton.call(this, 'play', defaultAttributes));\n            }\n            // Fast forward button\n            if (control === 'fast-forward') {\n                container.appendChild(createButton.call(this, 'fast-forward', defaultAttributes));\n            }\n            // Progress\n            if (control === 'progress') {\n                const progressContainer = createElement('div', {\n                    class: `${defaultAttributes.class} plyr__progress__container`\n                });\n                const progress = createElement('div', getAttributesFromSelector(this.config.selectors.progress));\n                // Seek range slider\n                progress.appendChild(createRange.call(this, 'seek', {\n                    id: `plyr-seek-${data.id}`\n                }));\n                // Buffer progress\n                progress.appendChild(createProgress.call(this, 'buffer'));\n                // TODO: Add loop display indicator\n                // Seek tooltip\n                if (this.config.tooltips.seek) {\n                    const tooltip = createElement('span', {\n                        class: this.config.classNames.tooltip\n                    }, '00:00');\n                    progress.appendChild(tooltip);\n                    this.elements.display.seekTooltip = tooltip;\n                }\n                this.elements.progress = progress;\n                progressContainer.appendChild(this.elements.progress);\n                container.appendChild(progressContainer);\n            }\n            // Media current time display\n            if (control === 'current-time') {\n                container.appendChild(createTime.call(this, 'currentTime', defaultAttributes));\n            }\n            // Media duration display\n            if (control === 'duration') {\n                container.appendChild(createTime.call(this, 'duration', defaultAttributes));\n            }\n            // Volume controls\n            if (control === 'mute' || control === 'volume') {\n                let { volume } = this.elements;\n                // Create the volume container if needed\n                if (!is.element(volume) || !container.contains(volume)) {\n                    volume = createElement('div', extend({}, defaultAttributes, {\n                        class: `${defaultAttributes.class} plyr__volume`.trim()\n                    }));\n                    this.elements.volume = volume;\n                    container.appendChild(volume);\n                }\n                // Toggle mute button\n                if (control === 'mute') {\n                    volume.appendChild(createButton.call(this, 'mute'));\n                }\n                // Volume range control\n                // Ignored on iOS as it's handled globally\n                // https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html\n                if (control === 'volume' && !browser.isIos && !browser.isIPadOS) {\n                    // Set the attributes\n                    const attributes = {\n                        max: 1,\n                        step: 0.05,\n                        value: this.config.volume\n                    };\n                    // Create the volume range slider\n                    volume.appendChild(createRange.call(this, 'volume', extend(attributes, {\n                        id: `plyr-volume-${data.id}`\n                    })));\n                }\n            }\n            // Toggle captions button\n            if (control === 'captions') {\n                container.appendChild(createButton.call(this, 'captions', defaultAttributes));\n            }\n            // Settings button / menu\n            if (control === 'settings' && !is.empty(this.config.settings)) {\n                const wrapper = createElement('div', extend({}, defaultAttributes, {\n                    class: `${defaultAttributes.class} plyr__menu`.trim(),\n                    hidden: ''\n                }));\n                wrapper.appendChild(createButton.call(this, 'settings', {\n                    'aria-haspopup': true,\n                    'aria-controls': `plyr-settings-${data.id}`,\n                    'aria-expanded': false\n                }));\n                const popup = createElement('div', {\n                    class: 'plyr__menu__container',\n                    id: `plyr-settings-${data.id}`,\n                    hidden: ''\n                });\n                const inner = createElement('div');\n                const home = createElement('div', {\n                    id: `plyr-settings-${data.id}-home`\n                });\n                // Create the menu\n                const menu = createElement('div', {\n                    role: 'menu'\n                });\n                home.appendChild(menu);\n                inner.appendChild(home);\n                this.elements.settings.panels.home = home;\n                // Build the menu items\n                this.config.settings.forEach((type)=>{\n                    // TODO: bundle this with the createMenuItem helper and bindings\n                    const menuItem = createElement('button', extend(getAttributesFromSelector(this.config.selectors.buttons.settings), {\n                        'type': 'button',\n                        'class': `${this.config.classNames.control} ${this.config.classNames.control}--forward`,\n                        'role': 'menuitem',\n                        'aria-haspopup': true,\n                        'hidden': ''\n                    }));\n                    // Bind menu shortcuts for keyboard users\n                    bindMenuItemShortcuts.call(this, menuItem, type);\n                    // Show menu on click\n                    on.call(this, menuItem, 'click', ()=>{\n                        showMenuPanel.call(this, type, false);\n                    });\n                    const flex = createElement('span', null, i18n.get(type, this.config));\n                    const value = createElement('span', {\n                        class: this.config.classNames.menu.value\n                    });\n                    // Speed contains HTML entities\n                    value.innerHTML = data[type];\n                    flex.appendChild(value);\n                    menuItem.appendChild(flex);\n                    menu.appendChild(menuItem);\n                    // Build the panes\n                    const pane = createElement('div', {\n                        id: `plyr-settings-${data.id}-${type}`,\n                        hidden: ''\n                    });\n                    // Back button\n                    const backButton = createElement('button', {\n                        type: 'button',\n                        class: `${this.config.classNames.control} ${this.config.classNames.control}--back`\n                    });\n                    // Visible label\n                    backButton.appendChild(createElement('span', {\n                        'aria-hidden': true\n                    }, i18n.get(type, this.config)));\n                    // Screen reader label\n                    backButton.appendChild(createElement('span', {\n                        class: this.config.classNames.hidden\n                    }, i18n.get('menuBack', this.config)));\n                    // Go back via keyboard\n                    on.call(this, pane, 'keydown', (event)=>{\n                        if (event.key !== 'ArrowLeft') return;\n                        // Prevent seek\n                        event.preventDefault();\n                        event.stopPropagation();\n                        // Show the respective menu\n                        showMenuPanel.call(this, 'home', true);\n                    }, false);\n                    // Go back via button click\n                    on.call(this, backButton, 'click', ()=>{\n                        showMenuPanel.call(this, 'home', false);\n                    });\n                    // Add to pane\n                    pane.appendChild(backButton);\n                    // Menu\n                    pane.appendChild(createElement('div', {\n                        role: 'menu'\n                    }));\n                    inner.appendChild(pane);\n                    this.elements.settings.buttons[type] = menuItem;\n                    this.elements.settings.panels[type] = pane;\n                });\n                popup.appendChild(inner);\n                wrapper.appendChild(popup);\n                container.appendChild(wrapper);\n                this.elements.settings.popup = popup;\n                this.elements.settings.menu = wrapper;\n            }\n            // Picture in picture button\n            if (control === 'pip' && support.pip) {\n                container.appendChild(createButton.call(this, 'pip', defaultAttributes));\n            }\n            // Airplay button\n            if (control === 'airplay' && support.airplay) {\n                container.appendChild(createButton.call(this, 'airplay', defaultAttributes));\n            }\n            // Download button\n            if (control === 'download') {\n                const attributes = extend({}, defaultAttributes, {\n                    element: 'a',\n                    href: this.download,\n                    target: '_blank'\n                });\n                // Set download attribute for HTML5 only\n                if (this.isHTML5) {\n                    attributes.download = '';\n                }\n                const { download } = this.config.urls;\n                if (!is.url(download) && this.isEmbed) {\n                    extend(attributes, {\n                        icon: `logo-${this.provider}`,\n                        label: this.provider\n                    });\n                }\n                container.appendChild(createButton.call(this, 'download', attributes));\n            }\n            // Toggle fullscreen button\n            if (control === 'fullscreen') {\n                container.appendChild(createButton.call(this, 'fullscreen', defaultAttributes));\n            }\n        });\n        // Set available quality levels\n        if (this.isHTML5) {\n            setQualityMenu.call(this, html5.getQualityOptions.call(this));\n        }\n        setSpeedMenu.call(this);\n        return container;\n    },\n    // Insert controls\n    inject () {\n        // Sprite\n        if (this.config.loadSprite) {\n            const icon = controls.getIconUrl.call(this);\n            // Only load external sprite using AJAX\n            if (icon.cors) {\n                loadSprite(icon.url, 'sprite-plyr');\n            }\n        }\n        // Create a unique ID\n        this.id = Math.floor(Math.random() * 10000);\n        // Null by default\n        let container = null;\n        this.elements.controls = null;\n        // Set template properties\n        const props = {\n            id: this.id,\n            seektime: this.config.seekTime,\n            title: this.config.title\n        };\n        let update = true;\n        // If function, run it and use output\n        if (is.function(this.config.controls)) {\n            this.config.controls = this.config.controls.call(this, props);\n        }\n        // Convert falsy controls to empty array (primarily for empty strings)\n        if (!this.config.controls) {\n            this.config.controls = [];\n        }\n        if (is.element(this.config.controls) || is.string(this.config.controls)) {\n            // HTMLElement or Non-empty string passed as the option\n            container = this.config.controls;\n        } else {\n            // Create controls\n            container = controls.create.call(this, {\n                id: this.id,\n                seektime: this.config.seekTime,\n                speed: this.speed,\n                quality: this.quality,\n                captions: captions.getLabel.call(this)\n            });\n            update = false;\n        }\n        // Replace props with their value\n        const replace = (input)=>{\n            let result = input;\n            Object.entries(props).forEach(([key, value])=>{\n                result = replaceAll(result, `{${key}}`, value);\n            });\n            return result;\n        };\n        // Update markup\n        if (update) {\n            if (is.string(this.config.controls)) {\n                container = replace(container);\n            }\n        }\n        // Controls container\n        let target;\n        // Inject to custom location\n        if (is.string(this.config.selectors.controls.container)) {\n            target = document.querySelector(this.config.selectors.controls.container);\n        }\n        // Inject into the container by default\n        if (!is.element(target)) {\n            target = this.elements.container;\n        }\n        // Inject controls HTML (needs to be before captions, hence \"afterbegin\")\n        const insertMethod = is.element(container) ? 'insertAdjacentElement' : 'insertAdjacentHTML';\n        target[insertMethod]('afterbegin', container);\n        // Find the elements if need be\n        if (!is.element(this.elements.controls)) {\n            controls.findElements.call(this);\n        }\n        // Add pressed property to buttons\n        if (!is.empty(this.elements.buttons)) {\n            const addProperty = (button)=>{\n                const className = this.config.classNames.controlPressed;\n                button.setAttribute('aria-pressed', 'false');\n                Object.defineProperty(button, 'pressed', {\n                    configurable: true,\n                    enumerable: true,\n                    get () {\n                        return hasClass(button, className);\n                    },\n                    set (pressed = false) {\n                        toggleClass(button, className, pressed);\n                        button.setAttribute('aria-pressed', pressed ? 'true' : 'false');\n                    }\n                });\n            };\n            // Toggle classname when pressed property is set\n            Object.values(this.elements.buttons).filter(Boolean).forEach((button)=>{\n                if (is.array(button) || is.nodeList(button)) {\n                    Array.from(button).filter(Boolean).forEach(addProperty);\n                } else {\n                    addProperty(button);\n                }\n            });\n        }\n        // Edge sometimes doesn't finish the paint so force a repaint\n        if (browser.isEdge) {\n            repaint(target);\n        }\n        // Setup tooltips\n        if (this.config.tooltips.controls) {\n            const { classNames, selectors } = this.config;\n            const selector = `${selectors.controls.wrapper} ${selectors.labels} .${classNames.hidden}`;\n            const labels = getElements.call(this, selector);\n            Array.from(labels).forEach((label)=>{\n                toggleClass(label, this.config.classNames.hidden, false);\n                toggleClass(label, this.config.classNames.tooltip, true);\n            });\n        }\n    },\n    // Set media metadata\n    setMediaMetadata () {\n        try {\n            if ('mediaSession' in navigator) {\n                navigator.mediaSession.metadata = new window.MediaMetadata({\n                    title: this.config.mediaMetadata.title,\n                    artist: this.config.mediaMetadata.artist,\n                    album: this.config.mediaMetadata.album,\n                    artwork: this.config.mediaMetadata.artwork\n                });\n            }\n        } catch  {\n        // Do nothing\n        }\n    },\n    // Add markers\n    setMarkers () {\n        var _this$config$markers2, _this$config$markers3;\n        if (!this.duration || this.elements.markers) return;\n        // Get valid points\n        const points = (_this$config$markers2 = this.config.markers) === null || _this$config$markers2 === void 0 ? void 0 : (_this$config$markers3 = _this$config$markers2.points) === null || _this$config$markers3 === void 0 ? void 0 : _this$config$markers3.filter(({ time })=>time > 0 && time < this.duration);\n        if (!(points !== null && points !== void 0 && points.length)) return;\n        const containerFragment = document.createDocumentFragment();\n        const pointsFragment = document.createDocumentFragment();\n        let tipElement = null;\n        const tipVisible = `${this.config.classNames.tooltip}--visible`;\n        const toggleTip = (show)=>toggleClass(tipElement, tipVisible, show);\n        // Inject markers to progress container\n        points.forEach((point)=>{\n            const markerElement = createElement('span', {\n                class: this.config.classNames.marker\n            }, '');\n            const left = `${point.time / this.duration * 100}%`;\n            if (tipElement) {\n                // Show on hover\n                markerElement.addEventListener('mouseenter', ()=>{\n                    if (point.label) return;\n                    tipElement.style.left = left;\n                    tipElement.innerHTML = point.label;\n                    toggleTip(true);\n                });\n                // Hide on leave\n                markerElement.addEventListener('mouseleave', ()=>{\n                    toggleTip(false);\n                });\n            }\n            markerElement.addEventListener('click', ()=>{\n                this.currentTime = point.time;\n            });\n            markerElement.style.left = left;\n            pointsFragment.appendChild(markerElement);\n        });\n        containerFragment.appendChild(pointsFragment);\n        // Inject a tooltip if needed\n        if (!this.config.tooltips.seek) {\n            tipElement = createElement('span', {\n                class: this.config.classNames.tooltip\n            }, '');\n            containerFragment.appendChild(tipElement);\n        }\n        this.elements.markers = {\n            points: pointsFragment,\n            tip: tipElement\n        };\n        this.elements.progress.appendChild(containerFragment);\n    }\n};\n// ==========================================================================\n// URL utils\n// ==========================================================================\n/**\n * Parse a string to a URL object\n * @param {string} input - the URL to be parsed\n * @param {boolean} safe - failsafe parsing\n */ function parseUrl(input, safe = true) {\n    let url = input;\n    if (safe) {\n        const parser = document.createElement('a');\n        parser.href = url;\n        url = parser.href;\n    }\n    try {\n        return new URL(url);\n    } catch  {\n        return null;\n    }\n}\n// Convert object to URLSearchParams\nfunction buildUrlParams(input) {\n    const params = new URLSearchParams();\n    if (is.object(input)) {\n        Object.entries(input).forEach(([key, value])=>{\n            params.set(key, value);\n        });\n    }\n    return params;\n}\n// ==========================================================================\n// Plyr Captions\n// TODO: Create as class\n// ==========================================================================\nconst captions = {\n    // Setup captions\n    setup () {\n        // Requires UI support\n        if (!this.supported.ui) {\n            return;\n        }\n        // Only Vimeo and HTML5 video supported at this point\n        if (!this.isVideo || this.isYouTube || this.isHTML5 && !support.textTracks) {\n            // Clear menu and hide\n            if (is.array(this.config.controls) && this.config.controls.includes('settings') && this.config.settings.includes('captions')) {\n                controls.setCaptionsMenu.call(this);\n            }\n            return;\n        }\n        // Inject the container\n        if (!is.element(this.elements.captions)) {\n            this.elements.captions = createElement('div', getAttributesFromSelector(this.config.selectors.captions));\n            this.elements.captions.setAttribute('dir', 'auto');\n            insertAfter(this.elements.captions, this.elements.wrapper);\n        }\n        // Fix IE captions if CORS is used\n        // Fetch captions and inject as blobs instead (data URIs not supported!)\n        if (browser.isIE && window.URL) {\n            const elements = this.media.querySelectorAll('track');\n            Array.from(elements).forEach((track)=>{\n                const src = track.getAttribute('src');\n                const url = parseUrl(src);\n                if (url !== null && url.hostname !== window.location.href.hostname && [\n                    'http:',\n                    'https:'\n                ].includes(url.protocol)) {\n                    fetch(src, 'blob').then((blob)=>{\n                        track.setAttribute('src', window.URL.createObjectURL(blob));\n                    }).catch(()=>{\n                        removeElement(track);\n                    });\n                }\n            });\n        }\n        // Get and set initial data\n        // The \"preferred\" options are not realized unless / until the wanted language has a match\n        // * languages: Array of user's browser languages.\n        // * language:  The language preferred by user settings or config\n        // * active:    The state preferred by user settings or config\n        // * toggled:   The real captions state\n        const browserLanguages = navigator.languages || [\n            navigator.language || navigator.userLanguage || 'en'\n        ];\n        const languages = dedupe(browserLanguages.map((language)=>language.split('-')[0]));\n        let language = (this.storage.get('language') || this.captions.language || this.config.captions.language || 'auto').toLowerCase();\n        // Use first browser language when language is 'auto'\n        if (language === 'auto') {\n            [language] = languages;\n        }\n        let active = this.storage.get('captions') || this.captions.active;\n        if (!is.boolean(active)) {\n            ({ active } = this.config.captions);\n        }\n        Object.assign(this.captions, {\n            toggled: false,\n            active,\n            language,\n            languages\n        });\n        // Watch changes to textTracks and update captions menu\n        if (this.isHTML5) {\n            const trackEvents = this.config.captions.update ? 'addtrack removetrack' : 'removetrack';\n            on.call(this, this.media.textTracks, trackEvents, captions.update.bind(this));\n        }\n        // Update available languages in list next tick (the event must not be triggered before the listeners)\n        setTimeout(captions.update.bind(this), 0);\n    },\n    // Update available language options in settings based on tracks\n    update () {\n        const tracks = captions.getTracks.call(this, true);\n        // Get the wanted language\n        const { active, language, meta, currentTrackNode } = this.captions;\n        const languageExists = Boolean(tracks.find((track)=>track.language === language));\n        // Handle tracks (add event listener and \"pseudo\"-default)\n        if (this.isHTML5 && this.isVideo) {\n            tracks.filter((track)=>!meta.get(track)).forEach((track)=>{\n                this.debug.log('Track added', track);\n                // Attempt to store if the original dom element was \"default\"\n                meta.set(track, {\n                    default: track.mode === 'showing'\n                });\n                // Turn off native caption rendering to avoid double captions\n                // Note: mode='hidden' forces a track to download. To ensure every track\n                // isn't downloaded at once, only 'showing' tracks should be reassigned\n                if (track.mode === 'showing') {\n                    track.mode = 'hidden';\n                }\n                // Add event listener for cue changes\n                on.call(this, track, 'cuechange', ()=>captions.updateCues.call(this));\n            });\n        }\n        // Update language first time it matches, or if the previous matching track was removed\n        if (languageExists && this.language !== language || !tracks.includes(currentTrackNode)) {\n            captions.setLanguage.call(this, language);\n            captions.toggle.call(this, active && languageExists);\n        }\n        // Enable or disable captions based on track length\n        if (this.elements) {\n            toggleClass(this.elements.container, this.config.classNames.captions.enabled, !is.empty(tracks));\n        }\n        // Update available languages in list\n        if (is.array(this.config.controls) && this.config.controls.includes('settings') && this.config.settings.includes('captions')) {\n            controls.setCaptionsMenu.call(this);\n        }\n    },\n    // Toggle captions display\n    // Used internally for the toggleCaptions method, with the passive option forced to false\n    toggle (input, passive = true) {\n        // If there's no full support\n        if (!this.supported.ui) {\n            return;\n        }\n        const { toggled } = this.captions; // Current state\n        const activeClass = this.config.classNames.captions.active;\n        // Get the next state\n        // If the method is called without parameter, toggle based on current value\n        const active = is.nullOrUndefined(input) ? !toggled : input;\n        // Update state and trigger event\n        if (active !== toggled) {\n            // When passive, don't override user preferences\n            if (!passive) {\n                this.captions.active = active;\n                this.storage.set({\n                    captions: active\n                });\n            }\n            // Force language if the call isn't passive and there is no matching language to toggle to\n            if (!this.language && active && !passive) {\n                const tracks = captions.getTracks.call(this);\n                const track = captions.findTrack.call(this, [\n                    this.captions.language,\n                    ...this.captions.languages\n                ], true);\n                // Override user preferences to avoid switching languages if a matching track is added\n                this.captions.language = track.language;\n                // Set caption, but don't store in localStorage as user preference\n                captions.set.call(this, tracks.indexOf(track));\n                return;\n            }\n            // Toggle button if it's enabled\n            if (this.elements.buttons.captions) {\n                this.elements.buttons.captions.pressed = active;\n            }\n            // Add class hook\n            toggleClass(this.elements.container, activeClass, active);\n            this.captions.toggled = active;\n            // Update settings menu\n            controls.updateSetting.call(this, 'captions');\n            // Trigger event (not used internally)\n            triggerEvent.call(this, this.media, active ? 'captionsenabled' : 'captionsdisabled');\n        }\n        // Wait for the call stack to clear before setting mode='hidden'\n        // on the active track - forcing the browser to download it\n        setTimeout(()=>{\n            if (active && this.captions.toggled) {\n                this.captions.currentTrackNode.mode = 'hidden';\n            }\n        });\n    },\n    // Set captions by track index\n    // Used internally for the currentTrack setter with the passive option forced to false\n    set (index, passive = true) {\n        const tracks = captions.getTracks.call(this);\n        // Disable captions if setting to -1\n        if (index === -1) {\n            captions.toggle.call(this, false, passive);\n            return;\n        }\n        if (!is.number(index)) {\n            this.debug.warn('Invalid caption argument', index);\n            return;\n        }\n        if (!(index in tracks)) {\n            this.debug.warn('Track not found', index);\n            return;\n        }\n        if (this.captions.currentTrack !== index) {\n            this.captions.currentTrack = index;\n            const track = tracks[index];\n            const { language } = track || {};\n            // Store reference to node for invalidation on remove\n            this.captions.currentTrackNode = track;\n            // Update settings menu\n            controls.updateSetting.call(this, 'captions');\n            // When passive, don't override user preferences\n            if (!passive) {\n                this.captions.language = language;\n                this.storage.set({\n                    language\n                });\n            }\n            // Handle Vimeo captions\n            if (this.isVimeo) {\n                // Enable text track but don't render captions within the player\n                // Since we handle that ourselves\n                this.embed.enableTextTrack(language, null, false);\n            }\n            // Trigger event\n            triggerEvent.call(this, this.media, 'languagechange');\n        }\n        // Show captions\n        captions.toggle.call(this, true, passive);\n        if (this.isHTML5 && this.isVideo) {\n            // If we change the active track while a cue is already displayed we need to update it\n            captions.updateCues.call(this);\n        }\n    },\n    // Set captions by language\n    // Used internally for the language setter with the passive option forced to false\n    setLanguage (input, passive = true) {\n        if (!is.string(input)) {\n            this.debug.warn('Invalid language argument', input);\n            return;\n        }\n        // Normalize\n        const language = input.toLowerCase();\n        this.captions.language = language;\n        // Set currentTrack\n        const tracks = captions.getTracks.call(this);\n        const track = captions.findTrack.call(this, [\n            language\n        ]);\n        captions.set.call(this, tracks.indexOf(track), passive);\n    },\n    // Get current valid caption tracks\n    // If update is false it will also ignore tracks without metadata\n    // This is used to \"freeze\" the language options when captions.update is false\n    getTracks (update = false) {\n        // Handle media or textTracks missing or null\n        const tracks = Array.from((this.media || {}).textTracks || []);\n        // For HTML5, use cache instead of current tracks when it exists (if captions.update is false)\n        // Filter out removed tracks and tracks that aren't captions/subtitles (for example metadata)\n        return tracks.filter((track)=>!this.isHTML5 || update || this.captions.meta.has(track)).filter((track)=>[\n                'captions',\n                'subtitles'\n            ].includes(track.kind));\n    },\n    // Match tracks based on languages and get the first\n    findTrack (languages, force = false) {\n        const tracks = captions.getTracks.call(this);\n        const sortIsDefault = (track)=>Number((this.captions.meta.get(track) || {}).default);\n        const sorted = Array.from(tracks).sort((a, b)=>sortIsDefault(b) - sortIsDefault(a));\n        let track;\n        languages.every((language)=>{\n            track = sorted.find((t)=>t.language === language);\n            return !track; // Break iteration if there is a match\n        });\n        // If no match is found but is required, get first\n        return track || (force ? sorted[0] : undefined);\n    },\n    // Get the current track\n    getCurrentTrack () {\n        return captions.getTracks.call(this)[this.currentTrack];\n    },\n    // Get UI label for track\n    getLabel (track) {\n        let currentTrack = track;\n        if (!is.track(currentTrack) && support.textTracks && this.captions.toggled) {\n            currentTrack = captions.getCurrentTrack.call(this);\n        }\n        if (is.track(currentTrack)) {\n            if (!is.empty(currentTrack.label)) {\n                return currentTrack.label;\n            }\n            if (!is.empty(currentTrack.language)) {\n                return track.language.toUpperCase();\n            }\n            return i18n.get('enabled', this.config);\n        }\n        return i18n.get('disabled', this.config);\n    },\n    // Update captions using current track's active cues\n    // Also optional array argument in case there isn't any track (ex: vimeo)\n    updateCues (input) {\n        // Requires UI\n        if (!this.supported.ui) {\n            return;\n        }\n        if (!is.element(this.elements.captions)) {\n            this.debug.warn('No captions element to render to');\n            return;\n        }\n        // Only accept array or empty input\n        if (!is.nullOrUndefined(input) && !Array.isArray(input)) {\n            this.debug.warn('updateCues: Invalid input', input);\n            return;\n        }\n        let cues = input;\n        // Get cues from track\n        if (!cues) {\n            const track = captions.getCurrentTrack.call(this);\n            cues = Array.from((track || {}).activeCues || []).map((cue)=>cue.getCueAsHTML()).map(getHTML);\n        }\n        // Set new caption text\n        const content = cues.map((cueText)=>cueText.trim()).join('\\n');\n        const changed = content !== this.elements.captions.innerHTML;\n        if (changed) {\n            // Empty the container and create a new child element\n            emptyElement(this.elements.captions);\n            const caption = createElement('span', getAttributesFromSelector(this.config.selectors.caption));\n            caption.innerHTML = content;\n            this.elements.captions.appendChild(caption);\n            // Trigger event\n            triggerEvent.call(this, this.media, 'cuechange');\n        }\n    }\n};\n// ==========================================================================\n// Plyr default config\n// ==========================================================================\nconst defaults = {\n    // Disable\n    enabled: true,\n    // Custom media title\n    title: '',\n    // Logging to console\n    debug: false,\n    // Auto play (if supported)\n    autoplay: false,\n    // Only allow one media playing at once (vimeo only)\n    autopause: true,\n    // Allow inline playback on iOS\n    playsinline: true,\n    // Default time to skip when rewind/fast forward\n    seekTime: 10,\n    // Default volume\n    volume: 1,\n    muted: false,\n    // Pass a custom duration\n    duration: null,\n    // Display the media duration on load in the current time position\n    // If you have opted to display both duration and currentTime, this is ignored\n    displayDuration: true,\n    // Invert the current time to be a countdown\n    invertTime: true,\n    // Clicking the currentTime inverts it's value to show time left rather than elapsed\n    toggleInvert: true,\n    // Force an aspect ratio\n    // The format must be `'w:h'` (e.g. `'16:9'`)\n    ratio: null,\n    // Click video container to play/pause\n    clickToPlay: true,\n    // Auto hide the controls\n    hideControls: true,\n    // Reset to start when playback ended\n    resetOnEnd: false,\n    // Disable the standard context menu\n    disableContextMenu: true,\n    // Sprite (for icons)\n    loadSprite: true,\n    iconPrefix: 'plyr',\n    iconUrl: 'https://cdn.plyr.io/3.8.4/plyr.svg',\n    // Blank video (used to prevent errors on source change)\n    blankVideo: 'https://cdn.plyr.io/static/blank.mp4',\n    // Quality default\n    quality: {\n        default: 576,\n        // The options to display in the UI, if available for the source media\n        options: [\n            4320,\n            2880,\n            2160,\n            1440,\n            1080,\n            720,\n            576,\n            480,\n            360,\n            240\n        ],\n        forced: false,\n        onChange: null\n    },\n    // Set loops\n    loop: {\n        active: false\n    },\n    // Speed default and options to display\n    speed: {\n        selected: 1,\n        // The options to display in the UI, if available for the source media (e.g. Vimeo and YouTube only support 0.5x-4x)\n        options: [\n            0.5,\n            0.75,\n            1,\n            1.25,\n            1.5,\n            1.75,\n            2,\n            4\n        ]\n    },\n    // Keyboard shortcut settings\n    keyboard: {\n        focused: true,\n        global: false\n    },\n    // Display tooltips\n    tooltips: {\n        controls: false,\n        seek: true\n    },\n    // Captions settings\n    captions: {\n        active: false,\n        language: 'auto',\n        // Listen to new tracks added after Plyr is initialized.\n        // This is needed for streaming captions, but may result in unselectable options\n        update: false\n    },\n    // Fullscreen settings\n    fullscreen: {\n        enabled: true,\n        // Allow fullscreen?\n        fallback: true,\n        // Fallback using full viewport/window\n        iosNative: false // Use the native fullscreen in iOS (disables custom controls)\n    },\n    // Local storage\n    storage: {\n        enabled: true,\n        key: 'plyr'\n    },\n    // Default controls\n    controls: [\n        'play-large',\n        // 'restart',\n        // 'rewind',\n        'play',\n        // 'fast-forward',\n        'progress',\n        'current-time',\n        // 'duration',\n        'mute',\n        'volume',\n        'captions',\n        'settings',\n        'pip',\n        'airplay',\n        // 'download',\n        'fullscreen'\n    ],\n    settings: [\n        'captions',\n        'quality',\n        'speed'\n    ],\n    // Localisation\n    i18n: {\n        restart: 'Restart',\n        rewind: 'Rewind {seektime}s',\n        play: 'Play',\n        pause: 'Pause',\n        fastForward: 'Forward {seektime}s',\n        seek: 'Seek',\n        seekLabel: '{currentTime} of {duration}',\n        played: 'Played',\n        buffered: 'Buffered',\n        currentTime: 'Current time',\n        duration: 'Duration',\n        volume: 'Volume',\n        mute: 'Mute',\n        unmute: 'Unmute',\n        enableCaptions: 'Enable captions',\n        disableCaptions: 'Disable captions',\n        download: 'Download',\n        enterFullscreen: 'Enter fullscreen',\n        exitFullscreen: 'Exit fullscreen',\n        frameTitle: 'Player for {title}',\n        captions: 'Captions',\n        settings: 'Settings',\n        pip: 'PIP',\n        menuBack: 'Go back to previous menu',\n        speed: 'Speed',\n        normal: 'Normal',\n        quality: 'Quality',\n        loop: 'Loop',\n        start: 'Start',\n        end: 'End',\n        all: 'All',\n        reset: 'Reset',\n        disabled: 'Disabled',\n        enabled: 'Enabled',\n        advertisement: 'Ad',\n        qualityBadge: {\n            2160: '4K',\n            1440: 'HD',\n            1080: 'HD',\n            720: 'HD',\n            576: 'SD',\n            480: 'SD'\n        }\n    },\n    // URLs\n    urls: {\n        download: null,\n        vimeo: {\n            sdk: 'https://player.vimeo.com/api/player.js',\n            iframe: 'https://player.vimeo.com/video/{0}?{1}',\n            api: 'https://vimeo.com/api/oembed.json?url={0}'\n        },\n        youtube: {\n            sdk: 'https://www.youtube.com/iframe_api',\n            api: 'https://noembed.com/embed?url=https://www.youtube.com/watch?v={0}'\n        },\n        googleIMA: {\n            sdk: 'https://imasdk.googleapis.com/js/sdkloader/ima3.js'\n        }\n    },\n    // Custom control listeners\n    listeners: {\n        seek: null,\n        play: null,\n        pause: null,\n        restart: null,\n        rewind: null,\n        fastForward: null,\n        mute: null,\n        volume: null,\n        captions: null,\n        download: null,\n        fullscreen: null,\n        pip: null,\n        airplay: null,\n        speed: null,\n        quality: null,\n        loop: null,\n        language: null\n    },\n    // Events to watch and bubble\n    events: [\n        // Events to watch on HTML5 media elements and bubble\n        // https://developer.mozilla.org/en/docs/Web/Guide/Events/Media_events\n        'ended',\n        'progress',\n        'stalled',\n        'playing',\n        'waiting',\n        'canplay',\n        'canplaythrough',\n        'loadstart',\n        'loadeddata',\n        'loadedmetadata',\n        'timeupdate',\n        'volumechange',\n        'play',\n        'pause',\n        'error',\n        'seeking',\n        'seeked',\n        'emptied',\n        'ratechange',\n        'cuechange',\n        // Custom events\n        'download',\n        'enterfullscreen',\n        'exitfullscreen',\n        'captionsenabled',\n        'captionsdisabled',\n        'languagechange',\n        'controlshidden',\n        'controlsshown',\n        'ready',\n        // YouTube\n        'statechange',\n        // Quality\n        'qualitychange',\n        // Ads\n        'adsloaded',\n        'adscontentpause',\n        'adscontentresume',\n        'adstarted',\n        'adsmidpoint',\n        'adscomplete',\n        'adsallcomplete',\n        'adsimpression',\n        'adsclick'\n    ],\n    // Selectors\n    // Change these to match your template if using custom HTML\n    selectors: {\n        editable: 'input, textarea, select, [contenteditable]',\n        container: '.plyr',\n        controls: {\n            container: null,\n            wrapper: '.plyr__controls'\n        },\n        labels: '[data-plyr]',\n        buttons: {\n            play: '[data-plyr=\"play\"]',\n            pause: '[data-plyr=\"pause\"]',\n            restart: '[data-plyr=\"restart\"]',\n            rewind: '[data-plyr=\"rewind\"]',\n            fastForward: '[data-plyr=\"fast-forward\"]',\n            mute: '[data-plyr=\"mute\"]',\n            captions: '[data-plyr=\"captions\"]',\n            download: '[data-plyr=\"download\"]',\n            fullscreen: '[data-plyr=\"fullscreen\"]',\n            pip: '[data-plyr=\"pip\"]',\n            airplay: '[data-plyr=\"airplay\"]',\n            settings: '[data-plyr=\"settings\"]',\n            loop: '[data-plyr=\"loop\"]'\n        },\n        inputs: {\n            seek: '[data-plyr=\"seek\"]',\n            volume: '[data-plyr=\"volume\"]',\n            speed: '[data-plyr=\"speed\"]',\n            language: '[data-plyr=\"language\"]',\n            quality: '[data-plyr=\"quality\"]'\n        },\n        display: {\n            currentTime: '.plyr__time--current',\n            duration: '.plyr__time--duration',\n            buffer: '.plyr__progress__buffer',\n            loop: '.plyr__progress__loop',\n            // Used later\n            volume: '.plyr__volume--display'\n        },\n        progress: '.plyr__progress',\n        captions: '.plyr__captions',\n        caption: '.plyr__caption'\n    },\n    // Class hooks added to the player in different states\n    classNames: {\n        type: 'plyr--{0}',\n        provider: 'plyr--{0}',\n        video: 'plyr__video-wrapper',\n        embed: 'plyr__video-embed',\n        videoFixedRatio: 'plyr__video-wrapper--fixed-ratio',\n        embedContainer: 'plyr__video-embed__container',\n        poster: 'plyr__poster',\n        posterEnabled: 'plyr__poster-enabled',\n        ads: 'plyr__ads',\n        control: 'plyr__control',\n        controlPressed: 'plyr__control--pressed',\n        playing: 'plyr--playing',\n        paused: 'plyr--paused',\n        stopped: 'plyr--stopped',\n        loading: 'plyr--loading',\n        hover: 'plyr--hover',\n        tooltip: 'plyr__tooltip',\n        cues: 'plyr__cues',\n        marker: 'plyr__progress__marker',\n        hidden: 'plyr__sr-only',\n        hideControls: 'plyr--hide-controls',\n        isTouch: 'plyr--is-touch',\n        uiSupported: 'plyr--full-ui',\n        noTransition: 'plyr--no-transition',\n        display: {\n            time: 'plyr__time'\n        },\n        menu: {\n            value: 'plyr__menu__value',\n            badge: 'plyr__badge',\n            open: 'plyr--menu-open'\n        },\n        captions: {\n            enabled: 'plyr--captions-enabled',\n            active: 'plyr--captions-active'\n        },\n        fullscreen: {\n            enabled: 'plyr--fullscreen-enabled',\n            fallback: 'plyr--fullscreen-fallback'\n        },\n        pip: {\n            supported: 'plyr--pip-supported',\n            active: 'plyr--pip-active'\n        },\n        airplay: {\n            supported: 'plyr--airplay-supported',\n            active: 'plyr--airplay-active'\n        },\n        previewThumbnails: {\n            // Tooltip thumbs\n            thumbContainer: 'plyr__preview-thumb',\n            thumbContainerShown: 'plyr__preview-thumb--is-shown',\n            imageContainer: 'plyr__preview-thumb__image-container',\n            timeContainer: 'plyr__preview-thumb__time-container',\n            // Scrubbing\n            scrubbingContainer: 'plyr__preview-scrubbing',\n            scrubbingContainerShown: 'plyr__preview-scrubbing--is-shown'\n        }\n    },\n    // Embed attributes\n    attributes: {\n        embed: {\n            provider: 'data-plyr-provider',\n            id: 'data-plyr-embed-id',\n            hash: 'data-plyr-embed-hash'\n        }\n    },\n    // Advertisements plugin\n    // Register for an account here: http://vi.ai/publisher-video-monetization/?aid=plyrio\n    ads: {\n        enabled: false,\n        publisherId: '',\n        tagUrl: ''\n    },\n    // Preview Thumbnails plugin\n    previewThumbnails: {\n        enabled: false,\n        src: '',\n        withCredentials: false\n    },\n    // Vimeo plugin\n    vimeo: {\n        byline: false,\n        portrait: false,\n        title: false,\n        speed: true,\n        transparent: false,\n        // Custom settings from Plyr\n        customControls: true,\n        referrerPolicy: null,\n        // https://developer.mozilla.org/en-US/docs/Web/API/HTMLIFrameElement/referrerPolicy\n        // Whether the owner of the video has a Pro or Business account\n        // (which allows us to properly hide controls without CSS hacks, etc)\n        premium: false\n    },\n    // YouTube plugin\n    youtube: {\n        rel: 0,\n        // No related vids\n        showinfo: 0,\n        // Hide info\n        iv_load_policy: 3,\n        // Hide annotations\n        modestbranding: 1,\n        // Hide logos as much as possible (they still show one in the corner when paused)\n        // Custom settings from Plyr\n        customControls: true,\n        noCookie: false // Whether to use an alternative version of YouTube without cookies\n    },\n    // Media Metadata\n    mediaMetadata: {\n        title: '',\n        artist: '',\n        album: '',\n        artwork: []\n    },\n    // Markers\n    markers: {\n        enabled: false,\n        points: []\n    }\n};\n// ==========================================================================\n// Plyr states\n// ==========================================================================\nconst pip = {\n    active: 'picture-in-picture',\n    inactive: 'inline'\n};\n// ==========================================================================\n// Plyr supported types and providers\n// ==========================================================================\nconst providers = {\n    html5: 'html5',\n    youtube: 'youtube',\n    vimeo: 'vimeo'\n};\nconst types = {\n    audio: 'audio',\n    video: 'video'\n};\n/**\n * Get provider by URL\n * @param {string} url\n */ function getProviderByUrl(url) {\n    // YouTube\n    if (/^(?:https?:\\/\\/)?(?:www\\.)?(?:youtube\\.com|youtube-nocookie\\.com|youtu\\.?be)\\/.+$/.test(url)) {\n        return providers.youtube;\n    }\n    // Vimeo\n    if (/^https?:\\/\\/player.vimeo.com\\/video\\/\\d{0,9}(?=\\b|\\/)/.test(url)) {\n        return providers.vimeo;\n    }\n    return null;\n}\n// ==========================================================================\n// Console wrapper\n// ==========================================================================\nfunction noop() {}\nclass Console {\n    constructor(enabled = false){\n        this.enabled = window.console && enabled;\n        if (this.enabled) {\n            this.log('Debugging enabled');\n        }\n    }\n    get log() {\n        // eslint-disable-next-line no-console\n        return this.enabled ? Function.prototype.bind.call(console.log, console) : noop;\n    }\n    get warn() {\n        return this.enabled ? Function.prototype.bind.call(console.warn, console) : noop;\n    }\n    get error() {\n        return this.enabled ? Function.prototype.bind.call(console.error, console) : noop;\n    }\n}\nclass Fullscreen {\n    constructor(player){\n        _defineProperty$1(this, \"onChange\", ()=>{\n            if (!this.supported) return;\n            // Update toggle button\n            const button = this.player.elements.buttons.fullscreen;\n            if (is.element(button)) {\n                button.pressed = this.active;\n            }\n            // Always trigger events on the plyr / media element (not a fullscreen container) and let them bubble up\n            const target = this.target === this.player.media ? this.target : this.player.elements.container;\n            // Trigger an event\n            triggerEvent.call(this.player, target, this.active ? 'enterfullscreen' : 'exitfullscreen', true);\n        });\n        _defineProperty$1(this, \"toggleFallback\", (toggle = false)=>{\n            // Store or restore scroll position\n            if (toggle) {\n                var _window$scrollX, _window$scrollY;\n                this.scrollPosition = {\n                    x: (_window$scrollX = window.scrollX) !== null && _window$scrollX !== void 0 ? _window$scrollX : 0,\n                    y: (_window$scrollY = window.scrollY) !== null && _window$scrollY !== void 0 ? _window$scrollY : 0\n                };\n            } else {\n                window.scrollTo(this.scrollPosition.x, this.scrollPosition.y);\n            }\n            // Toggle scroll\n            document.body.style.overflow = toggle ? 'hidden' : '';\n            // Toggle class hook\n            toggleClass(this.target, this.player.config.classNames.fullscreen.fallback, toggle);\n            // Force full viewport on iPhone X+\n            if (browser.isIos) {\n                let viewport = document.head.querySelector('meta[name=\"viewport\"]');\n                const property = 'viewport-fit=cover';\n                // Inject the viewport meta if required\n                if (!viewport) {\n                    viewport = document.createElement('meta');\n                    viewport.setAttribute('name', 'viewport');\n                }\n                // Check if the property already exists\n                const hasProperty = is.string(viewport.content) && viewport.content.includes(property);\n                if (toggle) {\n                    this.cleanupViewport = !hasProperty;\n                    if (!hasProperty) viewport.content += `,${property}`;\n                } else if (this.cleanupViewport) {\n                    viewport.content = viewport.content.split(',').filter((part)=>part.trim() !== property).join(',');\n                }\n            }\n            // Toggle button and fire events\n            this.onChange();\n        });\n        // Trap focus inside container\n        _defineProperty$1(this, \"trapFocus\", (event)=>{\n            // Bail if iOS/iPadOS, not active, not the tab key\n            if (browser.isIos || browser.isIPadOS || !this.active || event.key !== 'Tab') return;\n            // Get the current focused element\n            const focused = document.activeElement;\n            const focusable = getElements.call(this.player, 'a[href], button:not(:disabled), input:not(:disabled), [tabindex]');\n            const [first] = focusable;\n            const last = focusable[focusable.length - 1];\n            if (focused === last && !event.shiftKey) {\n                // Move focus to first element that can be tabbed if Shift isn't used\n                first.focus();\n                event.preventDefault();\n            } else if (focused === first && event.shiftKey) {\n                // Move focus to last element that can be tabbed if Shift is used\n                last.focus();\n                event.preventDefault();\n            }\n        });\n        // Update UI\n        _defineProperty$1(this, \"update\", ()=>{\n            if (this.supported) {\n                let mode;\n                if (this.forceFallback) mode = 'Fallback (forced)';\n                else if (Fullscreen.nativeSupported) mode = 'Native';\n                else mode = 'Fallback';\n                this.player.debug.log(`${mode} fullscreen enabled`);\n            } else {\n                this.player.debug.log('Fullscreen not supported and fallback disabled');\n            }\n            // Add styling hook to show button\n            toggleClass(this.player.elements.container, this.player.config.classNames.fullscreen.enabled, this.supported);\n        });\n        // Make an element fullscreen\n        _defineProperty$1(this, \"enter\", ()=>{\n            if (!this.supported) return;\n            // iOS native fullscreen doesn't need the request step\n            if (browser.isIos && this.player.config.fullscreen.iosNative) {\n                if (this.player.isVimeo) {\n                    this.player.embed.requestFullscreen();\n                } else {\n                    this.target.webkitEnterFullscreen();\n                }\n            } else if (!Fullscreen.nativeSupported || this.forceFallback) {\n                this.toggleFallback(true);\n            } else if (!this.prefix) {\n                this.target.requestFullscreen({\n                    navigationUI: 'hide'\n                });\n            } else if (!is.empty(this.prefix)) {\n                this.target[`${this.prefix}Request${this.property}`]();\n            }\n        });\n        // Bail from fullscreen\n        _defineProperty$1(this, \"exit\", ()=>{\n            if (!this.supported) return;\n            // iOS native fullscreen\n            if (browser.isIos && this.player.config.fullscreen.iosNative) {\n                if (this.player.isVimeo) {\n                    this.player.embed.exitFullscreen();\n                } else {\n                    this.target.webkitEnterFullscreen();\n                }\n                silencePromise(this.player.play());\n            } else if (!Fullscreen.nativeSupported || this.forceFallback) {\n                this.toggleFallback(false);\n            } else if (!this.prefix) {\n                (document.cancelFullScreen || document.exitFullscreen).call(document);\n            } else if (!is.empty(this.prefix)) {\n                const action = this.prefix === 'moz' ? 'Cancel' : 'Exit';\n                document[`${this.prefix}${action}${this.property}`]();\n            }\n        });\n        // Toggle state\n        _defineProperty$1(this, \"toggle\", ()=>{\n            if (!this.active) this.enter();\n            else this.exit();\n        });\n        // Keep reference to parent\n        this.player = player;\n        // Get prefix\n        this.prefix = Fullscreen.prefix;\n        this.property = Fullscreen.property;\n        // Scroll position\n        this.scrollPosition = {\n            x: 0,\n            y: 0\n        };\n        // Force the use of 'full window/browser' rather than fullscreen\n        this.forceFallback = player.config.fullscreen.fallback === 'force';\n        // Get the fullscreen element\n        // Checks container is an ancestor, defaults to null\n        this.player.elements.fullscreen = player.config.fullscreen.container && closest$1(this.player.elements.container, player.config.fullscreen.container);\n        // Register event listeners\n        // Handle event (incase user presses escape etc)\n        on.call(this.player, document, this.prefix === 'ms' ? 'MSFullscreenChange' : `${this.prefix}fullscreenchange`, ()=>{\n            // TODO: Filter for target??\n            this.onChange();\n        });\n        // Fullscreen toggle on double click\n        on.call(this.player, this.player.elements.container, 'dblclick', (event)=>{\n            // Ignore double click in controls\n            if (is.element(this.player.elements.controls) && this.player.elements.controls.contains(event.target)) {\n                return;\n            }\n            this.player.listeners.proxy(event, this.toggle, 'fullscreen');\n        });\n        // Tap focus when in fullscreen\n        on.call(this, this.player.elements.container, 'keydown', (event)=>this.trapFocus(event));\n        // Update the UI\n        this.update();\n    }\n    // Determine if native supported\n    static get nativeSupported() {\n        return !!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled);\n    }\n    // If we're actually using native\n    get useNative() {\n        return Fullscreen.nativeSupported && !this.forceFallback;\n    }\n    // Get the prefix for handlers\n    static get prefix() {\n        // No prefix\n        if (is.function(document.exitFullscreen)) return '';\n        // Check for fullscreen support by vendor prefix\n        let value = '';\n        const prefixes = [\n            'webkit',\n            'moz',\n            'ms'\n        ];\n        prefixes.some((pre)=>{\n            if (is.function(document[`${pre}ExitFullscreen`]) || is.function(document[`${pre}CancelFullScreen`])) {\n                value = pre;\n                return true;\n            }\n            return false;\n        });\n        return value;\n    }\n    static get property() {\n        return this.prefix === 'moz' ? 'FullScreen' : 'Fullscreen';\n    }\n    // Determine if fullscreen is supported\n    get supported() {\n        return [\n            // Fullscreen is enabled in config\n            this.player.config.fullscreen.enabled,\n            // Must be a video\n            this.player.isVideo,\n            // Either native is supported or fallback enabled\n            Fullscreen.nativeSupported || this.player.config.fullscreen.fallback,\n            // YouTube has no way to trigger fullscreen, so on devices with no native support, playsinline\n            // must be enabled and iosNative fullscreen must be disabled to offer the fullscreen fallback\n            !this.player.isYouTube || Fullscreen.nativeSupported || !browser.isIos || this.player.config.playsinline && !this.player.config.fullscreen.iosNative\n        ].every(Boolean);\n    }\n    // Get active state\n    get active() {\n        if (!this.supported) return false;\n        // Fallback using classname\n        if (!Fullscreen.nativeSupported || this.forceFallback) {\n            return hasClass(this.target, this.player.config.classNames.fullscreen.fallback);\n        }\n        const element = !this.prefix ? this.target.getRootNode().fullscreenElement : this.target.getRootNode()[`${this.prefix}${this.property}Element`];\n        return element && element.shadowRoot ? element === this.target.getRootNode().host : element === this.target;\n    }\n    // Get target element\n    get target() {\n        var _this$player$elements;\n        return browser.isIos && this.player.config.fullscreen.iosNative ? this.player.media : (_this$player$elements = this.player.elements.fullscreen) !== null && _this$player$elements !== void 0 ? _this$player$elements : this.player.elements.container;\n    }\n}\n// ==========================================================================\n// Load image avoiding xhr/fetch CORS issues\n// Server status can't be obtained this way unfortunately, so this uses \"naturalWidth\" to determine if the image has loaded\n// By default it checks if it is at least 1px, but you can add a second argument to change this\n// ==========================================================================\nfunction loadImage(src, minWidth = 1) {\n    return new Promise((resolve, reject)=>{\n        const image = new Image();\n        const handler = ()=>{\n            delete image.onload;\n            delete image.onerror;\n            (image.naturalWidth >= minWidth ? resolve : reject)(image);\n        };\n        Object.assign(image, {\n            onload: handler,\n            onerror: handler,\n            src\n        });\n    });\n}\n// ==========================================================================\n// Plyr UI\n// ==========================================================================\nconst ui = {\n    addStyleHook () {\n        toggleClass(this.elements.container, this.config.selectors.container.replace('.', ''), true);\n        toggleClass(this.elements.container, this.config.classNames.uiSupported, this.supported.ui);\n    },\n    // Toggle native HTML5 media controls\n    toggleNativeControls (toggle = false) {\n        if (toggle && this.isHTML5) {\n            this.media.setAttribute('controls', '');\n        } else {\n            this.media.removeAttribute('controls');\n        }\n    },\n    // Setup the UI\n    build () {\n        // Re-attach media element listeners\n        // TODO: Use event bubbling?\n        this.listeners.media();\n        // Don't setup interface if no support\n        if (!this.supported.ui) {\n            this.debug.warn(`Basic support only for ${this.provider} ${this.type}`);\n            // Restore native controls\n            ui.toggleNativeControls.call(this, true);\n            // Bail\n            return;\n        }\n        // Inject custom controls if not present\n        if (!is.element(this.elements.controls)) {\n            // Inject custom controls\n            controls.inject.call(this);\n            // Re-attach control listeners\n            this.listeners.controls();\n        }\n        // Remove native controls\n        ui.toggleNativeControls.call(this);\n        // Setup captions for HTML5\n        if (this.isHTML5) {\n            captions.setup.call(this);\n        }\n        // Reset volume\n        this.volume = null;\n        // Reset mute state\n        this.muted = null;\n        // Reset loop state\n        this.loop = null;\n        // Reset quality setting\n        this.quality = null;\n        // Reset speed\n        this.speed = null;\n        // Reset volume display\n        controls.updateVolume.call(this);\n        // Reset time display\n        controls.timeUpdate.call(this);\n        // Reset duration display\n        controls.durationUpdate.call(this);\n        // Update the UI\n        ui.checkPlaying.call(this);\n        // Check for picture-in-picture support\n        toggleClass(this.elements.container, this.config.classNames.pip.supported, support.pip && this.isHTML5 && this.isVideo);\n        // Check for airplay support\n        toggleClass(this.elements.container, this.config.classNames.airplay.supported, support.airplay && this.isHTML5);\n        // Add touch class\n        toggleClass(this.elements.container, this.config.classNames.isTouch, this.touch);\n        // Ready for API calls\n        this.ready = true;\n        // Ready event at end of execution stack\n        setTimeout(()=>{\n            triggerEvent.call(this, this.media, 'ready');\n        }, 0);\n        // Set the title\n        ui.setTitle.call(this);\n        // Assure the poster image is set, if the property was added before the element was created\n        if (this.poster) {\n            ui.setPoster.call(this, this.poster, false).catch(()=>{});\n        }\n        // Manually set the duration if user has overridden it.\n        // The event listeners for it doesn't get called if preload is disabled (#701)\n        if (this.config.duration) {\n            controls.durationUpdate.call(this);\n        }\n        // Media metadata\n        if (this.config.mediaMetadata) {\n            controls.setMediaMetadata.call(this);\n        }\n    },\n    // Setup aria attribute for play and iframe title\n    setTitle () {\n        // Find the current text\n        let label = i18n.get('play', this.config);\n        // If there's a media title set, use that for the label\n        if (is.string(this.config.title) && !is.empty(this.config.title)) {\n            label += `, ${this.config.title}`;\n        }\n        // If there's a play button, set label\n        Array.from(this.elements.buttons.play || []).forEach((button)=>{\n            button.setAttribute('aria-label', label);\n        });\n        // Set iframe title\n        // https://github.com/sampotts/plyr/issues/124\n        if (this.isEmbed) {\n            const iframe = getElement.call(this, 'iframe');\n            if (!is.element(iframe)) {\n                return;\n            }\n            // Default to media type\n            const title = !is.empty(this.config.title) ? this.config.title : 'video';\n            const format = i18n.get('frameTitle', this.config);\n            iframe.setAttribute('title', format.replace('{title}', title));\n        }\n    },\n    // Toggle poster\n    togglePoster (enable) {\n        toggleClass(this.elements.container, this.config.classNames.posterEnabled, enable);\n    },\n    // Set the poster image (async)\n    // Used internally for the poster setter, with the passive option forced to false\n    setPoster (poster, passive = true) {\n        // Don't override if call is passive\n        if (passive && this.poster) {\n            return Promise.reject(new Error('Poster already set'));\n        }\n        // Set property synchronously to respect the call order\n        this.media.setAttribute('data-poster', poster);\n        // Show the poster\n        this.elements.poster.removeAttribute('hidden');\n        // Wait until ui is ready\n        return ready.call(this)// Load image\n        .then(()=>loadImage(poster)).catch((error)=>{\n            // Hide poster on error unless it's been set by another call\n            if (poster === this.poster) {\n                ui.togglePoster.call(this, false);\n            }\n            // Rethrow\n            throw error;\n        }).then(()=>{\n            // Prevent race conditions\n            if (poster !== this.poster) {\n                throw new Error('setPoster cancelled by later call to setPoster');\n            }\n        }).then(()=>{\n            Object.assign(this.elements.poster.style, {\n                backgroundImage: `url('${poster}')`,\n                // Reset backgroundSize as well (since it can be set to \"cover\" for padded thumbnails for youtube)\n                backgroundSize: ''\n            });\n            ui.togglePoster.call(this, true);\n            return poster;\n        });\n    },\n    // Check playing state\n    checkPlaying (event) {\n        // Class hooks\n        toggleClass(this.elements.container, this.config.classNames.playing, this.playing);\n        toggleClass(this.elements.container, this.config.classNames.paused, this.paused);\n        toggleClass(this.elements.container, this.config.classNames.stopped, this.stopped);\n        // Set state\n        Array.from(this.elements.buttons.play || []).forEach((target)=>{\n            Object.assign(target, {\n                pressed: this.playing\n            });\n            target.setAttribute('aria-label', i18n.get(this.playing ? 'pause' : 'play', this.config));\n        });\n        // Only update controls on non timeupdate events\n        if (is.event(event) && event.type === 'timeupdate') {\n            return;\n        }\n        // Toggle controls\n        ui.toggleControls.call(this);\n    },\n    // Check if media is loading\n    checkLoading (event) {\n        this.loading = [\n            'stalled',\n            'waiting'\n        ].includes(event.type);\n        // Clear timer\n        clearTimeout(this.timers.loading);\n        // Timer to prevent flicker when seeking\n        this.timers.loading = setTimeout(()=>{\n            // Update progress bar loading class state\n            toggleClass(this.elements.container, this.config.classNames.loading, this.loading);\n            // Update controls visibility\n            ui.toggleControls.call(this);\n        }, this.loading ? 250 : 0);\n    },\n    // Toggle controls based on state and `force` argument\n    toggleControls (force) {\n        const { controls: controlsElement } = this.elements;\n        if (controlsElement && this.config.hideControls) {\n            // Don't hide controls if a touch-device user recently seeked. (Must be limited to touch devices, or it occasionally prevents desktop controls from hiding.)\n            const recentTouchSeek = this.touch && this.lastSeekTime + 2000 > Date.now();\n            // Show controls if force, loading, paused, button interaction, or recent seek, otherwise hide\n            this.toggleControls(Boolean(force || this.loading || this.paused || controlsElement.pressed || controlsElement.hover || recentTouchSeek));\n        }\n    },\n    // Migrate any custom properties from the media to the parent\n    migrateStyles () {\n        // Loop through values (as they are the keys when the object is spread )\n        Object.values({\n            ...this.media.style\n        })// We're only fussed about Plyr specific properties\n        .filter((key)=>!is.empty(key) && is.string(key) && key.startsWith('--plyr')).forEach((key)=>{\n            // Set on the container\n            this.elements.container.style.setProperty(key, this.media.style.getPropertyValue(key));\n            // Clean up from media element\n            this.media.style.removeProperty(key);\n        });\n        // Remove attribute if empty\n        if (is.empty(this.media.style)) {\n            this.media.removeAttribute('style');\n        }\n    }\n};\nclass Listeners {\n    constructor(_player){\n        // Device is touch enabled\n        _defineProperty$1(this, \"firstTouch\", ()=>{\n            const { player } = this;\n            const { elements } = player;\n            player.touch = true;\n            // Add touch class\n            toggleClass(elements.container, player.config.classNames.isTouch, true);\n        });\n        // Global window & document listeners\n        _defineProperty$1(this, \"global\", (toggle = true)=>{\n            const { player } = this;\n            // Keyboard shortcuts\n            if (player.config.keyboard.global) {\n                toggleListener.call(player, window, 'keydown keyup', this.handleKey, toggle, false);\n            }\n            // Click anywhere closes menu\n            toggleListener.call(player, document.body, 'click', this.toggleMenu, toggle);\n            // Detect touch by events\n            once.call(player, document.body, 'touchstart', this.firstTouch);\n        });\n        // Container listeners\n        _defineProperty$1(this, \"container\", ()=>{\n            const { player } = this;\n            const { config, elements, timers } = player;\n            // Keyboard shortcuts\n            if (!config.keyboard.global && config.keyboard.focused) {\n                on.call(player, elements.container, 'keydown keyup', this.handleKey, false);\n            }\n            // Toggle controls on mouse events and entering fullscreen\n            on.call(player, elements.container, 'mousemove mouseleave touchstart touchmove enterfullscreen exitfullscreen', (event)=>{\n                const { controls: controlsElement } = elements;\n                // Remove button states for fullscreen\n                if (controlsElement && event.type === 'enterfullscreen') {\n                    controlsElement.pressed = false;\n                    controlsElement.hover = false;\n                }\n                // Show, then hide after a timeout unless another control event occurs\n                const show = [\n                    'touchstart',\n                    'touchmove',\n                    'mousemove'\n                ].includes(event.type);\n                let delay = 0;\n                if (show) {\n                    ui.toggleControls.call(player, true);\n                    // Use longer timeout for touch devices\n                    delay = player.touch ? 3000 : 2000;\n                }\n                // Clear timer\n                clearTimeout(timers.controls);\n                // Set new timer to prevent flicker when seeking\n                timers.controls = setTimeout(()=>ui.toggleControls.call(player, false), delay);\n            });\n            // Set a gutter for Vimeo\n            const setGutter = ()=>{\n                if (!player.isVimeo || player.config.vimeo.premium) {\n                    return;\n                }\n                const target = elements.wrapper;\n                const { active } = player.fullscreen;\n                const [videoWidth, videoHeight] = getAspectRatio.call(player);\n                const useNativeAspectRatio = supportsCSS(`aspect-ratio: ${videoWidth} / ${videoHeight}`);\n                // If not active, remove styles\n                if (!active) {\n                    if (useNativeAspectRatio) {\n                        target.style.width = null;\n                        target.style.height = null;\n                    } else {\n                        target.style.maxWidth = null;\n                        target.style.margin = null;\n                    }\n                    return;\n                }\n                // Determine which dimension will overflow and constrain view\n                const [viewportWidth, viewportHeight] = getViewportSize();\n                const overflow = viewportWidth / viewportHeight > videoWidth / videoHeight;\n                if (useNativeAspectRatio) {\n                    target.style.width = overflow ? 'auto' : '100%';\n                    target.style.height = overflow ? '100%' : 'auto';\n                } else {\n                    target.style.maxWidth = overflow ? `${viewportHeight / videoHeight * videoWidth}px` : null;\n                    target.style.margin = overflow ? '0 auto' : null;\n                }\n            };\n            // Handle resizing\n            const resized = ()=>{\n                clearTimeout(timers.resized);\n                timers.resized = setTimeout(setGutter, 50);\n            };\n            on.call(player, elements.container, 'enterfullscreen exitfullscreen', (event)=>{\n                const { target } = player.fullscreen;\n                // Ignore events not from target\n                if (target !== elements.container) {\n                    return;\n                }\n                // If it's not an embed and no ratio specified\n                if (!player.isEmbed && is.empty(player.config.ratio)) {\n                    return;\n                }\n                // Set Vimeo gutter\n                setGutter();\n                // Watch for resizes\n                const method = event.type === 'enterfullscreen' ? on : off;\n                method.call(player, window, 'resize', resized);\n            });\n        });\n        // Listen for media events\n        _defineProperty$1(this, \"media\", ()=>{\n            const { player } = this;\n            const { elements } = player;\n            // Time change on media\n            on.call(player, player.media, 'timeupdate seeking seeked', (event)=>controls.timeUpdate.call(player, event));\n            // Display duration\n            on.call(player, player.media, 'durationchange loadeddata loadedmetadata', (event)=>controls.durationUpdate.call(player, event));\n            // Handle the media finishing\n            on.call(player, player.media, 'ended', ()=>{\n                // Show poster on end\n                if (player.isHTML5 && player.isVideo && player.config.resetOnEnd) {\n                    // Restart\n                    player.restart();\n                    // Call pause otherwise IE11 will start playing the video again\n                    player.pause();\n                }\n            });\n            // Check for buffer progress\n            on.call(player, player.media, 'progress playing seeking seeked', (event)=>controls.updateProgress.call(player, event));\n            // Handle volume changes\n            on.call(player, player.media, 'volumechange', (event)=>controls.updateVolume.call(player, event));\n            // Handle play/pause\n            on.call(player, player.media, 'playing play pause ended emptied timeupdate', (event)=>ui.checkPlaying.call(player, event));\n            // Loading state\n            on.call(player, player.media, 'waiting canplay seeked playing', (event)=>ui.checkLoading.call(player, event));\n            // Click video\n            if (player.supported.ui && player.config.clickToPlay && !player.isAudio) {\n                // Re-fetch the wrapper\n                const wrapper = getElement.call(player, `.${player.config.classNames.video}`);\n                // Bail if there's no wrapper (this should never happen)\n                if (!is.element(wrapper)) {\n                    return;\n                }\n                // On click play, pause or restart\n                on.call(player, elements.container, 'click', (event)=>{\n                    const targets = [\n                        elements.container,\n                        wrapper\n                    ];\n                    // Ignore if click if not container or in video wrapper\n                    if (!targets.includes(event.target) && !wrapper.contains(event.target)) {\n                        return;\n                    }\n                    // Touch devices will just show controls (if hidden)\n                    if (player.touch && player.config.hideControls) {\n                        return;\n                    }\n                    if (player.ended) {\n                        this.proxy(event, player.restart, 'restart');\n                        this.proxy(event, ()=>{\n                            silencePromise(player.play());\n                        }, 'play');\n                    } else {\n                        this.proxy(event, ()=>{\n                            silencePromise(player.togglePlay());\n                        }, 'play');\n                    }\n                });\n            }\n            // Disable right click\n            if (player.supported.ui && player.config.disableContextMenu) {\n                on.call(player, elements.wrapper, 'contextmenu', (event)=>{\n                    event.preventDefault();\n                }, false);\n            }\n            // Volume change\n            on.call(player, player.media, 'volumechange', ()=>{\n                // Save to storage\n                player.storage.set({\n                    volume: player.volume,\n                    muted: player.muted\n                });\n            });\n            // Speed change\n            on.call(player, player.media, 'ratechange', ()=>{\n                // Update UI\n                controls.updateSetting.call(player, 'speed');\n                // Save to storage\n                player.storage.set({\n                    speed: player.speed\n                });\n            });\n            // Quality change\n            on.call(player, player.media, 'qualitychange', (event)=>{\n                // Update UI\n                controls.updateSetting.call(player, 'quality', null, event.detail.quality);\n            });\n            // Update download link when ready and if quality changes\n            on.call(player, player.media, 'ready qualitychange', ()=>{\n                controls.setDownloadUrl.call(player);\n            });\n            // Proxy events to container\n            // Bubble up key events for Edge\n            const proxyEvents = player.config.events.concat([\n                'keyup',\n                'keydown'\n            ]).join(' ');\n            on.call(player, player.media, proxyEvents, (event)=>{\n                let { detail = {} } = event;\n                // Get error details from media\n                if (event.type === 'error') {\n                    detail = player.media.error;\n                }\n                triggerEvent.call(player, elements.container, event.type, true, detail);\n            });\n        });\n        // Run default and custom handlers\n        _defineProperty$1(this, \"proxy\", (event, defaultHandler, customHandlerKey)=>{\n            const { player } = this;\n            const customHandler = player.config.listeners[customHandlerKey];\n            const hasCustomHandler = is.function(customHandler);\n            let returned = true;\n            // Execute custom handler\n            if (hasCustomHandler) {\n                returned = customHandler.call(player, event);\n            }\n            // Only call default handler if not prevented in custom handler\n            if (returned !== false && is.function(defaultHandler)) {\n                defaultHandler.call(player, event);\n            }\n        });\n        // Trigger custom and default handlers\n        _defineProperty$1(this, \"bind\", (element, type, defaultHandler, customHandlerKey, passive = true)=>{\n            const { player } = this;\n            const customHandler = player.config.listeners[customHandlerKey];\n            const hasCustomHandler = is.function(customHandler);\n            on.call(player, element, type, (event)=>this.proxy(event, defaultHandler, customHandlerKey), passive && !hasCustomHandler);\n        });\n        // Listen for control events\n        _defineProperty$1(this, \"controls\", ()=>{\n            const { player } = this;\n            const { elements } = player;\n            // IE doesn't support input event, so we fallback to change\n            const inputEvent = browser.isIE ? 'change' : 'input';\n            // Play/pause toggle\n            if (elements.buttons.play) {\n                Array.from(elements.buttons.play).forEach((button)=>{\n                    this.bind(button, 'click', ()=>{\n                        silencePromise(player.togglePlay());\n                    }, 'play');\n                });\n            }\n            // Pause\n            this.bind(elements.buttons.restart, 'click', player.restart, 'restart');\n            // Rewind\n            this.bind(elements.buttons.rewind, 'click', ()=>{\n                // Record seek time so we can prevent hiding controls for a few seconds after rewind\n                player.lastSeekTime = Date.now();\n                player.rewind();\n            }, 'rewind');\n            // Rewind\n            this.bind(elements.buttons.fastForward, 'click', ()=>{\n                // Record seek time so we can prevent hiding controls for a few seconds after fast forward\n                player.lastSeekTime = Date.now();\n                player.forward();\n            }, 'fastForward');\n            // Mute toggle\n            this.bind(elements.buttons.mute, 'click', ()=>{\n                player.muted = !player.muted;\n            }, 'mute');\n            // Captions toggle\n            this.bind(elements.buttons.captions, 'click', ()=>player.toggleCaptions());\n            // Download\n            this.bind(elements.buttons.download, 'click', ()=>{\n                triggerEvent.call(player, player.media, 'download');\n            }, 'download');\n            // Fullscreen toggle\n            this.bind(elements.buttons.fullscreen, 'click', ()=>{\n                player.fullscreen.toggle();\n            }, 'fullscreen');\n            // Picture-in-Picture\n            this.bind(elements.buttons.pip, 'click', ()=>{\n                player.pip = 'toggle';\n            }, 'pip');\n            // Airplay\n            this.bind(elements.buttons.airplay, 'click', player.airplay, 'airplay');\n            // Settings menu - click toggle\n            this.bind(elements.buttons.settings, 'click', (event)=>{\n                // Prevent the document click listener closing the menu\n                event.stopPropagation();\n                event.preventDefault();\n                controls.toggleMenu.call(player, event);\n            }, null, false); // Can't be passive as we're preventing default\n            // Settings menu - keyboard toggle\n            // We have to bind to keyup otherwise Firefox triggers a click when a keydown event handler shifts focus\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143\n            this.bind(elements.buttons.settings, 'keyup', (event)=>{\n                if (![\n                    ' ',\n                    'Enter'\n                ].includes(event.key)) {\n                    return;\n                }\n                // Because return triggers a click anyway, all we need to do is set focus\n                if (event.key === 'Enter') {\n                    controls.focusFirstMenuItem.call(player, null, true);\n                    return;\n                }\n                // Prevent scroll\n                event.preventDefault();\n                // Prevent playing video (Firefox)\n                event.stopPropagation();\n                // Toggle menu\n                controls.toggleMenu.call(player, event);\n            }, null, false // Can't be passive as we're preventing default\n            );\n            // Escape closes menu\n            this.bind(elements.settings.menu, 'keydown', (event)=>{\n                if (event.key === 'Escape') {\n                    controls.toggleMenu.call(player, event);\n                }\n            });\n            // Set range input alternative \"value\", which matches the tooltip time (#954)\n            this.bind(elements.inputs.seek, 'mousedown mousemove', (event)=>{\n                const rect = elements.progress.getBoundingClientRect();\n                const scrollLeft = event.pageX - event.clientX;\n                const percent = 100 / rect.width * (event.pageX - rect.left - scrollLeft);\n                event.currentTarget.setAttribute('seek-value', percent);\n            });\n            // Pause while seeking\n            this.bind(elements.inputs.seek, 'mousedown mouseup keydown keyup touchstart touchend', (event)=>{\n                const seek = event.currentTarget;\n                const attribute = 'play-on-seeked';\n                if (is.keyboardEvent(event) && ![\n                    'ArrowLeft',\n                    'ArrowRight'\n                ].includes(event.key)) {\n                    return;\n                }\n                // Record seek time so we can prevent hiding controls for a few seconds after seek\n                player.lastSeekTime = Date.now();\n                // Was playing before?\n                const play = seek.hasAttribute(attribute);\n                // Done seeking\n                const done = [\n                    'mouseup',\n                    'touchend',\n                    'keyup'\n                ].includes(event.type);\n                // If we're done seeking and it was playing, resume playback\n                if (play && done) {\n                    seek.removeAttribute(attribute);\n                    silencePromise(player.play());\n                } else if (!done && player.playing) {\n                    seek.setAttribute(attribute, '');\n                    player.pause();\n                }\n            });\n            // Fix range inputs on iOS\n            // Super weird iOS bug where after you interact with an <input type=\"range\">,\n            // it takes over further interactions on the page. This is a hack\n            if (browser.isIos) {\n                const inputs = getElements.call(player, 'input[type=\"range\"]');\n                Array.from(inputs).forEach((input)=>this.bind(input, inputEvent, (event)=>repaint(event.target)));\n            }\n            // Seek\n            this.bind(elements.inputs.seek, inputEvent, (event)=>{\n                const seek = event.currentTarget;\n                // If it exists, use seek-value instead of \"value\" for consistency with tooltip time (#954)\n                let seekTo = seek.getAttribute('seek-value');\n                if (is.empty(seekTo)) {\n                    seekTo = seek.value;\n                }\n                seek.removeAttribute('seek-value');\n                player.currentTime = seekTo / seek.max * player.duration;\n            }, 'seek');\n            // Seek tooltip\n            this.bind(elements.progress, 'mouseenter mouseleave mousemove', (event)=>controls.updateSeekTooltip.call(player, event));\n            // Preview thumbnails plugin\n            // TODO: Really need to work on some sort of plug-in wide event bus or pub-sub for this\n            this.bind(elements.progress, 'mousemove touchmove', (event)=>{\n                const { previewThumbnails } = player;\n                if (previewThumbnails && previewThumbnails.loaded) {\n                    previewThumbnails.startMove(event);\n                }\n            });\n            // Hide thumbnail preview - on mouse click, mouse leave, and video play/seek. All four are required, e.g., for buffering\n            this.bind(elements.progress, 'mouseleave touchend click', ()=>{\n                const { previewThumbnails } = player;\n                if (previewThumbnails && previewThumbnails.loaded) {\n                    previewThumbnails.endMove(false, true);\n                }\n            });\n            // Show scrubbing preview\n            this.bind(elements.progress, 'mousedown touchstart', (event)=>{\n                const { previewThumbnails } = player;\n                if (previewThumbnails && previewThumbnails.loaded) {\n                    previewThumbnails.startScrubbing(event);\n                }\n            });\n            this.bind(elements.progress, 'mouseup touchend', (event)=>{\n                const { previewThumbnails } = player;\n                if (previewThumbnails && previewThumbnails.loaded) {\n                    previewThumbnails.endScrubbing(event);\n                }\n            });\n            // Polyfill for lower fill in <input type=\"range\"> for webkit\n            if (browser.isWebKit) {\n                Array.from(getElements.call(player, 'input[type=\"range\"]')).forEach((element)=>{\n                    this.bind(element, 'input', (event)=>controls.updateRangeFill.call(player, event.target));\n                });\n            }\n            // Current time invert\n            // Only if one time element is used for both currentTime and duration\n            if (player.config.toggleInvert && !is.element(elements.display.duration)) {\n                this.bind(elements.display.currentTime, 'click', ()=>{\n                    // Do nothing if we're at the start\n                    if (player.currentTime === 0) {\n                        return;\n                    }\n                    player.config.invertTime = !player.config.invertTime;\n                    controls.timeUpdate.call(player);\n                });\n            }\n            // Volume\n            this.bind(elements.inputs.volume, inputEvent, (event)=>{\n                player.volume = event.target.value;\n            }, 'volume');\n            // Update controls.hover state (used for ui.toggleControls to avoid hiding when interacting)\n            this.bind(elements.controls, 'mouseenter mouseleave', (event)=>{\n                elements.controls.hover = !player.touch && event.type === 'mouseenter';\n            });\n            // Also update controls.hover state for any non-player children of fullscreen element (as above)\n            if (elements.fullscreen) {\n                Array.from(elements.fullscreen.children).filter((c)=>!c.contains(elements.container)).forEach((child)=>{\n                    this.bind(child, 'mouseenter mouseleave', (event)=>{\n                        if (elements.controls) {\n                            elements.controls.hover = !player.touch && event.type === 'mouseenter';\n                        }\n                    });\n                });\n            }\n            // Update controls.pressed state (used for ui.toggleControls to avoid hiding when interacting)\n            this.bind(elements.controls, 'mousedown mouseup touchstart touchend touchcancel', (event)=>{\n                elements.controls.pressed = [\n                    'mousedown',\n                    'touchstart'\n                ].includes(event.type);\n            });\n            // Show controls when they receive focus (e.g., when using keyboard tab key)\n            this.bind(elements.controls, 'focusin', ()=>{\n                const { config, timers } = player;\n                // Skip transition to prevent focus from scrolling the parent element\n                toggleClass(elements.controls, config.classNames.noTransition, true);\n                // Toggle\n                ui.toggleControls.call(player, true);\n                // Restore transition\n                setTimeout(()=>{\n                    toggleClass(elements.controls, config.classNames.noTransition, false);\n                }, 0);\n                // Delay a little more for mouse users\n                const delay = this.touch ? 3000 : 4000;\n                // Clear timer\n                clearTimeout(timers.controls);\n                // Hide again after delay\n                timers.controls = setTimeout(()=>ui.toggleControls.call(player, false), delay);\n            });\n            // Mouse wheel for volume\n            this.bind(elements.inputs.volume, 'wheel', (event)=>{\n                // Detect \"natural\" scroll - supported on OS X Safari only\n                // Other browsers on OS X will be inverted until support improves\n                const inverted = event.webkitDirectionInvertedFromDevice;\n                // Get delta from event. Invert if `inverted` is true\n                const [x, y] = [\n                    event.deltaX,\n                    -event.deltaY\n                ].map((value)=>inverted ? -value : value);\n                // Using the biggest delta, normalize to 1 or -1 (or 0 if no delta)\n                const direction = Math.sign(Math.abs(x) > Math.abs(y) ? x : y);\n                // Change the volume by 2%\n                player.increaseVolume(direction / 50);\n                // Don't break page scrolling at max and min\n                const { volume } = player.media;\n                if (direction === 1 && volume < 1 || direction === -1 && volume > 0) {\n                    event.preventDefault();\n                }\n            }, 'volume', false);\n        });\n        this.player = _player;\n        this.lastKey = null;\n        this.focusTimer = null;\n        this.lastKeyDown = null;\n        this.handleKey = this.handleKey.bind(this);\n        this.toggleMenu = this.toggleMenu.bind(this);\n        this.firstTouch = this.firstTouch.bind(this);\n    }\n    // Handle key presses\n    handleKey(event) {\n        const { player } = this;\n        const { elements } = player;\n        const { key, type, altKey, ctrlKey, metaKey, shiftKey } = event;\n        const pressed = type === 'keydown';\n        const repeat = pressed && key === this.lastKey;\n        // Bail if a modifier key is set\n        if (altKey || ctrlKey || metaKey || shiftKey) {\n            return;\n        }\n        // If the event is bubbled from the media element\n        // Firefox doesn't get the key for whatever reason\n        if (!key) {\n            return;\n        }\n        // Seek by increment\n        const seekByIncrement = (increment)=>{\n            // Divide the max duration into 10th's and times by the number value\n            player.currentTime = player.duration / 10 * increment;\n        };\n        // Handle the key on keydown\n        // Reset on keyup\n        if (pressed) {\n            // Check focused element\n            // and if the focused element is not editable (e.g. text input)\n            // and any that accept key input http://webaim.org/techniques/keyboard/\n            const focused = document.activeElement;\n            if (is.element(focused)) {\n                const { editable } = player.config.selectors;\n                const { seek } = elements.inputs;\n                if (focused !== seek && matches(focused, editable)) {\n                    return;\n                }\n                if (event.key === ' ' && matches(focused, 'button, [role^=\"menuitem\"]')) {\n                    return;\n                }\n            }\n            // Which keys should we prevent default\n            const preventDefault = [\n                ' ',\n                'ArrowLeft',\n                'ArrowUp',\n                'ArrowRight',\n                'ArrowDown',\n                '0',\n                '1',\n                '2',\n                '3',\n                '4',\n                '5',\n                '6',\n                '7',\n                '8',\n                '9',\n                'c',\n                'f',\n                'k',\n                'l',\n                'm'\n            ];\n            // If the key is found prevent default (e.g. prevent scrolling for arrows)\n            if (preventDefault.includes(key)) {\n                event.preventDefault();\n                event.stopPropagation();\n            }\n            switch(key){\n                case '0':\n                case '1':\n                case '2':\n                case '3':\n                case '4':\n                case '5':\n                case '6':\n                case '7':\n                case '8':\n                case '9':\n                    if (!repeat) {\n                        seekByIncrement(Number.parseInt(key, 10));\n                    }\n                    break;\n                case ' ':\n                case 'k':\n                    if (!repeat) {\n                        silencePromise(player.togglePlay());\n                    }\n                    break;\n                case 'ArrowUp':\n                    player.increaseVolume(0.1);\n                    break;\n                case 'ArrowDown':\n                    player.decreaseVolume(0.1);\n                    break;\n                case 'm':\n                    if (!repeat) {\n                        player.muted = !player.muted;\n                    }\n                    break;\n                case 'ArrowRight':\n                    player.forward();\n                    break;\n                case 'ArrowLeft':\n                    player.rewind();\n                    break;\n                case 'f':\n                    player.fullscreen.toggle();\n                    break;\n                case 'c':\n                    if (!repeat) {\n                        player.toggleCaptions();\n                    }\n                    break;\n                case 'l':\n                    player.loop = !player.loop;\n                    break;\n            }\n            // Escape is handle natively when in full screen\n            // So we only need to worry about non native\n            if (key === 'Escape' && !player.fullscreen.usingNative && player.fullscreen.active) {\n                player.fullscreen.toggle();\n            }\n            // Store last key for next cycle\n            this.lastKey = key;\n        } else {\n            this.lastKey = null;\n        }\n    }\n    // Toggle menu\n    toggleMenu(event) {\n        controls.toggleMenu.call(this.player, event);\n    }\n}\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\nvar loadjs_umd$1 = {\n    exports: {}\n};\nvar loadjs_umd = loadjs_umd$1.exports;\nvar hasRequiredLoadjs_umd;\nfunction requireLoadjs_umd() {\n    if (hasRequiredLoadjs_umd) return loadjs_umd$1.exports;\n    hasRequiredLoadjs_umd = 1;\n    (function(module, exports) {\n        (function(root, factory) {\n            {\n                module.exports = factory();\n            }\n        })(loadjs_umd, function() {\n            /**\n       * Global dependencies.\n       * @global {Object} document - DOM\n       */ var devnull = function() {}, bundleIdCache = {}, bundleResultCache = {}, bundleCallbackQueue = {};\n            /**\n       * Subscribe to bundle load event.\n       * @param {string[]} bundleIds - Bundle ids\n       * @param {Function} callbackFn - The callback function\n       */ function subscribe(bundleIds, callbackFn) {\n                // listify\n                bundleIds = bundleIds.push ? bundleIds : [\n                    bundleIds\n                ];\n                var depsNotFound = [], i = bundleIds.length, numWaiting = i, fn, bundleId, r, q;\n                // define callback function\n                fn = function(bundleId, pathsNotFound) {\n                    if (pathsNotFound.length) depsNotFound.push(bundleId);\n                    numWaiting--;\n                    if (!numWaiting) callbackFn(depsNotFound);\n                };\n                // register callback\n                while(i--){\n                    bundleId = bundleIds[i];\n                    // execute callback if in result cache\n                    r = bundleResultCache[bundleId];\n                    if (r) {\n                        fn(bundleId, r);\n                        continue;\n                    }\n                    // add to callback queue\n                    q = bundleCallbackQueue[bundleId] = bundleCallbackQueue[bundleId] || [];\n                    q.push(fn);\n                }\n            }\n            /**\n       * Publish bundle load event.\n       * @param {string} bundleId - Bundle id\n       * @param {string[]} pathsNotFound - List of files not found\n       */ function publish(bundleId, pathsNotFound) {\n                // exit if id isn't defined\n                if (!bundleId) return;\n                var q = bundleCallbackQueue[bundleId];\n                // cache result\n                bundleResultCache[bundleId] = pathsNotFound;\n                // exit if queue is empty\n                if (!q) return;\n                // empty callback queue\n                while(q.length){\n                    q[0](bundleId, pathsNotFound);\n                    q.splice(0, 1);\n                }\n            }\n            /**\n       * Execute callbacks.\n       * @param {Object or Function} args - The callback args\n       * @param {string[]} depsNotFound - List of dependencies not found\n       */ function executeCallbacks(args, depsNotFound) {\n                // accept function as argument\n                if (args.call) args = {\n                    success: args\n                };\n                // success and error callbacks\n                if (depsNotFound.length) (args.error || devnull)(depsNotFound);\n                else (args.success || devnull)(args);\n            }\n            /**\n       * Load individual file.\n       * @param {string} path - The file path\n       * @param {Function} callbackFn - The callback function\n       */ function loadFile(path, callbackFn, args, numTries) {\n                var doc = document, async = args.async, maxTries = (args.numRetries || 0) + 1, beforeCallbackFn = args.before || devnull, pathname = path.replace(/[\\?|#].*$/, ''), pathStripped = path.replace(/^(css|img|module|nomodule)!/, ''), isLegacyIECss, hasModuleSupport, e;\n                numTries = numTries || 0;\n                if (/(^css!|\\.css$)/.test(pathname)) {\n                    // css\n                    e = doc.createElement('link');\n                    e.rel = 'stylesheet';\n                    e.href = pathStripped;\n                    // tag IE9+\n                    isLegacyIECss = 'hideFocus' in e;\n                    // use preload in IE Edge (to detect load errors)\n                    if (isLegacyIECss && e.relList) {\n                        isLegacyIECss = 0;\n                        e.rel = 'preload';\n                        e.as = 'style';\n                    }\n                } else if (/(^img!|\\.(png|gif|jpg|svg|webp)$)/.test(pathname)) {\n                    // image\n                    e = doc.createElement('img');\n                    e.src = pathStripped;\n                } else {\n                    // javascript\n                    e = doc.createElement('script');\n                    e.src = pathStripped;\n                    e.async = async === undefined ? true : async;\n                    // handle es modules\n                    // modern browsers:\n                    //   module: add to dom with type=\"module\"\n                    //   nomodule: call success() callback without adding to dom\n                    // legacy browsers:\n                    //   module: call success() callback without adding to dom\n                    //   nomodule: add to dom with default type (\"text/javascript\")\n                    hasModuleSupport = 'noModule' in e;\n                    if (/^module!/.test(pathname)) {\n                        if (!hasModuleSupport) return callbackFn(path, 'l');\n                        e.type = \"module\";\n                    } else if (/^nomodule!/.test(pathname) && hasModuleSupport) return callbackFn(path, 'l');\n                }\n                e.onload = e.onerror = e.onbeforeload = function(ev) {\n                    var result = ev.type[0];\n                    // treat empty stylesheets as failures to get around lack of onerror\n                    // support in IE9-11\n                    if (isLegacyIECss) {\n                        try {\n                            if (!e.sheet.cssText.length) result = 'e';\n                        } catch (x) {\n                            // sheets objects created from load errors don't allow access to\n                            // `cssText` (unless error is Code:18 SecurityError)\n                            if (x.code != 18) result = 'e';\n                        }\n                    }\n                    // handle retries in case of load failure\n                    if (result == 'e') {\n                        // increment counter\n                        numTries += 1;\n                        // exit function and try again\n                        if (numTries < maxTries) {\n                            return loadFile(path, callbackFn, args, numTries);\n                        }\n                    } else if (e.rel == 'preload' && e.as == 'style') {\n                        // activate preloaded stylesheets\n                        return e.rel = 'stylesheet'; // jshint ignore:line\n                    }\n                    // execute callback\n                    callbackFn(path, result, ev.defaultPrevented);\n                };\n                // add to document (unless callback returns `false`)\n                if (beforeCallbackFn(path, e) !== false) doc.head.appendChild(e);\n            }\n            /**\n       * Load multiple files.\n       * @param {string[]} paths - The file paths\n       * @param {Function} callbackFn - The callback function\n       */ function loadFiles(paths, callbackFn, args) {\n                // listify paths\n                paths = paths.push ? paths : [\n                    paths\n                ];\n                var numWaiting = paths.length, x = numWaiting, pathsNotFound = [], fn, i;\n                // define callback function\n                fn = function(path, result, defaultPrevented) {\n                    // handle error\n                    if (result == 'e') pathsNotFound.push(path);\n                    // handle beforeload event. If defaultPrevented then that means the load\n                    // will be blocked (ex. Ghostery/ABP on Safari)\n                    if (result == 'b') {\n                        if (defaultPrevented) pathsNotFound.push(path);\n                        else return;\n                    }\n                    numWaiting--;\n                    if (!numWaiting) callbackFn(pathsNotFound);\n                };\n                // load scripts\n                for(i = 0; i < x; i++)loadFile(paths[i], fn, args);\n            }\n            /**\n       * Initiate script load and register bundle.\n       * @param {(string|string[])} paths - The file paths\n       * @param {(string|Function|Object)} [arg1] - The (1) bundleId or (2) success\n       *   callback or (3) object literal with success/error arguments, numRetries,\n       *   etc.\n       * @param {(Function|Object)} [arg2] - The (1) success callback or (2) object\n       *   literal with success/error arguments, numRetries, etc.\n       */ function loadjs(paths, arg1, arg2) {\n                var bundleId, args;\n                // bundleId (if string)\n                if (arg1 && arg1.trim) bundleId = arg1;\n                // args (default is {})\n                args = (bundleId ? arg2 : arg1) || {};\n                // throw error if bundle is already defined\n                if (bundleId) {\n                    if (bundleId in bundleIdCache) {\n                        throw \"LoadJS\";\n                    } else {\n                        bundleIdCache[bundleId] = true;\n                    }\n                }\n                function loadFn(resolve, reject) {\n                    loadFiles(paths, function(pathsNotFound) {\n                        // execute callbacks\n                        executeCallbacks(args, pathsNotFound);\n                        // resolve Promise\n                        if (resolve) {\n                            executeCallbacks({\n                                success: resolve,\n                                error: reject\n                            }, pathsNotFound);\n                        }\n                        // publish bundle load event\n                        publish(bundleId, pathsNotFound);\n                    }, args);\n                }\n                if (args.returnPromise) return new Promise(loadFn);\n                else loadFn();\n            }\n            /**\n       * Execute callbacks when dependencies have been satisfied.\n       * @param {(string|string[])} deps - List of bundle ids\n       * @param {Object} args - success/error arguments\n       */ loadjs.ready = function ready(deps, args) {\n                // subscribe to bundle load event\n                subscribe(deps, function(depsNotFound) {\n                    // execute callbacks\n                    executeCallbacks(args, depsNotFound);\n                });\n                return loadjs;\n            };\n            /**\n       * Manually satisfy bundle dependencies.\n       * @param {string} bundleId - The bundle id\n       */ loadjs.done = function done(bundleId) {\n                publish(bundleId, []);\n            };\n            /**\n       * Reset loadjs dependencies statuses\n       */ loadjs.reset = function reset() {\n                bundleIdCache = {};\n                bundleResultCache = {};\n                bundleCallbackQueue = {};\n            };\n            /**\n       * Determine if bundle has already been defined\n       * @param String} bundleId - The bundle id\n       */ loadjs.isDefined = function isDefined(bundleId) {\n                return bundleId in bundleIdCache;\n            };\n            // export\n            return loadjs;\n        });\n    })(loadjs_umd$1);\n    return loadjs_umd$1.exports;\n}\nvar loadjs_umdExports = requireLoadjs_umd();\nvar loadjs = /*@__PURE__*/ getDefaultExportFromCjs(loadjs_umdExports);\n// ==========================================================================\n// Load an external script\n// ==========================================================================\nfunction loadScript(url) {\n    return new Promise((resolve, reject)=>{\n        loadjs(url, {\n            success: resolve,\n            error: reject\n        });\n    });\n}\n// ==========================================================================\n// Vimeo plugin\n// ==========================================================================\n// Parse Vimeo ID from URL\nfunction parseId$1(url) {\n    if (is.empty(url)) {\n        return null;\n    }\n    if (is.number(Number(url))) {\n        return url;\n    }\n    // eslint-disable-next-line regexp/optimal-quantifier-concatenation\n    const regex = /^.*(vimeo.com\\/|video\\/)(\\d+).*/;\n    const match = url.match(regex);\n    return match ? match[2] : url;\n}\n// Try to extract a hash for private videos from the URL\nfunction parseHash(url) {\n    /* This regex matches a hexadecimal hash if given in any of these forms:\n   *  - [https://player.]vimeo.com/video/{id}/{hash}[?params]\n   *  - [https://player.]vimeo.com/video/{id}?h={hash}[&params]\n   *  - [https://player.]vimeo.com/video/{id}?[params]&h={hash}\n   *  - video/{id}/{hash}\n   * If matched, the hash is available in capture group 4\n   */ const regex = /^.*(vimeo.com\\/|video\\/)(\\d+)(\\?.*h=|\\/)+([\\d,a-f]+)/;\n    const found = url.match(regex);\n    return found && found.length === 5 ? found[4] : null;\n}\n// Set playback state and trigger change (only on actual change)\nfunction assurePlaybackState$1(play) {\n    if (play && !this.embed.hasPlayed) {\n        this.embed.hasPlayed = true;\n    }\n    if (this.media.paused === play) {\n        this.media.paused = !play;\n        triggerEvent.call(this, this.media, play ? 'play' : 'pause');\n    }\n}\nconst vimeo = {\n    setup () {\n        const player = this;\n        // Add embed class for responsive\n        toggleClass(player.elements.wrapper, player.config.classNames.embed, true);\n        // Set speed options from config\n        player.options.speed = player.config.speed.options;\n        // Set initial ratio\n        setAspectRatio.call(player);\n        // Load the SDK if not already\n        if (!is.object(window.Vimeo)) {\n            loadScript(player.config.urls.vimeo.sdk).then(()=>{\n                vimeo.ready.call(player);\n            }).catch((error)=>{\n                player.debug.warn('Vimeo SDK (player.js) failed to load', error);\n            });\n        } else {\n            vimeo.ready.call(player);\n        }\n    },\n    // API Ready\n    ready () {\n        const player = this;\n        const config = player.config.vimeo;\n        const { premium, referrerPolicy, ...frameParams } = config;\n        // Get the source URL or ID\n        let source = player.media.getAttribute('src');\n        let hash = '';\n        // Get from <div> if needed\n        if (is.empty(source)) {\n            source = player.media.getAttribute(player.config.attributes.embed.id);\n            // hash can also be set as attribute on the <div>\n            hash = player.media.getAttribute(player.config.attributes.embed.hash);\n        } else {\n            hash = parseHash(source);\n        }\n        const hashParam = hash ? {\n            h: hash\n        } : {};\n        // If the owner has a pro or premium account then we can hide controls etc\n        if (premium) {\n            Object.assign(frameParams, {\n                controls: false,\n                sidedock: false\n            });\n        }\n        // Get Vimeo params for the iframe\n        const params = buildUrlParams({\n            loop: player.config.loop.active,\n            autoplay: player.autoplay,\n            muted: player.muted,\n            gesture: 'media',\n            playsinline: player.config.playsinline,\n            // hash has to be added to iframe-URL\n            ...hashParam,\n            ...frameParams\n        });\n        const id = parseId$1(source);\n        // Build an iframe\n        const iframe = createElement('iframe');\n        const src = format(player.config.urls.vimeo.iframe, id, params);\n        iframe.setAttribute('src', src);\n        iframe.setAttribute('allowfullscreen', '');\n        iframe.setAttribute('allow', [\n            'autoplay',\n            'fullscreen',\n            'picture-in-picture',\n            'encrypted-media',\n            'accelerometer',\n            'gyroscope'\n        ].join('; '));\n        // Set the referrer policy if required\n        if (!is.empty(referrerPolicy)) {\n            iframe.setAttribute('referrerPolicy', referrerPolicy);\n        }\n        // Inject the package\n        if (premium || !config.customControls) {\n            iframe.setAttribute('data-poster', player.poster);\n            player.media = replaceElement(iframe, player.media);\n        } else {\n            const wrapper = createElement('div', {\n                'class': player.config.classNames.embedContainer,\n                'data-poster': player.poster\n            });\n            wrapper.appendChild(iframe);\n            player.media = replaceElement(wrapper, player.media);\n        }\n        // Get poster image\n        if (!config.customControls) {\n            fetch(format(player.config.urls.vimeo.api, src)).then((response)=>{\n                if (is.empty(response) || !response.thumbnail_url) {\n                    return;\n                }\n                // Set and show poster\n                ui.setPoster.call(player, response.thumbnail_url).catch(()=>{});\n            });\n        }\n        // Setup instance\n        // https://github.com/vimeo/player.js\n        player.embed = new window.Vimeo.Player(iframe, {\n            autopause: player.config.autopause,\n            muted: player.muted\n        });\n        player.media.paused = true;\n        player.media.currentTime = 0;\n        // Disable native text track rendering\n        if (player.supported.ui) {\n            player.embed.disableTextTrack();\n        }\n        // Create a faux HTML5 API using the Vimeo API\n        player.media.play = ()=>{\n            assurePlaybackState$1.call(player, true);\n            return player.embed.play();\n        };\n        player.media.pause = ()=>{\n            assurePlaybackState$1.call(player, false);\n            return player.embed.pause();\n        };\n        player.media.stop = ()=>{\n            player.pause();\n            player.currentTime = 0;\n        };\n        // Seeking\n        let { currentTime } = player.media;\n        Object.defineProperty(player.media, 'currentTime', {\n            get () {\n                return currentTime;\n            },\n            set (time) {\n                // Vimeo will automatically play on seek if the video hasn't been played before\n                // Get current paused state and volume etc\n                const { embed, media, paused, volume } = player;\n                const restorePause = paused && !embed.hasPlayed;\n                // Set seeking state and trigger event\n                media.seeking = true;\n                triggerEvent.call(player, media, 'seeking');\n                // If paused, mute until seek is complete\n                Promise.resolve(restorePause && embed.setVolume(0))// Seek\n                .then(()=>embed.setCurrentTime(time))// Restore paused\n                .then(()=>restorePause && embed.pause())// Restore volume\n                .then(()=>restorePause && embed.setVolume(volume)).catch(()=>{\n                // Do nothing\n                });\n            }\n        });\n        // Playback speed\n        let speed = player.config.speed.selected;\n        Object.defineProperty(player.media, 'playbackRate', {\n            get () {\n                return speed;\n            },\n            set (input) {\n                player.embed.setPlaybackRate(input).then(()=>{\n                    speed = input;\n                    triggerEvent.call(player, player.media, 'ratechange');\n                }).catch(()=>{\n                    // Cannot set Playback Rate, Video is probably not on Pro account\n                    player.options.speed = [\n                        1\n                    ];\n                });\n            }\n        });\n        // Volume\n        let { volume } = player.config;\n        Object.defineProperty(player.media, 'volume', {\n            get () {\n                return volume;\n            },\n            set (input) {\n                player.embed.setVolume(input).then(()=>{\n                    volume = input;\n                    triggerEvent.call(player, player.media, 'volumechange');\n                });\n            }\n        });\n        // Muted\n        let { muted } = player.config;\n        Object.defineProperty(player.media, 'muted', {\n            get () {\n                return muted;\n            },\n            set (input) {\n                const toggle = is.boolean(input) ? input : false;\n                player.embed.setMuted(toggle ? true : player.config.muted).then(()=>{\n                    muted = toggle;\n                    triggerEvent.call(player, player.media, 'volumechange');\n                });\n            }\n        });\n        // Loop\n        let { loop } = player.config;\n        Object.defineProperty(player.media, 'loop', {\n            get () {\n                return loop;\n            },\n            set (input) {\n                const toggle = is.boolean(input) ? input : player.config.loop.active;\n                player.embed.setLoop(toggle).then(()=>{\n                    loop = toggle;\n                });\n            }\n        });\n        // Source\n        let currentSrc;\n        player.embed.getVideoUrl().then((value)=>{\n            currentSrc = value;\n            controls.setDownloadUrl.call(player);\n        }).catch((error)=>{\n            this.debug.warn(error);\n        });\n        Object.defineProperty(player.media, 'currentSrc', {\n            get () {\n                return currentSrc;\n            }\n        });\n        // Ended\n        Object.defineProperty(player.media, 'ended', {\n            get () {\n                return player.currentTime === player.duration;\n            }\n        });\n        // Set aspect ratio based on video size\n        Promise.all([\n            player.embed.getVideoWidth(),\n            player.embed.getVideoHeight()\n        ]).then((dimensions)=>{\n            const [width, height] = dimensions;\n            player.embed.ratio = roundAspectRatio(width, height);\n            setAspectRatio.call(this);\n        });\n        // Set autopause\n        player.embed.setAutopause(player.config.autopause).then((state)=>{\n            player.config.autopause = state;\n        });\n        // Get title\n        player.embed.getVideoTitle().then((title)=>{\n            player.config.title = title;\n            ui.setTitle.call(this);\n        });\n        // Get current time\n        player.embed.getCurrentTime().then((value)=>{\n            currentTime = value;\n            triggerEvent.call(player, player.media, 'timeupdate');\n        });\n        // Get duration\n        player.embed.getDuration().then((value)=>{\n            player.media.duration = value;\n            triggerEvent.call(player, player.media, 'durationchange');\n        });\n        // Get captions\n        player.embed.getTextTracks().then((tracks)=>{\n            player.media.textTracks = tracks;\n            captions.setup.call(player);\n        });\n        player.embed.on('cuechange', ({ cues = [] })=>{\n            const strippedCues = cues.map((cue)=>stripHTML(cue.text));\n            captions.updateCues.call(player, strippedCues);\n        });\n        player.embed.on('loaded', ()=>{\n            // Assure state and events are updated on autoplay\n            player.embed.getPaused().then((paused)=>{\n                assurePlaybackState$1.call(player, !paused);\n                if (!paused) {\n                    triggerEvent.call(player, player.media, 'playing');\n                }\n            });\n            if (is.element(player.embed.element) && player.supported.ui) {\n                const frame = player.embed.element;\n                // Fix keyboard focus issues\n                // https://github.com/sampotts/plyr/issues/317\n                frame.setAttribute('tabindex', -1);\n            }\n        });\n        player.embed.on('bufferstart', ()=>{\n            triggerEvent.call(player, player.media, 'waiting');\n        });\n        player.embed.on('bufferend', ()=>{\n            triggerEvent.call(player, player.media, 'playing');\n        });\n        player.embed.on('play', ()=>{\n            assurePlaybackState$1.call(player, true);\n            triggerEvent.call(player, player.media, 'playing');\n        });\n        player.embed.on('pause', ()=>{\n            assurePlaybackState$1.call(player, false);\n        });\n        player.embed.on('timeupdate', (data)=>{\n            player.media.seeking = false;\n            currentTime = data.seconds;\n            triggerEvent.call(player, player.media, 'timeupdate');\n        });\n        player.embed.on('progress', (data)=>{\n            player.media.buffered = data.percent;\n            triggerEvent.call(player, player.media, 'progress');\n            // Check all loaded\n            if (Number.parseInt(data.percent, 10) === 1) {\n                triggerEvent.call(player, player.media, 'canplaythrough');\n            }\n            // Get duration as if we do it before load, it gives an incorrect value\n            // https://github.com/sampotts/plyr/issues/891\n            player.embed.getDuration().then((value)=>{\n                if (value !== player.media.duration) {\n                    player.media.duration = value;\n                    triggerEvent.call(player, player.media, 'durationchange');\n                }\n            });\n        });\n        player.embed.on('seeked', ()=>{\n            player.media.seeking = false;\n            triggerEvent.call(player, player.media, 'seeked');\n        });\n        player.embed.on('ended', ()=>{\n            player.media.paused = true;\n            triggerEvent.call(player, player.media, 'ended');\n        });\n        player.embed.on('error', (detail)=>{\n            player.media.error = detail;\n            triggerEvent.call(player, player.media, 'error');\n        });\n        // Rebuild UI\n        if (config.customControls) {\n            setTimeout(()=>ui.build.call(player), 0);\n        }\n    }\n};\n// ==========================================================================\n// YouTube plugin\n// ==========================================================================\n// Parse YouTube ID from URL\nfunction parseId(url) {\n    if (is.empty(url)) {\n        return null;\n    }\n    const regex = /^.*(youtu.be\\/|v\\/|u\\/\\w\\/|embed\\/|watch\\?v=|&v=)([^#&?]*).*/;\n    const match = url.match(regex);\n    return match && match[2] ? match[2] : url;\n}\n// Set playback state and trigger change (only on actual change)\nfunction assurePlaybackState(play) {\n    if (play && !this.embed.hasPlayed) {\n        this.embed.hasPlayed = true;\n    }\n    if (this.media.paused === play) {\n        this.media.paused = !play;\n        triggerEvent.call(this, this.media, play ? 'play' : 'pause');\n    }\n}\nfunction getHost(config) {\n    if (config.noCookie) {\n        return 'https://www.youtube-nocookie.com';\n    }\n    if (window.location.protocol === 'http:') {\n        return 'http://www.youtube.com';\n    }\n    // Use YouTube's default\n    return undefined;\n}\nconst youtube = {\n    setup () {\n        // Add embed class for responsive\n        toggleClass(this.elements.wrapper, this.config.classNames.embed, true);\n        // Setup API\n        if (is.object(window.YT) && is.function(window.YT.Player)) {\n            youtube.ready.call(this);\n        } else {\n            // Reference current global callback\n            const callback = window.onYouTubeIframeAPIReady;\n            // Set callback to process queue\n            window.onYouTubeIframeAPIReady = ()=>{\n                // Call global callback if set\n                if (is.function(callback)) {\n                    callback();\n                }\n                youtube.ready.call(this);\n            };\n            // Load the SDK\n            loadScript(this.config.urls.youtube.sdk).catch((error)=>{\n                this.debug.warn('YouTube API failed to load', error);\n            });\n        }\n    },\n    // Get the media title\n    getTitle (videoId) {\n        const url = format(this.config.urls.youtube.api, videoId);\n        fetch(url).then((data)=>{\n            if (is.object(data)) {\n                const { title, height, width } = data;\n                // Set title\n                this.config.title = title;\n                ui.setTitle.call(this);\n                // Set aspect ratio\n                this.embed.ratio = roundAspectRatio(width, height);\n            }\n            setAspectRatio.call(this);\n        }).catch(()=>{\n            // Set aspect ratio\n            setAspectRatio.call(this);\n        });\n    },\n    // API ready\n    ready () {\n        const player = this;\n        const config = player.config.youtube;\n        // Ignore already setup (race condition)\n        const currentId = player.media && player.media.getAttribute('id');\n        if (!is.empty(currentId) && currentId.startsWith('youtube-')) {\n            return;\n        }\n        // Get the source URL or ID\n        let source = player.media.getAttribute('src');\n        // Get from <div> if needed\n        if (is.empty(source)) {\n            source = player.media.getAttribute(this.config.attributes.embed.id);\n        }\n        // Replace the <iframe> with a <div> due to YouTube API issues\n        const videoId = parseId(source);\n        const id = generateId(player.provider);\n        // Replace media element\n        const container = createElement('div', {\n            id,\n            'data-poster': config.customControls ? player.poster : undefined\n        });\n        player.media = replaceElement(container, player.media);\n        // Only load the poster when using custom controls\n        if (config.customControls) {\n            const posterSrc = (s)=>`https://i.ytimg.com/vi/${videoId}/${s}default.jpg`;\n            // Check thumbnail images in order of quality, but reject fallback thumbnails (120px wide)\n            loadImage(posterSrc('maxres'), 121) // Highest quality and un-padded\n            .catch(()=>loadImage(posterSrc('sd'), 121)) // 480p padded 4:3\n            .catch(()=>loadImage(posterSrc('hq'))) // 360p padded 4:3. Always exists\n            .then((image)=>ui.setPoster.call(player, image.src)).then((src)=>{\n                // If the image is padded, use background-size \"cover\" instead (like youtube does too with their posters)\n                if (!src.includes('maxres')) {\n                    player.elements.poster.style.backgroundSize = 'cover';\n                }\n            }).catch(()=>{});\n        }\n        // Setup instance\n        // https://developers.google.com/youtube/iframe_api_reference\n        player.embed = new window.YT.Player(player.media, {\n            videoId,\n            host: getHost(config),\n            playerVars: extend({}, {\n                // Autoplay\n                autoplay: player.config.autoplay ? 1 : 0,\n                // iframe interface language\n                hl: player.config.hl,\n                // Only show controls if not fully supported or opted out\n                controls: player.supported.ui && config.customControls ? 0 : 1,\n                // Disable keyboard as we handle it\n                disablekb: 1,\n                // Allow iOS inline playback\n                playsinline: player.config.playsinline && !player.config.fullscreen.iosNative ? 1 : 0,\n                // Captions are flaky on YouTube\n                cc_load_policy: player.captions.active ? 1 : 0,\n                cc_lang_pref: player.config.captions.language,\n                // Tracking for stats\n                widget_referrer: window ? window.location.href : null\n            }, config),\n            events: {\n                onError (event) {\n                    // YouTube may fire onError twice, so only handle it once\n                    if (!player.media.error) {\n                        const code = event.data;\n                        // Messages copied from https://developers.google.com/youtube/iframe_api_reference#onError\n                        const message = {\n                            2: 'The request contains an invalid parameter value. For example, this error occurs if you specify a video ID that does not have 11 characters, or if the video ID contains invalid characters, such as exclamation points or asterisks.',\n                            5: 'The requested content cannot be played in an HTML5 player or another error related to the HTML5 player has occurred.',\n                            100: 'The video requested was not found. This error occurs when a video has been removed (for any reason) or has been marked as private.',\n                            101: 'The owner of the requested video does not allow it to be played in embedded players.',\n                            150: 'The owner of the requested video does not allow it to be played in embedded players.'\n                        }[code] || 'An unknown error occurred';\n                        player.media.error = {\n                            code,\n                            message\n                        };\n                        triggerEvent.call(player, player.media, 'error');\n                    }\n                },\n                onPlaybackRateChange (event) {\n                    // Get the instance\n                    const instance = event.target;\n                    // Get current speed\n                    player.media.playbackRate = instance.getPlaybackRate();\n                    triggerEvent.call(player, player.media, 'ratechange');\n                },\n                onReady (event) {\n                    // Bail if onReady has already been called. See issue #1108\n                    if (is.function(player.media.play)) {\n                        return;\n                    }\n                    // Get the instance\n                    const instance = event.target;\n                    // Get the title\n                    youtube.getTitle.call(player, videoId);\n                    // Create a faux HTML5 API using the YouTube API\n                    player.media.play = ()=>{\n                        assurePlaybackState.call(player, true);\n                        instance.playVideo();\n                    };\n                    player.media.pause = ()=>{\n                        assurePlaybackState.call(player, false);\n                        instance.pauseVideo();\n                    };\n                    player.media.stop = ()=>{\n                        instance.stopVideo();\n                    };\n                    player.media.duration = instance.getDuration();\n                    player.media.paused = true;\n                    // Seeking\n                    player.media.currentTime = 0;\n                    Object.defineProperty(player.media, 'currentTime', {\n                        get () {\n                            return Number(instance.getCurrentTime());\n                        },\n                        set (time) {\n                            // If paused and never played, mute audio preventively (YouTube starts playing on seek if the video hasn't been played yet).\n                            if (player.paused && !player.embed.hasPlayed) {\n                                player.embed.mute();\n                            }\n                            // Set seeking state and trigger event\n                            player.media.seeking = true;\n                            triggerEvent.call(player, player.media, 'seeking');\n                            // Seek after events sent\n                            instance.seekTo(time);\n                        }\n                    });\n                    // Playback speed\n                    Object.defineProperty(player.media, 'playbackRate', {\n                        get () {\n                            return instance.getPlaybackRate();\n                        },\n                        set (input) {\n                            instance.setPlaybackRate(input);\n                        }\n                    });\n                    // Volume\n                    let { volume } = player.config;\n                    Object.defineProperty(player.media, 'volume', {\n                        get () {\n                            return volume;\n                        },\n                        set (input) {\n                            volume = input;\n                            instance.setVolume(volume * 100);\n                            triggerEvent.call(player, player.media, 'volumechange');\n                        }\n                    });\n                    // Muted\n                    let { muted } = player.config;\n                    Object.defineProperty(player.media, 'muted', {\n                        get () {\n                            return muted;\n                        },\n                        set (input) {\n                            const toggle = is.boolean(input) ? input : muted;\n                            muted = toggle;\n                            instance[toggle ? 'mute' : 'unMute']();\n                            instance.setVolume(volume * 100);\n                            triggerEvent.call(player, player.media, 'volumechange');\n                        }\n                    });\n                    // Source\n                    Object.defineProperty(player.media, 'currentSrc', {\n                        get () {\n                            return instance.getVideoUrl();\n                        }\n                    });\n                    // Ended\n                    Object.defineProperty(player.media, 'ended', {\n                        get () {\n                            return player.currentTime === player.duration;\n                        }\n                    });\n                    // Get available speeds\n                    const speeds = instance.getAvailablePlaybackRates();\n                    // Filter based on config\n                    player.options.speed = speeds.filter((s)=>player.config.speed.options.includes(s));\n                    // Set the tabindex to avoid focus entering iframe\n                    if (player.supported.ui && config.customControls) {\n                        player.media.setAttribute('tabindex', -1);\n                    }\n                    triggerEvent.call(player, player.media, 'timeupdate');\n                    triggerEvent.call(player, player.media, 'durationchange');\n                    // Reset timer\n                    clearInterval(player.timers.buffering);\n                    // Setup buffering\n                    player.timers.buffering = setInterval(()=>{\n                        // Get loaded % from YouTube\n                        player.media.buffered = instance.getVideoLoadedFraction();\n                        // Trigger progress only when we actually buffer something\n                        if (player.media.lastBuffered === null || player.media.lastBuffered < player.media.buffered) {\n                            triggerEvent.call(player, player.media, 'progress');\n                        }\n                        // Set last buffer point\n                        player.media.lastBuffered = player.media.buffered;\n                        // Bail if we're at 100%\n                        if (player.media.buffered === 1) {\n                            clearInterval(player.timers.buffering);\n                            // Trigger event\n                            triggerEvent.call(player, player.media, 'canplaythrough');\n                        }\n                    }, 200);\n                    // Rebuild UI\n                    if (config.customControls) {\n                        setTimeout(()=>ui.build.call(player), 50);\n                    }\n                },\n                onStateChange (event) {\n                    // Get the instance\n                    const instance = event.target;\n                    // Reset timer\n                    clearInterval(player.timers.playing);\n                    const seeked = player.media.seeking && [\n                        1,\n                        2\n                    ].includes(event.data);\n                    if (seeked) {\n                        // Unset seeking and fire seeked event\n                        player.media.seeking = false;\n                        triggerEvent.call(player, player.media, 'seeked');\n                    }\n                    // Handle events\n                    // -1   Unstarted\n                    // 0    Ended\n                    // 1    Playing\n                    // 2    Paused\n                    // 3    Buffering\n                    // 5    Video cued\n                    switch(event.data){\n                        case -1:\n                            // Update scrubber\n                            triggerEvent.call(player, player.media, 'timeupdate');\n                            // Get loaded % from YouTube\n                            player.media.buffered = instance.getVideoLoadedFraction();\n                            triggerEvent.call(player, player.media, 'progress');\n                            break;\n                        case 0:\n                            assurePlaybackState.call(player, false);\n                            // YouTube doesn't support loop for a single video, so mimick it.\n                            if (player.media.loop) {\n                                // YouTube needs a call to `stopVideo` before playing again\n                                instance.stopVideo();\n                                instance.playVideo();\n                            } else {\n                                triggerEvent.call(player, player.media, 'ended');\n                            }\n                            break;\n                        case 1:\n                            // Restore paused state (YouTube starts playing on seek if the video hasn't been played yet)\n                            if (config.customControls && !player.config.autoplay && player.media.paused && !player.embed.hasPlayed) {\n                                player.media.pause();\n                            } else {\n                                assurePlaybackState.call(player, true);\n                                triggerEvent.call(player, player.media, 'playing');\n                                // Poll to get playback progress\n                                player.timers.playing = setInterval(()=>{\n                                    triggerEvent.call(player, player.media, 'timeupdate');\n                                }, 50);\n                                // Check duration again due to YouTube bug\n                                // https://github.com/sampotts/plyr/issues/374\n                                // https://code.google.com/p/gdata-issues/issues/detail?id=8690\n                                if (player.media.duration !== instance.getDuration()) {\n                                    player.media.duration = instance.getDuration();\n                                    triggerEvent.call(player, player.media, 'durationchange');\n                                }\n                            }\n                            break;\n                        case 2:\n                            // Restore audio (YouTube starts playing on seek if the video hasn't been played yet)\n                            if (!player.muted) {\n                                player.embed.unMute();\n                            }\n                            assurePlaybackState.call(player, false);\n                            break;\n                        case 3:\n                            // Trigger waiting event to add loading classes to container as the video buffers.\n                            triggerEvent.call(player, player.media, 'waiting');\n                            break;\n                    }\n                    triggerEvent.call(player, player.elements.container, 'statechange', false, {\n                        code: event.data\n                    });\n                }\n            }\n        });\n    }\n};\n// ==========================================================================\n// Plyr Media\n// ==========================================================================\nconst media = {\n    // Setup media\n    setup () {\n        // If there's no media, bail\n        if (!this.media) {\n            this.debug.warn('No media element found!');\n            return;\n        }\n        // Add type class\n        toggleClass(this.elements.container, this.config.classNames.type.replace('{0}', this.type), true);\n        // Add provider class\n        toggleClass(this.elements.container, this.config.classNames.provider.replace('{0}', this.provider), true);\n        // Add video class for embeds\n        // This will require changes if audio embeds are added\n        if (this.isEmbed) {\n            toggleClass(this.elements.container, this.config.classNames.type.replace('{0}', 'video'), true);\n        }\n        // Inject the player wrapper\n        if (this.isVideo) {\n            // Create the wrapper div\n            this.elements.wrapper = createElement('div', {\n                class: this.config.classNames.video\n            });\n            // Wrap the video in a container\n            wrap(this.media, this.elements.wrapper);\n            // Poster image container\n            this.elements.poster = createElement('div', {\n                class: this.config.classNames.poster\n            });\n            this.elements.wrapper.appendChild(this.elements.poster);\n        }\n        if (this.isHTML5) {\n            html5.setup.call(this);\n        } else if (this.isYouTube) {\n            youtube.setup.call(this);\n        } else if (this.isVimeo) {\n            vimeo.setup.call(this);\n        }\n    }\n};\nfunction destroy(instance) {\n    // Destroy our adsManager\n    if (instance.manager) {\n        instance.manager.destroy();\n    }\n    // Destroy our adsManager\n    if (instance.elements.displayContainer) {\n        instance.elements.displayContainer.destroy();\n    }\n    instance.elements.container.remove();\n}\nclass Ads {\n    /**\n   * Ads constructor.\n   * @param {object} player\n   * @return {Ads}\n   */ constructor(player){\n        /**\n     * Load the IMA SDK\n     */ _defineProperty$1(this, \"load\", ()=>{\n            if (!this.enabled) {\n                return;\n            }\n            // Check if the Google IMA3 SDK is loaded or load it ourselves\n            if (!is.object(window.google) || !is.object(window.google.ima)) {\n                loadScript(this.player.config.urls.googleIMA.sdk).then(()=>{\n                    this.ready();\n                }).catch(()=>{\n                    // Script failed to load or is blocked\n                    this.trigger('error', new Error('Google IMA SDK failed to load'));\n                });\n            } else {\n                this.ready();\n            }\n        });\n        /**\n     * Get the ads instance ready\n     */ _defineProperty$1(this, \"ready\", ()=>{\n            // Double check we're enabled\n            if (!this.enabled) {\n                destroy(this);\n            }\n            // Start ticking our safety timer. If the whole advertisement\n            // thing doesn't resolve within our set time; we bail\n            this.startSafetyTimer(12000, 'ready()');\n            // Clear the safety timer\n            this.managerPromise.then(()=>{\n                this.clearSafetyTimer('onAdsManagerLoaded()');\n            });\n            // Set listeners on the Plyr instance\n            this.listeners();\n            // Setup the IMA SDK\n            this.setupIMA();\n        });\n        /**\n     * In order for the SDK to display ads for our video, we need to tell it where to put them,\n     * so here we define our ad container. This div is set up to render on top of the video player.\n     * Using the code below, we tell the SDK to render ads within that div. We also provide a\n     * handle to the content video player - the SDK will poll the current time of our player to\n     * properly place mid-rolls. After we create the ad display container, we initialize it. On\n     * mobile devices, this initialization is done as the result of a user action.\n     */ _defineProperty$1(this, \"setupIMA\", ()=>{\n            // Create the container for our advertisements\n            this.elements.container = createElement('div', {\n                class: this.player.config.classNames.ads\n            });\n            this.player.elements.container.appendChild(this.elements.container);\n            // So we can run VPAID2\n            google.ima.settings.setVpaidMode(google.ima.ImaSdkSettings.VpaidMode.ENABLED);\n            // Set language\n            google.ima.settings.setLocale(this.player.config.ads.language);\n            // Set playback for iOS10+\n            google.ima.settings.setDisableCustomPlaybackForIOS10Plus(this.player.config.playsinline);\n            // We assume the adContainer is the video container of the plyr element that will house the ads\n            this.elements.displayContainer = new google.ima.AdDisplayContainer(this.elements.container, this.player.media);\n            // Create ads loader\n            this.loader = new google.ima.AdsLoader(this.elements.displayContainer);\n            // Listen and respond to ads loaded and error events\n            this.loader.addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, (event)=>this.onAdsManagerLoaded(event), false);\n            this.loader.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, (error)=>this.onAdError(error), false);\n            // Request video ads to be pre-loaded\n            this.requestAds();\n        });\n        /**\n     * Request advertisements\n     */ _defineProperty$1(this, \"requestAds\", ()=>{\n            const { container } = this.player.elements;\n            try {\n                // Request video ads\n                const request = new google.ima.AdsRequest();\n                request.adTagUrl = this.tagUrl;\n                // Specify the linear and nonlinear slot sizes. This helps the SDK\n                // to select the correct creative if multiple are returned\n                request.linearAdSlotWidth = container.offsetWidth;\n                request.linearAdSlotHeight = container.offsetHeight;\n                request.nonLinearAdSlotWidth = container.offsetWidth;\n                request.nonLinearAdSlotHeight = container.offsetHeight;\n                // We only overlay ads as we only support video.\n                request.forceNonLinearFullSlot = false;\n                // Mute based on current state\n                request.setAdWillPlayMuted(!this.player.muted);\n                this.loader.requestAds(request);\n            } catch (error) {\n                this.onAdError(error);\n            }\n        });\n        /**\n     * Update the ad countdown\n     * @param {boolean} start\n     */ _defineProperty$1(this, \"pollCountdown\", (start = false)=>{\n            if (!start) {\n                clearInterval(this.countdownTimer);\n                this.elements.container.removeAttribute('data-badge-text');\n                return;\n            }\n            const update = ()=>{\n                const time = formatTime(Math.max(this.manager.getRemainingTime(), 0));\n                const label = `${i18n.get('advertisement', this.player.config)} - ${time}`;\n                this.elements.container.setAttribute('data-badge-text', label);\n            };\n            this.countdownTimer = setInterval(update, 100);\n        });\n        /**\n     * This method is called whenever the ads are ready inside the AdDisplayContainer\n     * @param {Event} event - adsManagerLoadedEvent\n     */ _defineProperty$1(this, \"onAdsManagerLoaded\", (event)=>{\n            // Load could occur after a source change (race condition)\n            if (!this.enabled) {\n                return;\n            }\n            // Get the ads manager\n            const settings = new google.ima.AdsRenderingSettings();\n            // Tell the SDK to save and restore content video state on our behalf\n            settings.restoreCustomPlaybackStateOnAdBreakComplete = true;\n            settings.enablePreloading = true;\n            // The SDK is polling currentTime on the contentPlayback. And needs a duration\n            // so it can determine when to start the mid- and post-roll\n            this.manager = event.getAdsManager(this.player, settings);\n            // Get the cue points for any mid-rolls by filtering out the pre- and post-roll\n            this.cuePoints = this.manager.getCuePoints();\n            // Add listeners to the required events\n            // Advertisement error events\n            this.manager.addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, (error)=>this.onAdError(error));\n            // Advertisement regular events\n            Object.keys(google.ima.AdEvent.Type).forEach((type)=>{\n                this.manager.addEventListener(google.ima.AdEvent.Type[type], (e)=>this.onAdEvent(e));\n            });\n            // Resolve our adsManager\n            this.trigger('loaded');\n        });\n        _defineProperty$1(this, \"addCuePoints\", ()=>{\n            // Add advertisement cue's within the time line if available\n            if (!is.empty(this.cuePoints)) {\n                this.cuePoints.forEach((cuePoint)=>{\n                    if (cuePoint !== 0 && cuePoint !== -1 && cuePoint < this.player.duration) {\n                        const seekElement = this.player.elements.progress;\n                        if (is.element(seekElement)) {\n                            const cuePercentage = 100 / this.player.duration * cuePoint;\n                            const cue = createElement('span', {\n                                class: this.player.config.classNames.cues\n                            });\n                            cue.style.left = `${cuePercentage.toString()}%`;\n                            seekElement.appendChild(cue);\n                        }\n                    }\n                });\n            }\n        });\n        /**\n     * This is where all the event handling takes place. Retrieve the ad from the event. Some\n     * events (e.g. ALL_ADS_COMPLETED) don't have the ad object associated\n     * https://developers.google.com/interactive-media-ads/docs/sdks/html5/v3/apis#ima.AdEvent.Type\n     * @param {Event} event\n     */ _defineProperty$1(this, \"onAdEvent\", (event)=>{\n            const { container } = this.player.elements;\n            // Retrieve the ad from the event. Some events (e.g. ALL_ADS_COMPLETED)\n            // don't have ad object associated\n            const ad = event.getAd();\n            const adData = event.getAdData();\n            // Proxy event\n            const dispatchEvent = (type)=>{\n                triggerEvent.call(this.player, this.player.media, `ads${type.replace(/_/g, '').toLowerCase()}`);\n            };\n            // Bubble the event\n            dispatchEvent(event.type);\n            switch(event.type){\n                case google.ima.AdEvent.Type.LOADED:\n                    // This is the first event sent for an ad - it is possible to determine whether the\n                    // ad is a video ad or an overlay\n                    this.trigger('loaded');\n                    // Start countdown\n                    this.pollCountdown(true);\n                    if (!ad.isLinear()) {\n                        // Position AdDisplayContainer correctly for overlay\n                        ad.width = container.offsetWidth;\n                        ad.height = container.offsetHeight;\n                    }\n                    break;\n                case google.ima.AdEvent.Type.STARTED:\n                    // Set volume to match player\n                    this.manager.setVolume(this.player.volume);\n                    break;\n                case google.ima.AdEvent.Type.ALL_ADS_COMPLETED:\n                    // All ads for the current videos are done. We can now request new advertisements\n                    // in case the video is re-played\n                    // TODO: Example for what happens when a next video in a playlist would be loaded.\n                    // So here we load a new video when all ads are done.\n                    // Then we load new ads within a new adsManager. When the video\n                    // Is started - after - the ads are loaded, then we get ads.\n                    // You can also easily test cancelling and reloading by running\n                    // player.ads.cancel() and player.ads.play from the console I guess.\n                    // this.player.source = {\n                    //     type: 'video',\n                    //     title: 'View From A Blue Moon',\n                    //     sources: [{\n                    //         src:\n                    // 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-HD.mp4', type:\n                    // 'video/mp4', }], poster:\n                    // 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-HD.jpg', tracks:\n                    // [ { kind: 'captions', label: 'English', srclang: 'en', src:\n                    // 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-HD.en.vtt',\n                    // default: true, }, { kind: 'captions', label: 'French', srclang: 'fr', src:\n                    // 'https://cdn.plyr.io/static/demo/View_From_A_Blue_Moon_Trailer-HD.fr.vtt', }, ],\n                    // };\n                    // TODO: So there is still this thing where a video should only be allowed to start\n                    // playing when the IMA SDK is ready or has failed\n                    if (this.player.ended) {\n                        this.loadAds();\n                    } else {\n                        // The SDK won't allow new ads to be called without receiving a contentComplete()\n                        this.loader.contentComplete();\n                    }\n                    break;\n                case google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED:\n                    // This event indicates the ad has started - the video player can adjust the UI,\n                    // for example display a pause button and remaining time. Fired when content should\n                    // be paused. This usually happens right before an ad is about to cover the content\n                    this.pauseContent();\n                    break;\n                case google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED:\n                    // This event indicates the ad has finished - the video player can perform\n                    // appropriate UI actions, such as removing the timer for remaining time detection.\n                    // Fired when content should be resumed. This usually happens when an ad finishes\n                    // or collapses\n                    this.pollCountdown();\n                    this.resumeContent();\n                    break;\n                case google.ima.AdEvent.Type.LOG:\n                    if (adData.adError) {\n                        this.player.debug.warn(`Non-fatal ad error: ${adData.adError.getMessage()}`);\n                    }\n                    break;\n            }\n        });\n        /**\n     * Any ad error handling comes through here\n     * @param {Event} event\n     */ _defineProperty$1(this, \"onAdError\", (event)=>{\n            this.cancel();\n            this.player.debug.warn('Ads error', event);\n        });\n        /**\n     * Setup hooks for Plyr and window events. This ensures\n     * the mid- and post-roll launch at the correct time. And\n     * resize the advertisement when the player resizes\n     */ _defineProperty$1(this, \"listeners\", ()=>{\n            const { container } = this.player.elements;\n            let time;\n            this.player.on('canplay', ()=>{\n                this.addCuePoints();\n            });\n            this.player.on('ended', ()=>{\n                this.loader.contentComplete();\n            });\n            this.player.on('timeupdate', ()=>{\n                time = this.player.currentTime;\n            });\n            this.player.on('seeked', ()=>{\n                const seekedTime = this.player.currentTime;\n                if (is.empty(this.cuePoints)) {\n                    return;\n                }\n                this.cuePoints.forEach((cuePoint, index)=>{\n                    if (time < cuePoint && cuePoint < seekedTime) {\n                        this.manager.discardAdBreak();\n                        this.cuePoints.splice(index, 1);\n                    }\n                });\n            });\n            // Listen to the resizing of the window. And resize ad accordingly\n            // TODO: eventually implement ResizeObserver\n            window.addEventListener('resize', ()=>{\n                if (this.manager) {\n                    this.manager.resize(container.offsetWidth, container.offsetHeight, google.ima.ViewMode.NORMAL);\n                }\n            });\n        });\n        /**\n     * Initialize the adsManager and start playing advertisements\n     */ _defineProperty$1(this, \"play\", ()=>{\n            const { container } = this.player.elements;\n            if (!this.managerPromise) {\n                this.resumeContent();\n            }\n            // Play the requested advertisement whenever the adsManager is ready\n            this.managerPromise.then(()=>{\n                // Set volume to match player\n                this.manager.setVolume(this.player.volume);\n                // Initialize the container. Must be done via a user action on mobile devices\n                this.elements.displayContainer.initialize();\n                try {\n                    if (!this.initialized) {\n                        // Initialize the ads manager. Ad rules playlist will start at this time\n                        this.manager.init(container.offsetWidth, container.offsetHeight, google.ima.ViewMode.NORMAL);\n                        // Call play to start showing the ad. Single video and overlay ads will\n                        // start at this time; the call will be ignored for ad rules\n                        this.manager.start();\n                    }\n                    this.initialized = true;\n                } catch (adError) {\n                    // An error may be thrown if there was a problem with the\n                    // VAST response\n                    this.onAdError(adError);\n                }\n            }).catch(()=>{});\n        });\n        /**\n     * Resume our video\n     */ _defineProperty$1(this, \"resumeContent\", ()=>{\n            // Hide the advertisement container\n            this.elements.container.style.zIndex = '';\n            // Ad is stopped\n            this.playing = false;\n            // Play video\n            silencePromise(this.player.media.play());\n        });\n        /**\n     * Pause our video\n     */ _defineProperty$1(this, \"pauseContent\", ()=>{\n            // Show the advertisement container\n            this.elements.container.style.zIndex = 3;\n            // Ad is playing\n            this.playing = true;\n            // Pause our video.\n            this.player.media.pause();\n        });\n        /**\n     * Destroy the adsManager so we can grab new ads after this. If we don't then we're not\n     * allowed to call new ads based on google policies, as they interpret this as an accidental\n     * video requests. https://developers.google.com/interactive-\n     * media-ads/docs/sdks/android/faq#8\n     */ _defineProperty$1(this, \"cancel\", ()=>{\n            // Pause our video\n            if (this.initialized) {\n                this.resumeContent();\n            }\n            // Tell our instance that we're done for now\n            this.trigger('error');\n            // Re-create our adsManager\n            this.loadAds();\n        });\n        /**\n     * Re-create our adsManager\n     */ _defineProperty$1(this, \"loadAds\", ()=>{\n            // Tell our adsManager to go bye bye\n            this.managerPromise.then(()=>{\n                // Destroy our adsManager\n                if (this.manager) {\n                    this.manager.destroy();\n                }\n                // Re-set our adsManager promises\n                this.managerPromise = new Promise((resolve)=>{\n                    this.on('loaded', resolve);\n                    this.player.debug.log(this.manager);\n                });\n                // Now that the manager has been destroyed set it to also be un-initialized\n                this.initialized = false;\n                // Now request some new advertisements\n                this.requestAds();\n            }).catch(()=>{});\n        });\n        /**\n     * Handles callbacks after an ad event was invoked\n     * @param {string} event - Event type\n     * @param args\n     */ _defineProperty$1(this, \"trigger\", (event, ...args)=>{\n            const handlers = this.events[event];\n            if (is.array(handlers)) {\n                handlers.forEach((handler)=>{\n                    if (is.function(handler)) {\n                        handler.apply(this, args);\n                    }\n                });\n            }\n        });\n        /**\n     * Add event listeners\n     * @param {string} event - Event type\n     * @param {Function} callback - Callback for when event occurs\n     * @return {Ads}\n     */ _defineProperty$1(this, \"on\", (event, callback)=>{\n            if (!is.array(this.events[event])) {\n                this.events[event] = [];\n            }\n            this.events[event].push(callback);\n            return this;\n        });\n        /**\n     * Setup a safety timer for when the ad network doesn't respond for whatever reason.\n     * The advertisement has 12 seconds to get its things together. We stop this timer when the\n     * advertisement is playing, or when a user action is required to start, then we clear the\n     * timer on ad ready\n     * @param {number} time\n     * @param {string} from\n     */ _defineProperty$1(this, \"startSafetyTimer\", (time, from)=>{\n            this.player.debug.log(`Safety timer invoked from: ${from}`);\n            this.safetyTimer = setTimeout(()=>{\n                this.cancel();\n                this.clearSafetyTimer('startSafetyTimer()');\n            }, time);\n        });\n        /**\n     * Clear our safety timer(s)\n     * @param {string} from\n     */ _defineProperty$1(this, \"clearSafetyTimer\", (from)=>{\n            if (!is.nullOrUndefined(this.safetyTimer)) {\n                this.player.debug.log(`Safety timer cleared from: ${from}`);\n                clearTimeout(this.safetyTimer);\n                this.safetyTimer = null;\n            }\n        });\n        this.player = player;\n        this.config = player.config.ads;\n        this.playing = false;\n        this.initialized = false;\n        this.elements = {\n            container: null,\n            displayContainer: null\n        };\n        this.manager = null;\n        this.loader = null;\n        this.cuePoints = null;\n        this.events = {};\n        this.safetyTimer = null;\n        this.countdownTimer = null;\n        // Setup a promise to resolve when the IMA manager is ready\n        this.managerPromise = new Promise((resolve, reject)=>{\n            // The ad is loaded and ready\n            this.on('loaded', resolve);\n            // Ads failed\n            this.on('error', reject);\n        });\n        this.load();\n    }\n    get enabled() {\n        const { config } = this;\n        return this.player.isHTML5 && this.player.isVideo && config.enabled && (!is.empty(config.publisherId) || is.url(config.tagUrl));\n    }\n    // Build the tag URL\n    get tagUrl() {\n        const { config } = this;\n        if (is.url(config.tagUrl)) {\n            return config.tagUrl;\n        }\n        const params = {\n            AV_PUBLISHERID: '58c25bb0073ef448b1087ad6',\n            AV_CHANNELID: '5a0458dc28a06145e4519d21',\n            AV_URL: window.location.hostname,\n            cb: Date.now(),\n            AV_WIDTH: 640,\n            AV_HEIGHT: 480,\n            AV_CDIM2: config.publisherId\n        };\n        const base = 'https://go.aniview.com/api/adserver6/vast/';\n        return `${base}?${buildUrlParams(params)}`;\n    }\n}\n/**\n * Returns a number whose value is limited to the given range.\n *\n * Example: limit the output of this computation to between 0 and 255\n * (x * 255).clamp(0, 255)\n *\n * @param {number} input\n * @param {number} min The lower boundary of the output range\n * @param {number} max The upper boundary of the output range\n * @returns A number within the bounds of min and max\n * @type Number\n */ function clamp(input = 0, min = 0, max = 255) {\n    return Math.min(Math.max(input, min), max);\n}\n// Arg: vttDataString example: \"WEBVTT\\n\\n1\\n00:00:05.000 --> 00:00:10.000\\n1080p-00001.jpg\"\nfunction parseVtt(vttDataString) {\n    const processedList = [];\n    const frames = vttDataString.split(/\\r\\n\\r\\n|\\n\\n|\\r\\r/);\n    frames.forEach((frame)=>{\n        const result = {};\n        const lines = frame.split(/\\r\\n|\\n|\\r/);\n        lines.forEach((line)=>{\n            if (!is.number(result.startTime)) {\n                // The line with start and end times on it is the first line of interest\n                const matchTimes = line.match(/(\\d{2})?:?(\\d{2}):(\\d{2}).(\\d{2,3})( ?--> ?)(\\d{2})?:?(\\d{2}):(\\d{2}).(\\d{2,3})/); // Note that this currently ignores caption formatting directives that are optionally on the end of this line - fine for non-captions VTT\n                if (matchTimes) {\n                    result.startTime = Number(matchTimes[1] || 0) * 60 * 60 + Number(matchTimes[2]) * 60 + Number(matchTimes[3]) + Number(`0.${matchTimes[4]}`);\n                    result.endTime = Number(matchTimes[6] || 0) * 60 * 60 + Number(matchTimes[7]) * 60 + Number(matchTimes[8]) + Number(`0.${matchTimes[9]}`);\n                }\n            } else if (!is.empty(line.trim()) && is.empty(result.text)) {\n                // If we already have the startTime, then we're definitely up to the text line(s)\n                const lineSplit = line.trim().split('#xywh=');\n                [result.text] = lineSplit;\n                // If there's content in lineSplit[1], then we have sprites. If not, then it's just one frame per image\n                if (lineSplit[1]) {\n                    [result.x, result.y, result.w, result.h] = lineSplit[1].split(',');\n                }\n            }\n        });\n        if (result.text) {\n            processedList.push(result);\n        }\n    });\n    return processedList;\n}\n/**\n * Preview thumbnails for seek hover and scrubbing\n * Seeking: Hover over the seek bar (desktop only): shows a small preview container above the seek bar\n * Scrubbing: Click and drag the seek bar (desktop and mobile): shows the preview image over the entire video, as if the video is scrubbing at very high speed\n *\n * Notes:\n * - Thumbs are set via JS settings on Plyr init, not HTML5 'track' property. Using the track property would be a bit gross, because it doesn't support custom 'kinds'. kind=metadata might be used for something else, and we want to allow multiple thumbnails tracks. Tracks must have a unique combination of 'kind' and 'label'. We would have to do something like kind=metadata,label=thumbnails1 / kind=metadata,label=thumbnails2. Square peg, round hole\n * - VTT info: the image URL is relative to the VTT, not the current document. But if the url starts with a slash, it will naturally be relative to the current domain. https://support.jwplayer.com/articles/how-to-add-preview-thumbnails\n * - This implementation uses multiple separate img elements. Other implementations use background-image on one element. This would be nice and simple, but Firefox and Safari have flickering issues with replacing backgrounds of larger images. It seems that YouTube perhaps only avoids this because they don't have the option for high-res previews (even the fullscreen ones, when mousedown/seeking). Images appear over the top of each other, and previous ones are discarded once the new ones have been rendered\n */ function fitRatio(ratio, outer) {\n    const targetRatio = outer.width / outer.height;\n    const result = {};\n    if (ratio > targetRatio) {\n        result.width = outer.width;\n        result.height = 1 / ratio * outer.width;\n    } else {\n        result.height = outer.height;\n        result.width = ratio * outer.height;\n    }\n    return result;\n}\nclass PreviewThumbnails {\n    /**\n   * PreviewThumbnails constructor.\n   * @param {Plyr} player\n   * @return {PreviewThumbnails}\n   */ constructor(player){\n        _defineProperty$1(this, \"load\", ()=>{\n            // Toggle the regular seek tooltip\n            if (this.player.elements.display.seekTooltip) {\n                this.player.elements.display.seekTooltip.hidden = this.enabled;\n            }\n            if (!this.enabled) return;\n            this.getThumbnails().then(()=>{\n                if (!this.enabled) {\n                    return;\n                }\n                // Render DOM elements\n                this.render();\n                // Check to see if thumb container size was specified manually in CSS\n                this.determineContainerAutoSizing();\n                // Set up listeners\n                this.listeners();\n                this.loaded = true;\n            });\n        });\n        // Download VTT files and parse them\n        _defineProperty$1(this, \"getThumbnails\", ()=>{\n            return new Promise((resolve)=>{\n                const { src } = this.player.config.previewThumbnails;\n                if (is.empty(src)) {\n                    throw new Error('Missing previewThumbnails.src config attribute');\n                }\n                // Resolve promise\n                const sortAndResolve = ()=>{\n                    // Sort smallest to biggest (e.g., [120p, 480p, 1080p])\n                    this.thumbnails.sort((x, y)=>x.height - y.height);\n                    this.player.debug.log('Preview thumbnails', this.thumbnails);\n                    resolve();\n                };\n                // Via callback()\n                if (is.function(src)) {\n                    src((thumbnails)=>{\n                        this.thumbnails = thumbnails;\n                        sortAndResolve();\n                    });\n                } else {\n                    // If string, convert into single-element list\n                    const urls = is.string(src) ? [\n                        src\n                    ] : src;\n                    // Loop through each src URL. Download and process the VTT file, storing the resulting data in this.thumbnails\n                    const promises = urls.map((u)=>this.getThumbnail(u));\n                    // Resolve\n                    Promise.all(promises).then(sortAndResolve);\n                }\n            });\n        });\n        // Process individual VTT file\n        _defineProperty$1(this, \"getThumbnail\", (url)=>{\n            return new Promise((resolve)=>{\n                fetch(url, undefined, this.player.config.previewThumbnails.withCredentials).then((response)=>{\n                    const thumbnail = {\n                        frames: parseVtt(response),\n                        height: null,\n                        urlPrefix: ''\n                    };\n                    // If the URLs don't start with '/', then we need to set their relative path to be the location of the VTT file\n                    // If the URLs do start with '/', then they obviously don't need a prefix, so it will remain blank\n                    // If the thumbnail URLs start with with none of '/', 'http://' or 'https://', then we need to set their relative path to be the location of the VTT file\n                    if (!thumbnail.frames[0].text.startsWith('/') && !thumbnail.frames[0].text.startsWith('http://') && !thumbnail.frames[0].text.startsWith('https://')) {\n                        thumbnail.urlPrefix = url.substring(0, url.lastIndexOf('/') + 1);\n                    }\n                    // Download the first frame, so that we can determine/set the height of this thumbnailsDef\n                    const tempImage = new Image();\n                    tempImage.onload = ()=>{\n                        thumbnail.height = tempImage.naturalHeight;\n                        thumbnail.width = tempImage.naturalWidth;\n                        this.thumbnails.push(thumbnail);\n                        resolve();\n                    };\n                    tempImage.src = thumbnail.urlPrefix + thumbnail.frames[0].text;\n                });\n            });\n        });\n        _defineProperty$1(this, \"startMove\", (event)=>{\n            if (!this.loaded) return;\n            if (!is.event(event) || ![\n                'touchmove',\n                'mousemove'\n            ].includes(event.type)) return;\n            // Wait until media has a duration\n            if (!this.player.media.duration) return;\n            if (event.type === 'touchmove') {\n                // Calculate seek hover position as approx video seconds\n                this.seekTime = this.player.media.duration * (this.player.elements.inputs.seek.value / 100);\n            } else {\n                var _this$player$config$m, _this$player$config$m2;\n                // Calculate seek hover position as approx video seconds\n                const clientRect = this.player.elements.progress.getBoundingClientRect();\n                const percentage = 100 / clientRect.width * (event.pageX - clientRect.left);\n                this.seekTime = this.player.media.duration * (percentage / 100);\n                if (this.seekTime < 0) {\n                    // The mousemove fires for 10+px out to the left\n                    this.seekTime = 0;\n                }\n                if (this.seekTime > this.player.media.duration - 1) {\n                    // Took 1 second off the duration for safety, because different players can disagree on the real duration of a video\n                    this.seekTime = this.player.media.duration - 1;\n                }\n                this.mousePosX = event.pageX;\n                // Set time text inside image container\n                this.elements.thumb.time.textContent = formatTime(this.seekTime);\n                // Get marker point for time\n                const point = (_this$player$config$m = this.player.config.markers) === null || _this$player$config$m === void 0 ? void 0 : (_this$player$config$m2 = _this$player$config$m.points) === null || _this$player$config$m2 === void 0 ? void 0 : _this$player$config$m2.find(({ time: t })=>t === Math.round(this.seekTime));\n                // Append the point label to the tooltip\n                if (point) {\n                    // this.elements.thumb.time.innerText.concat('\\n');\n                    this.elements.thumb.time.insertAdjacentHTML('afterbegin', `${point.label}<br>`);\n                }\n            }\n            // Download and show image\n            this.showImageAtCurrentTime();\n        });\n        _defineProperty$1(this, \"endMove\", ()=>{\n            this.toggleThumbContainer(false, true);\n        });\n        _defineProperty$1(this, \"startScrubbing\", (event)=>{\n            // Only act on left mouse button (0), or touch device (event.button does not exist or is false)\n            if (is.nullOrUndefined(event.button) || event.button === false || event.button === 0) {\n                this.mouseDown = true;\n                // Wait until media has a duration\n                if (this.player.media.duration) {\n                    this.toggleScrubbingContainer(true);\n                    this.toggleThumbContainer(false, true);\n                    // Download and show image\n                    this.showImageAtCurrentTime();\n                }\n            }\n        });\n        _defineProperty$1(this, \"endScrubbing\", ()=>{\n            this.mouseDown = false;\n            // Hide scrubbing preview. But wait until the video has successfully seeked before hiding the scrubbing preview\n            if (Math.ceil(this.lastTime) === Math.ceil(this.player.media.currentTime)) {\n                // The video was already seeked/loaded at the chosen time - hide immediately\n                this.toggleScrubbingContainer(false);\n            } else {\n                // The video hasn't seeked yet. Wait for that\n                once.call(this.player, this.player.media, 'timeupdate', ()=>{\n                    // Re-check mousedown - we might have already started scrubbing again\n                    if (!this.mouseDown) {\n                        this.toggleScrubbingContainer(false);\n                    }\n                });\n            }\n        });\n        /**\n     * Setup hooks for Plyr and window events\n     */ _defineProperty$1(this, \"listeners\", ()=>{\n            // Hide thumbnail preview - on mouse click, mouse leave (in listeners.js for now), and video play/seek. All four are required, e.g., for buffering\n            this.player.on('play', ()=>{\n                this.toggleThumbContainer(false, true);\n            });\n            this.player.on('seeked', ()=>{\n                this.toggleThumbContainer(false);\n            });\n            this.player.on('timeupdate', ()=>{\n                this.lastTime = this.player.media.currentTime;\n            });\n        });\n        /**\n     * Create HTML elements for image containers\n     */ _defineProperty$1(this, \"render\", ()=>{\n            // Create HTML element: plyr__preview-thumbnail-container\n            this.elements.thumb.container = createElement('div', {\n                class: this.player.config.classNames.previewThumbnails.thumbContainer\n            });\n            // Wrapper for the image for styling\n            this.elements.thumb.imageContainer = createElement('div', {\n                class: this.player.config.classNames.previewThumbnails.imageContainer\n            });\n            this.elements.thumb.container.appendChild(this.elements.thumb.imageContainer);\n            // Create HTML element, parent+span: time text (e.g., 01:32:00)\n            const timeContainer = createElement('div', {\n                class: this.player.config.classNames.previewThumbnails.timeContainer\n            });\n            this.elements.thumb.time = createElement('span', {}, '00:00');\n            timeContainer.appendChild(this.elements.thumb.time);\n            this.elements.thumb.imageContainer.appendChild(timeContainer);\n            // Inject the whole thumb\n            if (is.element(this.player.elements.progress)) {\n                this.player.elements.progress.appendChild(this.elements.thumb.container);\n            }\n            // Create HTML element: plyr__preview-scrubbing-container\n            this.elements.scrubbing.container = createElement('div', {\n                class: this.player.config.classNames.previewThumbnails.scrubbingContainer\n            });\n            this.player.elements.wrapper.appendChild(this.elements.scrubbing.container);\n        });\n        _defineProperty$1(this, \"destroy\", ()=>{\n            if (this.elements.thumb.container) {\n                this.elements.thumb.container.remove();\n            }\n            if (this.elements.scrubbing.container) {\n                this.elements.scrubbing.container.remove();\n            }\n        });\n        _defineProperty$1(this, \"showImageAtCurrentTime\", ()=>{\n            if (this.mouseDown) {\n                this.setScrubbingContainerSize();\n            } else {\n                this.setThumbContainerSizeAndPos();\n            }\n            // Find the desired thumbnail index\n            // TODO: Handle a video longer than the thumbs where thumbNum is null\n            const thumbNum = this.thumbnails[0].frames.findIndex((frame)=>this.seekTime >= frame.startTime && this.seekTime <= frame.endTime);\n            const hasThumb = thumbNum >= 0;\n            let qualityIndex = 0;\n            // Show the thumb container if we're not scrubbing\n            if (!this.mouseDown) {\n                this.toggleThumbContainer(hasThumb);\n            }\n            // No matching thumb found\n            if (!hasThumb) {\n                return;\n            }\n            // Check to see if we've already downloaded higher quality versions of this image\n            this.thumbnails.forEach((thumbnail, index)=>{\n                if (this.loadedImages.includes(thumbnail.frames[thumbNum].text)) {\n                    qualityIndex = index;\n                }\n            });\n            // Only proceed if either thumb num or thumbfilename has changed\n            if (thumbNum !== this.showingThumb) {\n                this.showingThumb = thumbNum;\n                this.loadImage(qualityIndex);\n            }\n        });\n        // Show the image that's currently specified in this.showingThumb\n        _defineProperty$1(this, \"loadImage\", (qualityIndex = 0)=>{\n            const thumbNum = this.showingThumb;\n            const thumbnail = this.thumbnails[qualityIndex];\n            const { urlPrefix } = thumbnail;\n            const frame = thumbnail.frames[thumbNum];\n            const thumbFilename = thumbnail.frames[thumbNum].text;\n            const thumbUrl = urlPrefix + thumbFilename;\n            if (!this.currentImageElement || this.currentImageElement.dataset.filename !== thumbFilename) {\n                // If we're already loading a previous image, remove its onload handler - we don't want it to load after this one\n                // Only do this if not using sprites. Without sprites we really want to show as many images as possible, as a best-effort\n                if (this.loadingImage && this.usingSprites) {\n                    this.loadingImage.onload = null;\n                }\n                // We're building and adding a new image. In other implementations of similar functionality (YouTube), background image\n                // is instead used. But this causes issues with larger images in Firefox and Safari - switching between background\n                // images causes a flicker. Putting a new image over the top does not\n                const previewImage = new Image();\n                previewImage.src = thumbUrl;\n                previewImage.dataset.index = thumbNum;\n                previewImage.dataset.filename = thumbFilename;\n                this.showingThumbFilename = thumbFilename;\n                this.player.debug.log(`Loading image: ${thumbUrl}`);\n                // For some reason, passing the named function directly causes it to execute immediately. So I've wrapped it in an anonymous function...\n                previewImage.onload = ()=>this.showImage(previewImage, frame, qualityIndex, thumbNum, thumbFilename, true);\n                this.loadingImage = previewImage;\n                this.removeOldImages(previewImage);\n            } else {\n                // Update the existing image\n                this.showImage(this.currentImageElement, frame, qualityIndex, thumbNum, thumbFilename, false);\n                this.currentImageElement.dataset.index = thumbNum;\n                this.removeOldImages(this.currentImageElement);\n            }\n        });\n        _defineProperty$1(this, \"showImage\", (previewImage, frame, qualityIndex, thumbNum, thumbFilename, newImage = true)=>{\n            this.player.debug.log(`Showing thumb: ${thumbFilename}. num: ${thumbNum}. qual: ${qualityIndex}. newimg: ${newImage}`);\n            this.setImageSizeAndOffset(previewImage, frame);\n            if (newImage) {\n                this.currentImageContainer.appendChild(previewImage);\n                this.currentImageElement = previewImage;\n                if (!this.loadedImages.includes(thumbFilename)) {\n                    this.loadedImages.push(thumbFilename);\n                }\n            }\n            // Preload images before and after the current one\n            // Show higher quality of the same frame\n            // Each step here has a short time delay, and only continues if still hovering/seeking the same spot. This is to protect slow connections from overloading\n            this.preloadNearby(thumbNum, true).then(this.preloadNearby(thumbNum, false)).then(this.getHigherQuality(qualityIndex, previewImage, frame, thumbFilename));\n        });\n        // Remove all preview images that aren't the designated current image\n        _defineProperty$1(this, \"removeOldImages\", (currentImage)=>{\n            // Get a list of all images, convert it from a DOM list to an array\n            Array.from(this.currentImageContainer.children).forEach((image)=>{\n                if (image.tagName.toLowerCase() !== 'img') {\n                    return;\n                }\n                const removeDelay = this.usingSprites ? 500 : 1000;\n                if (image.dataset.index !== currentImage.dataset.index && !image.dataset.deleting) {\n                    // Wait 200ms, as the new image can take some time to show on certain browsers (even though it was downloaded before showing). This will prevent flicker, and show some generosity towards slower clients\n                    // First set attribute 'deleting' to prevent multi-handling of this on repeat firing of this function\n                    image.dataset.deleting = true;\n                    // This has to be set before the timeout - to prevent issues switching between hover and scrub\n                    const { currentImageContainer } = this;\n                    setTimeout(()=>{\n                        currentImageContainer.removeChild(image);\n                        this.player.debug.log(`Removing thumb: ${image.dataset.filename}`);\n                    }, removeDelay);\n                }\n            });\n        });\n        // Preload images before and after the current one. Only if the user is still hovering/seeking the same frame\n        // This will only preload the lowest quality\n        _defineProperty$1(this, \"preloadNearby\", (thumbNum, forward = true)=>{\n            return new Promise((resolve)=>{\n                setTimeout(()=>{\n                    const oldThumbFilename = this.thumbnails[0].frames[thumbNum].text;\n                    if (this.showingThumbFilename === oldThumbFilename) {\n                        // Find the nearest thumbs with different filenames. Sometimes it'll be the next index, but in the case of sprites, it might be 100+ away\n                        let thumbnailsClone;\n                        if (forward) {\n                            thumbnailsClone = this.thumbnails[0].frames.slice(thumbNum);\n                        } else {\n                            thumbnailsClone = this.thumbnails[0].frames.slice(0, thumbNum).reverse();\n                        }\n                        let foundOne = false;\n                        thumbnailsClone.forEach((frame)=>{\n                            const newThumbFilename = frame.text;\n                            if (newThumbFilename !== oldThumbFilename) {\n                                // Found one with a different filename. Make sure it hasn't already been loaded on this page visit\n                                if (!this.loadedImages.includes(newThumbFilename)) {\n                                    foundOne = true;\n                                    this.player.debug.log(`Preloading thumb filename: ${newThumbFilename}`);\n                                    const { urlPrefix } = this.thumbnails[0];\n                                    const thumbURL = urlPrefix + newThumbFilename;\n                                    const previewImage = new Image();\n                                    previewImage.src = thumbURL;\n                                    previewImage.onload = ()=>{\n                                        this.player.debug.log(`Preloaded thumb filename: ${newThumbFilename}`);\n                                        if (!this.loadedImages.includes(newThumbFilename)) this.loadedImages.push(newThumbFilename);\n                                        // We don't resolve until the thumb is loaded\n                                        resolve();\n                                    };\n                                }\n                            }\n                        });\n                        // If there are none to preload then we want to resolve immediately\n                        if (!foundOne) {\n                            resolve();\n                        }\n                    }\n                }, 300);\n            });\n        });\n        // If user has been hovering current image for half a second, look for a higher quality one\n        _defineProperty$1(this, \"getHigherQuality\", (currentQualityIndex, previewImage, frame, thumbFilename)=>{\n            if (currentQualityIndex < this.thumbnails.length - 1) {\n                // Only use the higher quality version if it's going to look any better - if the current thumb is of a lower pixel density than the thumbnail container\n                let previewImageHeight = previewImage.naturalHeight;\n                if (this.usingSprites) {\n                    previewImageHeight = frame.h;\n                }\n                if (previewImageHeight < this.thumbContainerHeight) {\n                    // Recurse back to the loadImage function - show a higher quality one, but only if the viewer is on this frame for a while\n                    setTimeout(()=>{\n                        // Make sure the mouse hasn't already moved on and started hovering at another image\n                        if (this.showingThumbFilename === thumbFilename) {\n                            this.player.debug.log(`Showing higher quality thumb for: ${thumbFilename}`);\n                            this.loadImage(currentQualityIndex + 1);\n                        }\n                    }, 300);\n                }\n            }\n        });\n        _defineProperty$1(this, \"toggleThumbContainer\", (toggle = false, clearShowing = false)=>{\n            const className = this.player.config.classNames.previewThumbnails.thumbContainerShown;\n            this.elements.thumb.container.classList.toggle(className, toggle);\n            if (!toggle && clearShowing) {\n                this.showingThumb = null;\n                this.showingThumbFilename = null;\n            }\n        });\n        _defineProperty$1(this, \"toggleScrubbingContainer\", (toggle = false)=>{\n            const className = this.player.config.classNames.previewThumbnails.scrubbingContainerShown;\n            this.elements.scrubbing.container.classList.toggle(className, toggle);\n            if (!toggle) {\n                this.showingThumb = null;\n                this.showingThumbFilename = null;\n            }\n        });\n        _defineProperty$1(this, \"determineContainerAutoSizing\", ()=>{\n            if (this.elements.thumb.imageContainer.clientHeight > 20 || this.elements.thumb.imageContainer.clientWidth > 20) {\n                // This will prevent auto sizing in this.setThumbContainerSizeAndPos()\n                this.sizeSpecifiedInCSS = true;\n            }\n        });\n        // Set the size to be about a quarter of the size of video. Unless option dynamicSize === false, in which case it needs to be set in CSS\n        _defineProperty$1(this, \"setThumbContainerSizeAndPos\", ()=>{\n            const { imageContainer } = this.elements.thumb;\n            if (!this.sizeSpecifiedInCSS) {\n                const thumbWidth = Math.floor(this.thumbContainerHeight * this.thumbAspectRatio);\n                imageContainer.style.height = `${this.thumbContainerHeight}px`;\n                imageContainer.style.width = `${thumbWidth}px`;\n            } else if (imageContainer.clientHeight > 20 && imageContainer.clientWidth < 20) {\n                const thumbWidth = Math.floor(imageContainer.clientHeight * this.thumbAspectRatio);\n                imageContainer.style.width = `${thumbWidth}px`;\n            } else if (imageContainer.clientHeight < 20 && imageContainer.clientWidth > 20) {\n                const thumbHeight = Math.floor(imageContainer.clientWidth / this.thumbAspectRatio);\n                imageContainer.style.height = `${thumbHeight}px`;\n            }\n            this.setThumbContainerPos();\n        });\n        _defineProperty$1(this, \"setThumbContainerPos\", ()=>{\n            const scrubberRect = this.player.elements.progress.getBoundingClientRect();\n            const containerRect = this.player.elements.container.getBoundingClientRect();\n            const { container } = this.elements.thumb;\n            // Find the lowest and highest desired left-position, so we don't slide out the side of the video container\n            const min = containerRect.left - scrubberRect.left + 10;\n            const max = containerRect.right - scrubberRect.left - container.clientWidth - 10;\n            // Set preview container position to: mousepos, minus seekbar.left, minus half of previewContainer.clientWidth\n            const position = this.mousePosX - scrubberRect.left - container.clientWidth / 2;\n            const clamped = clamp(position, min, max);\n            // Move the popover position\n            container.style.left = `${clamped}px`;\n            // The arrow can follow the cursor\n            container.style.setProperty('--preview-arrow-offset', `${position - clamped}px`);\n        });\n        // Can't use 100% width, in case the video is a different aspect ratio to the video container\n        _defineProperty$1(this, \"setScrubbingContainerSize\", ()=>{\n            const { width, height } = fitRatio(this.thumbAspectRatio, {\n                width: this.player.media.clientWidth,\n                height: this.player.media.clientHeight\n            });\n            this.elements.scrubbing.container.style.width = `${width}px`;\n            this.elements.scrubbing.container.style.height = `${height}px`;\n        });\n        // Sprites need to be offset to the correct location\n        _defineProperty$1(this, \"setImageSizeAndOffset\", (previewImage, frame)=>{\n            if (!this.usingSprites) return;\n            // Find difference between height and preview container height\n            const multiplier = this.thumbContainerHeight / frame.h;\n            previewImage.style.height = `${previewImage.naturalHeight * multiplier}px`;\n            previewImage.style.width = `${previewImage.naturalWidth * multiplier}px`;\n            previewImage.style.left = `-${frame.x * multiplier}px`;\n            previewImage.style.top = `-${frame.y * multiplier}px`;\n        });\n        this.player = player;\n        this.thumbnails = [];\n        this.loaded = false;\n        this.lastMouseMoveTime = Date.now();\n        this.mouseDown = false;\n        this.loadedImages = [];\n        this.elements = {\n            thumb: {},\n            scrubbing: {}\n        };\n        this.load();\n    }\n    get enabled() {\n        return this.player.isHTML5 && this.player.isVideo && this.player.config.previewThumbnails.enabled;\n    }\n    get currentImageContainer() {\n        return this.mouseDown ? this.elements.scrubbing.container : this.elements.thumb.imageContainer;\n    }\n    get usingSprites() {\n        return Object.keys(this.thumbnails[0].frames[0]).includes('w');\n    }\n    get thumbAspectRatio() {\n        if (this.usingSprites) {\n            return this.thumbnails[0].frames[0].w / this.thumbnails[0].frames[0].h;\n        }\n        return this.thumbnails[0].width / this.thumbnails[0].height;\n    }\n    get thumbContainerHeight() {\n        if (this.mouseDown) {\n            const { height } = fitRatio(this.thumbAspectRatio, {\n                width: this.player.media.clientWidth,\n                height: this.player.media.clientHeight\n            });\n            return height;\n        }\n        // If css is used this needs to return the css height for sprites to work (see setImageSizeAndOffset)\n        if (this.sizeSpecifiedInCSS) {\n            return this.elements.thumb.imageContainer.clientHeight;\n        }\n        return Math.floor(this.player.media.clientWidth / this.thumbAspectRatio / 4);\n    }\n    get currentImageElement() {\n        return this.mouseDown ? this.currentScrubbingImageElement : this.currentThumbnailImageElement;\n    }\n    set currentImageElement(element) {\n        if (this.mouseDown) {\n            this.currentScrubbingImageElement = element;\n        } else {\n            this.currentThumbnailImageElement = element;\n        }\n    }\n}\n// ==========================================================================\n// Plyr source update\n// ==========================================================================\nconst source = {\n    // Add elements to HTML5 media (source, tracks, etc)\n    insertElements (type, attributes) {\n        if (is.string(attributes)) {\n            insertElement(type, this.media, {\n                src: attributes\n            });\n        } else if (is.array(attributes)) {\n            attributes.forEach((attribute)=>{\n                insertElement(type, this.media, attribute);\n            });\n        }\n    },\n    // Update source\n    // Sources are not checked for support so be careful\n    change (input) {\n        if (!getDeep(input, 'sources.length')) {\n            this.debug.warn('Invalid source format');\n            return;\n        }\n        // Cancel current network requests\n        html5.cancelRequests.call(this);\n        // Destroy instance and re-setup\n        this.destroy(()=>{\n            // Reset quality options\n            this.options.quality = [];\n            // Remove elements\n            removeElement(this.media);\n            this.media = null;\n            // Reset class name\n            if (is.element(this.elements.container)) {\n                this.elements.container.removeAttribute('class');\n            }\n            // Set the type and provider\n            const { sources, type } = input;\n            const [{ provider = providers.html5, src }] = sources;\n            const tagName = provider === 'html5' ? type : 'div';\n            const attributes = provider === 'html5' ? {} : {\n                src\n            };\n            Object.assign(this, {\n                provider,\n                type,\n                // Check for support\n                supported: support.check(type, provider, this.config.playsinline),\n                // Create new element\n                media: createElement(tagName, attributes)\n            });\n            // Inject the new element\n            this.elements.container.appendChild(this.media);\n            // Autoplay the new source?\n            if (is.boolean(input.autoplay)) {\n                this.config.autoplay = input.autoplay;\n            }\n            // Set attributes for audio and video\n            if (this.isHTML5) {\n                if (this.config.crossorigin) {\n                    this.media.setAttribute('crossorigin', '');\n                }\n                if (this.config.autoplay) {\n                    this.media.setAttribute('autoplay', '');\n                }\n                if (!is.empty(input.poster)) {\n                    this.poster = input.poster;\n                }\n                if (this.config.loop.active) {\n                    this.media.setAttribute('loop', '');\n                }\n                if (this.config.muted) {\n                    this.media.setAttribute('muted', '');\n                }\n                if (this.config.playsinline) {\n                    this.media.setAttribute('playsinline', '');\n                }\n            }\n            // Restore class hook\n            ui.addStyleHook.call(this);\n            // Set new sources for html5\n            if (this.isHTML5) {\n                source.insertElements.call(this, 'source', sources);\n            }\n            // Set video title\n            this.config.title = input.title;\n            // Set up from scratch\n            media.setup.call(this);\n            // HTML5 stuff\n            if (this.isHTML5) {\n                // Setup captions\n                if (Object.keys(input).includes('tracks')) {\n                    source.insertElements.call(this, 'track', input.tracks);\n                }\n            }\n            // If HTML5 or embed but not fully supported, setupInterface and call ready now\n            if (this.isHTML5 || this.isEmbed && !this.supported.ui) {\n                // Setup interface\n                ui.build.call(this);\n            }\n            // Load HTML5 sources\n            if (this.isHTML5) {\n                this.media.load();\n            }\n            // Update previewThumbnails config & reload plugin\n            if (!is.empty(input.previewThumbnails)) {\n                Object.assign(this.config.previewThumbnails, input.previewThumbnails);\n                // Cleanup previewThumbnails plugin if it was loaded\n                if (this.previewThumbnails && this.previewThumbnails.loaded) {\n                    this.previewThumbnails.destroy();\n                    this.previewThumbnails = null;\n                }\n                // Create new instance if it is still enabled\n                if (this.config.previewThumbnails.enabled) {\n                    this.previewThumbnails = new PreviewThumbnails(this);\n                }\n            }\n            // Update the fullscreen support\n            this.fullscreen.update();\n        }, true);\n    }\n};\n// Private properties\n// TODO: Use a WeakMap for private globals\n// const globals = new WeakMap();\n// Plyr instance\nclass Plyr {\n    constructor(target, options){\n        /**\n     * Play the media, or play the advertisement (if they are not blocked)\n     */ _defineProperty$1(this, \"play\", ()=>{\n            if (!is.function(this.media.play)) {\n                return null;\n            }\n            // Intecept play with ads\n            if (this.ads && this.ads.enabled) {\n                this.ads.managerPromise.then(()=>this.ads.play()).catch(()=>silencePromise(this.media.play()));\n            }\n            // Return the promise (for HTML5)\n            return this.media.play();\n        });\n        /**\n     * Pause the media\n     */ _defineProperty$1(this, \"pause\", ()=>{\n            if (!this.playing || !is.function(this.media.pause)) {\n                return null;\n            }\n            return this.media.pause();\n        });\n        /**\n     * Toggle playback based on current status\n     * @param {boolean} input\n     */ _defineProperty$1(this, \"togglePlay\", (input)=>{\n            // Toggle based on current state if nothing passed\n            const toggle = is.boolean(input) ? input : !this.playing;\n            if (toggle) {\n                return this.play();\n            }\n            return this.pause();\n        });\n        /**\n     * Stop playback\n     */ _defineProperty$1(this, \"stop\", ()=>{\n            if (this.isHTML5) {\n                this.pause();\n                this.restart();\n            } else if (is.function(this.media.stop)) {\n                this.media.stop();\n            }\n        });\n        /**\n     * Restart playback\n     */ _defineProperty$1(this, \"restart\", ()=>{\n            this.currentTime = 0;\n        });\n        /**\n     * Rewind\n     * @param {number} seekTime - how far to rewind in seconds. Defaults to the config.seekTime\n     */ _defineProperty$1(this, \"rewind\", (seekTime)=>{\n            this.currentTime -= is.number(seekTime) ? seekTime : this.config.seekTime;\n        });\n        /**\n     * Fast forward\n     * @param {number} seekTime - how far to fast forward in seconds. Defaults to the config.seekTime\n     */ _defineProperty$1(this, \"forward\", (seekTime)=>{\n            this.currentTime += is.number(seekTime) ? seekTime : this.config.seekTime;\n        });\n        /**\n     * Increase volume\n     * @param {boolean} step - How much to decrease by (between 0 and 1)\n     */ _defineProperty$1(this, \"increaseVolume\", (step)=>{\n            const volume = this.media.muted ? 0 : this.volume;\n            this.volume = volume + (is.number(step) ? step : 0);\n        });\n        /**\n     * Decrease volume\n     * @param {boolean} step - How much to decrease by (between 0 and 1)\n     */ _defineProperty$1(this, \"decreaseVolume\", (step)=>{\n            this.increaseVolume(-step);\n        });\n        /**\n     * Trigger the airplay dialog\n     * TODO: update player with state, support, enabled\n     */ _defineProperty$1(this, \"airplay\", ()=>{\n            // Show dialog if supported\n            if (support.airplay) {\n                this.media.webkitShowPlaybackTargetPicker();\n            }\n        });\n        /**\n     * Toggle the player controls\n     * @param {boolean} [toggle] - Whether to show the controls\n     */ _defineProperty$1(this, \"toggleControls\", (toggle)=>{\n            // Don't toggle if missing UI support or if it's audio\n            if (this.supported.ui && !this.isAudio) {\n                // Get state before change\n                const isHidden = hasClass(this.elements.container, this.config.classNames.hideControls);\n                // Negate the argument if not undefined since adding the class to hides the controls\n                const force = typeof toggle === 'undefined' ? undefined : !toggle;\n                // Apply and get updated state\n                const hiding = toggleClass(this.elements.container, this.config.classNames.hideControls, force);\n                // Close menu\n                if (hiding && is.array(this.config.controls) && this.config.controls.includes('settings') && !is.empty(this.config.settings)) {\n                    controls.toggleMenu.call(this, false);\n                }\n                // Trigger event on change\n                if (hiding !== isHidden) {\n                    const eventName = hiding ? 'controlshidden' : 'controlsshown';\n                    triggerEvent.call(this, this.media, eventName);\n                }\n                return !hiding;\n            }\n            return false;\n        });\n        /**\n     * Add event listeners\n     * @param {string} event - Event type\n     * @param {Function} callback - Callback for when event occurs\n     */ _defineProperty$1(this, \"on\", (event, callback)=>{\n            on.call(this, this.elements.container, event, callback);\n        });\n        /**\n     * Add event listeners once\n     * @param {string} event - Event type\n     * @param {Function} callback - Callback for when event occurs\n     */ _defineProperty$1(this, \"once\", (event, callback)=>{\n            once.call(this, this.elements.container, event, callback);\n        });\n        /**\n     * Remove event listeners\n     * @param {string} event - Event type\n     * @param {Function} callback - Callback for when event occurs\n     */ _defineProperty$1(this, \"off\", (event, callback)=>{\n            off(this.elements.container, event, callback);\n        });\n        /**\n     * Destroy an instance\n     * Event listeners are removed when elements are removed\n     * http://stackoverflow.com/questions/12528049/if-a-dom-element-is-removed-are-its-listeners-also-removed-from-memory\n     * @param {Function} callback - Callback for when destroy is complete\n     * @param {boolean} soft - Whether it's a soft destroy (for source changes etc)\n     */ _defineProperty$1(this, \"destroy\", (callback, soft = false)=>{\n            if (!this.ready) {\n                return;\n            }\n            const done = ()=>{\n                // Reset overflow (incase destroyed while in fullscreen)\n                document.body.style.overflow = '';\n                // GC for embed\n                this.embed = null;\n                // If it's a soft destroy, make minimal changes\n                if (soft) {\n                    if (Object.keys(this.elements).length) {\n                        // Remove elements\n                        removeElement(this.elements.buttons.play);\n                        removeElement(this.elements.captions);\n                        removeElement(this.elements.controls);\n                        removeElement(this.elements.wrapper);\n                        // Clear for GC\n                        this.elements.buttons.play = null;\n                        this.elements.captions = null;\n                        this.elements.controls = null;\n                        this.elements.wrapper = null;\n                    }\n                    // Callback\n                    if (is.function(callback)) {\n                        callback();\n                    }\n                } else {\n                    // Unbind listeners\n                    unbindListeners.call(this);\n                    // Cancel current network requests\n                    html5.cancelRequests.call(this);\n                    // Replace the container with the original element provided\n                    replaceElement(this.elements.original, this.elements.container);\n                    // Event\n                    triggerEvent.call(this, this.elements.original, 'destroyed', true);\n                    // Callback\n                    if (is.function(callback)) {\n                        callback.call(this.elements.original);\n                    }\n                    // Reset state\n                    this.ready = false;\n                    // Clear for garbage collection\n                    setTimeout(()=>{\n                        this.elements = null;\n                        this.media = null;\n                    }, 200);\n                }\n            };\n            // Stop playback\n            this.stop();\n            // Clear timeouts\n            clearTimeout(this.timers.loading);\n            clearTimeout(this.timers.controls);\n            clearTimeout(this.timers.resized);\n            // Provider specific stuff\n            if (this.isHTML5) {\n                // Restore native video controls\n                ui.toggleNativeControls.call(this, true);\n                // Clean up\n                done();\n            } else if (this.isYouTube) {\n                // Clear timers\n                clearInterval(this.timers.buffering);\n                clearInterval(this.timers.playing);\n                // Destroy YouTube API\n                if (this.embed !== null && is.function(this.embed.destroy)) {\n                    this.embed.destroy();\n                }\n                // Clean up\n                done();\n            } else if (this.isVimeo) {\n                // Destroy Vimeo API\n                // then clean up (wait, to prevent postmessage errors)\n                if (this.embed !== null) {\n                    this.embed.unload().then(done);\n                }\n                // Vimeo does not always return\n                setTimeout(done, 200);\n            }\n        });\n        /**\n     * Check for support for a mime type (HTML5 only)\n     * @param {string} type - Mime type\n     */ _defineProperty$1(this, \"supports\", (type)=>support.mime.call(this, type));\n        this.timers = {};\n        // State\n        this.ready = false;\n        this.loading = false;\n        this.failed = false;\n        // Touch device\n        this.touch = support.touch;\n        // Set the media element\n        this.media = target;\n        // String selector passed\n        if (is.string(this.media)) {\n            this.media = document.querySelectorAll(this.media);\n        }\n        // jQuery, NodeList or Array passed, use first element\n        if (window.jQuery && this.media instanceof jQuery || is.nodeList(this.media) || is.array(this.media)) {\n            this.media = this.media[0];\n        }\n        // Set config\n        this.config = extend({}, defaults, Plyr.defaults, options || {}, (()=>{\n            try {\n                return JSON.parse(this.media.getAttribute('data-plyr-config'));\n            } catch  {\n                return {};\n            }\n        })());\n        // Elements cache\n        this.elements = {\n            container: null,\n            fullscreen: null,\n            captions: null,\n            buttons: {},\n            display: {},\n            progress: {},\n            inputs: {},\n            settings: {\n                popup: null,\n                menu: null,\n                panels: {},\n                buttons: {}\n            }\n        };\n        // Captions\n        this.captions = {\n            active: null,\n            currentTrack: -1,\n            meta: new WeakMap()\n        };\n        // Fullscreen\n        this.fullscreen = {\n            active: false\n        };\n        // Options\n        this.options = {\n            speed: [],\n            quality: []\n        };\n        // Debugging\n        // TODO: move to globals\n        this.debug = new Console(this.config.debug);\n        // Log config options and support\n        this.debug.log('Config', this.config);\n        this.debug.log('Support', support);\n        // We need an element to setup\n        if (is.nullOrUndefined(this.media) || !is.element(this.media)) {\n            this.debug.error('Setup failed: no suitable element passed');\n            return;\n        }\n        // Bail if the element is initialized\n        if (this.media.plyr) {\n            this.debug.warn('Target already setup');\n            return;\n        }\n        // Bail if not enabled\n        if (!this.config.enabled) {\n            this.debug.error('Setup failed: disabled by config');\n            return;\n        }\n        // Bail if disabled or no basic support\n        // You may want to disable certain UAs etc\n        if (!support.check().api) {\n            this.debug.error('Setup failed: no support');\n            return;\n        }\n        // Cache original element state for .destroy()\n        const clone = this.media.cloneNode(true);\n        clone.autoplay = false;\n        this.elements.original = clone;\n        // Set media type based on tag or data attribute\n        // Supported: video, audio, vimeo, youtube\n        const _type = this.media.tagName.toLowerCase();\n        // Embed properties\n        let iframe = null;\n        let url = null;\n        // Different setup based on type\n        switch(_type){\n            case 'div':\n                // Find the frame\n                iframe = this.media.querySelector('iframe');\n                // <iframe> type\n                if (is.element(iframe)) {\n                    // Detect provider\n                    url = parseUrl(iframe.getAttribute('src'));\n                    this.provider = getProviderByUrl(url.toString());\n                    // Rework elements\n                    this.elements.container = this.media;\n                    this.media = iframe;\n                    // Reset classname\n                    this.elements.container.className = '';\n                    // Get attributes from URL and set config\n                    if (url.search.length) {\n                        const truthy = [\n                            '1',\n                            'true'\n                        ];\n                        if (truthy.includes(url.searchParams.get('autoplay'))) {\n                            this.config.autoplay = true;\n                        }\n                        if (truthy.includes(url.searchParams.get('loop'))) {\n                            this.config.loop.active = true;\n                        }\n                        // TODO: replace fullscreen.iosNative with this playsinline config option\n                        // YouTube requires the playsinline in the URL\n                        if (this.isYouTube) {\n                            this.config.playsinline = truthy.includes(url.searchParams.get('playsinline'));\n                            this.config.youtube.hl = url.searchParams.get('hl'); // TODO: Should this be setting language?\n                        } else {\n                            this.config.playsinline = true;\n                        }\n                    }\n                } else {\n                    // <div> with attributes\n                    this.provider = this.media.getAttribute(this.config.attributes.embed.provider);\n                    // Remove attribute\n                    this.media.removeAttribute(this.config.attributes.embed.provider);\n                }\n                // Unsupported or missing provider\n                if (is.empty(this.provider) || !Object.values(providers).includes(this.provider)) {\n                    this.debug.error('Setup failed: Invalid provider');\n                    return;\n                }\n                // Audio will come later for external providers\n                this.type = types.video;\n                break;\n            case 'video':\n            case 'audio':\n                this.type = _type;\n                this.provider = providers.html5;\n                // Get config from attributes\n                if (this.media.hasAttribute('crossorigin')) {\n                    this.config.crossorigin = true;\n                }\n                if (this.media.hasAttribute('autoplay')) {\n                    this.config.autoplay = true;\n                }\n                if (this.media.hasAttribute('playsinline') || this.media.hasAttribute('webkit-playsinline')) {\n                    this.config.playsinline = true;\n                }\n                if (this.media.hasAttribute('muted')) {\n                    this.config.muted = true;\n                }\n                if (this.media.hasAttribute('loop')) {\n                    this.config.loop.active = true;\n                }\n                break;\n            default:\n                this.debug.error('Setup failed: unsupported type');\n                return;\n        }\n        // Check for support again but with type\n        this.supported = support.check(this.type, this.provider);\n        // If no support for even API, bail\n        if (!this.supported.api) {\n            this.debug.error('Setup failed: no support');\n            return;\n        }\n        this.eventListeners = [];\n        // Create listeners\n        this.listeners = new Listeners(this);\n        // Setup local storage for user settings\n        this.storage = new Storage(this);\n        // Store reference\n        this.media.plyr = this;\n        // Wrap media\n        if (!is.element(this.elements.container)) {\n            this.elements.container = createElement('div');\n            wrap(this.media, this.elements.container);\n        }\n        // Migrate custom properties from media to container (so they work )\n        ui.migrateStyles.call(this);\n        // Add style hook\n        ui.addStyleHook.call(this);\n        // Setup media\n        media.setup.call(this);\n        // Listen for events if debugging\n        if (this.config.debug) {\n            on.call(this, this.elements.container, this.config.events.join(' '), (event)=>{\n                this.debug.log(`event: ${event.type}`);\n            });\n        }\n        // Setup fullscreen\n        this.fullscreen = new Fullscreen(this);\n        // Setup interface\n        // If embed but not fully supported, build interface now to avoid flash of controls\n        if (this.isHTML5 || this.isEmbed && !this.supported.ui) {\n            ui.build.call(this);\n        }\n        // Container listeners\n        this.listeners.container();\n        // Global listeners\n        this.listeners.global();\n        // Setup ads if provided\n        if (this.config.ads.enabled) {\n            this.ads = new Ads(this);\n        }\n        // Autoplay if required\n        if (this.isHTML5 && this.config.autoplay) {\n            this.once('canplay', ()=>silencePromise(this.play()));\n        }\n        // Seek time will be recorded (in listeners.js) so we can prevent hiding controls for a few seconds after seek\n        this.lastSeekTime = 0;\n        // Setup preview thumbnails if enabled\n        if (this.config.previewThumbnails.enabled) {\n            this.previewThumbnails = new PreviewThumbnails(this);\n        }\n    }\n    // ---------------------------------------\n    // API\n    // ---------------------------------------\n    /**\n   * Types and provider helpers\n   */ get isHTML5() {\n        return this.provider === providers.html5;\n    }\n    get isEmbed() {\n        return this.isYouTube || this.isVimeo;\n    }\n    get isYouTube() {\n        return this.provider === providers.youtube;\n    }\n    get isVimeo() {\n        return this.provider === providers.vimeo;\n    }\n    get isVideo() {\n        return this.type === types.video;\n    }\n    get isAudio() {\n        return this.type === types.audio;\n    }\n    /**\n   * Get playing state\n   */ get playing() {\n        return Boolean(this.ready && !this.paused && !this.ended);\n    }\n    /**\n   * Get paused state\n   */ get paused() {\n        return Boolean(this.media.paused);\n    }\n    /**\n   * Get stopped state\n   */ get stopped() {\n        return Boolean(this.paused && this.currentTime === 0);\n    }\n    /**\n   * Get ended state\n   */ get ended() {\n        return Boolean(this.media.ended);\n    }\n    /**\n   * Seek to a time\n   * @param {number} input - where to seek to in seconds. Defaults to 0 (the start)\n   */ set currentTime(input) {\n        // Bail if media duration isn't available yet\n        if (!this.duration) {\n            return;\n        }\n        // Validate input\n        const inputIsValid = is.number(input) && input > 0;\n        // Set\n        this.media.currentTime = inputIsValid ? Math.min(input, this.duration) : 0;\n        // Logging\n        this.debug.log(`Seeking to ${this.currentTime} seconds`);\n    }\n    /**\n   * Get current time\n   */ get currentTime() {\n        return Number(this.media.currentTime);\n    }\n    /**\n   * Get buffered\n   */ get buffered() {\n        const { buffered } = this.media;\n        // YouTube / Vimeo return a float between 0-1\n        if (is.number(buffered)) {\n            return buffered;\n        }\n        // HTML5\n        // TODO: Handle buffered chunks of the media\n        // (i.e. seek to another section buffers only that section)\n        if (buffered && buffered.length && this.duration > 0) {\n            return buffered.end(0) / this.duration;\n        }\n        return 0;\n    }\n    /**\n   * Get seeking status\n   */ get seeking() {\n        return Boolean(this.media.seeking);\n    }\n    /**\n   * Get the duration of the current media\n   */ get duration() {\n        // Faux duration set via config\n        const fauxDuration = Number.parseFloat(this.config.duration);\n        // Media duration can be NaN or Infinity before the media has loaded\n        const realDuration = (this.media || {}).duration;\n        const duration = !is.number(realDuration) || realDuration === Infinity ? 0 : realDuration;\n        // If config duration is funky, use regular duration\n        return fauxDuration || duration;\n    }\n    /**\n   * Set the player volume\n   * @param {number} value - must be between 0 and 1. Defaults to the value from local storage and config.volume if not set in storage\n   */ set volume(value) {\n        let volume = value;\n        const max = 1;\n        const min = 0;\n        if (is.string(volume)) {\n            volume = Number(volume);\n        }\n        // Load volume from storage if no value specified\n        if (!is.number(volume)) {\n            volume = this.storage.get('volume');\n        }\n        // Use config if all else fails\n        if (!is.number(volume)) {\n            ({ volume } = this.config);\n        }\n        // Maximum is volumeMax\n        if (volume > max) {\n            volume = max;\n        }\n        // Minimum is volumeMin\n        if (volume < min) {\n            volume = min;\n        }\n        // Update config\n        this.config.volume = volume;\n        // Set the player volume\n        this.media.volume = volume;\n        // If muted, and we're increasing volume manually, reset muted state\n        if (!is.empty(value) && this.muted && volume > 0) {\n            this.muted = false;\n        }\n    }\n    /**\n   * Get the current player volume\n   */ get volume() {\n        return Number(this.media.volume);\n    }\n    /**\n   * Set muted state\n   * @param {boolean} mute\n   */ set muted(mute) {\n        let toggle = mute;\n        // Load muted state from storage\n        if (!is.boolean(toggle)) {\n            toggle = this.storage.get('muted');\n        }\n        // Use config if all else fails\n        if (!is.boolean(toggle)) {\n            toggle = this.config.muted;\n        }\n        // Update config\n        this.config.muted = toggle;\n        // Set mute on the player\n        this.media.muted = toggle;\n    }\n    /**\n   * Get current muted state\n   */ get muted() {\n        return Boolean(this.media.muted);\n    }\n    /**\n   * Check if the media has audio\n   */ get hasAudio() {\n        // Assume yes for all non HTML5 (as we can't tell...)\n        if (!this.isHTML5) {\n            return true;\n        }\n        if (this.isAudio) {\n            return true;\n        }\n        // Get audio tracks\n        return Boolean(this.media.mozHasAudio) || Boolean(this.media.webkitAudioDecodedByteCount) || Boolean(this.media.audioTracks && this.media.audioTracks.length);\n    }\n    /**\n   * Set playback speed\n   * @param {number} input - the speed of playback (0.5-2.0)\n   */ set speed(input) {\n        let speed = null;\n        if (is.number(input)) {\n            speed = input;\n        }\n        if (!is.number(speed)) {\n            speed = this.storage.get('speed');\n        }\n        if (!is.number(speed)) {\n            speed = this.config.speed.selected;\n        }\n        // Clamp to min/max\n        const { minimumSpeed: min, maximumSpeed: max } = this;\n        speed = clamp(speed, min, max);\n        // Update config\n        this.config.speed.selected = speed;\n        // Set media speed\n        setTimeout(()=>{\n            if (this.media) {\n                this.media.playbackRate = speed;\n            }\n        }, 0);\n    }\n    /**\n   * Get current playback speed\n   */ get speed() {\n        return Number(this.media.playbackRate);\n    }\n    /**\n   * Get the minimum allowed speed\n   */ get minimumSpeed() {\n        if (this.isYouTube) {\n            // https://developers.google.com/youtube/iframe_api_reference#setPlaybackRate\n            return Math.min(...this.options.speed);\n        }\n        if (this.isVimeo) {\n            // https://github.com/vimeo/player.js/#setplaybackrateplaybackrate-number-promisenumber-rangeerrorerror\n            return 0.5;\n        }\n        // https://stackoverflow.com/a/32320020/1191319\n        return 0.0625;\n    }\n    /**\n   * Get the maximum allowed speed\n   */ get maximumSpeed() {\n        if (this.isYouTube) {\n            // https://developers.google.com/youtube/iframe_api_reference#setPlaybackRate\n            return Math.max(...this.options.speed);\n        }\n        if (this.isVimeo) {\n            // https://github.com/vimeo/player.js/#setplaybackrateplaybackrate-number-promisenumber-rangeerrorerror\n            return 2;\n        }\n        // https://stackoverflow.com/a/32320020/1191319\n        return 16;\n    }\n    /**\n   * Set playback quality\n   * Currently HTML5 & YouTube only\n   * @param {number} input - Quality level\n   */ set quality(input) {\n        const config = this.config.quality;\n        const options = this.options.quality;\n        if (!options.length) {\n            return;\n        }\n        let quality = [\n            !is.empty(input) && Number(input),\n            this.storage.get('quality'),\n            config.selected,\n            config.default\n        ].find(is.number);\n        let updateStorage = true;\n        if (!options.includes(quality)) {\n            const value = closest(options, quality);\n            this.debug.warn(`Unsupported quality option: ${quality}, using ${value} instead`);\n            quality = value;\n            // Don't update storage if quality is not supported\n            updateStorage = false;\n        }\n        // Update config\n        config.selected = quality;\n        // Set quality\n        this.media.quality = quality;\n        // Save to storage\n        if (updateStorage) {\n            this.storage.set({\n                quality\n            });\n        }\n    }\n    /**\n   * Get current quality level\n   */ get quality() {\n        return this.media.quality;\n    }\n    /**\n   * Toggle loop\n   * TODO: Finish fancy new logic. Set the indicator on load as user may pass loop as config\n   * @param {boolean} input - Whether to loop or not\n   */ set loop(input) {\n        const toggle = is.boolean(input) ? input : this.config.loop.active;\n        this.config.loop.active = toggle;\n        this.media.loop = toggle;\n    // Set default to be a true toggle\n    /* const type = ['start', 'end', 'all', 'none', 'toggle'].includes(input) ? input : 'toggle';\n         switch (type) {\n            case 'start':\n                if (this.config.loop.end && this.config.loop.end <= this.currentTime) {\n                    this.config.loop.end = null;\n                }\n                this.config.loop.start = this.currentTime;\n                // this.config.loop.indicator.start = this.elements.display.played.value;\n                break;\n             case 'end':\n                if (this.config.loop.start >= this.currentTime) {\n                    return this;\n                }\n                this.config.loop.end = this.currentTime;\n                // this.config.loop.indicator.end = this.elements.display.played.value;\n                break;\n             case 'all':\n                this.config.loop.start = 0;\n                this.config.loop.end = this.duration - 2;\n                this.config.loop.indicator.start = 0;\n                this.config.loop.indicator.end = 100;\n                break;\n             case 'toggle':\n                if (this.config.loop.active) {\n                    this.config.loop.start = 0;\n                    this.config.loop.end = null;\n                } else {\n                    this.config.loop.start = 0;\n                    this.config.loop.end = this.duration - 2;\n                }\n                break;\n             default:\n                this.config.loop.start = 0;\n                this.config.loop.end = null;\n                break;\n        } */ }\n    /**\n   * Get current loop state\n   */ get loop() {\n        return Boolean(this.media.loop);\n    }\n    /**\n   * Set new media source\n   * @param {object} input - The new source object (see docs)\n   */ set source(input) {\n        source.change.call(this, input);\n    }\n    /**\n   * Get current source\n   */ get source() {\n        return this.media.currentSrc;\n    }\n    /**\n   * Get a download URL (either source or custom)\n   */ get download() {\n        const { download } = this.config.urls;\n        return is.url(download) ? download : this.source;\n    }\n    /**\n   * Set the download URL\n   */ set download(input) {\n        if (!is.url(input)) {\n            return;\n        }\n        this.config.urls.download = input;\n        controls.setDownloadUrl.call(this);\n    }\n    /**\n   * Set the poster image for a video\n   * @param {string} input - the URL for the new poster image\n   */ set poster(input) {\n        if (!this.isVideo) {\n            this.debug.warn('Poster can only be set for video');\n            return;\n        }\n        ui.setPoster.call(this, input, false).catch(()=>{});\n    }\n    /**\n   * Get the current poster image\n   */ get poster() {\n        if (!this.isVideo) {\n            return null;\n        }\n        return this.media.getAttribute('poster') || this.media.getAttribute('data-poster');\n    }\n    /**\n   * Get the current aspect ratio in use\n   */ get ratio() {\n        if (!this.isVideo) {\n            return null;\n        }\n        const ratio = reduceAspectRatio(getAspectRatio.call(this));\n        return is.array(ratio) ? ratio.join(':') : ratio;\n    }\n    /**\n   * Set video aspect ratio\n   */ set ratio(input) {\n        if (!this.isVideo) {\n            this.debug.warn('Aspect ratio can only be set for video');\n            return;\n        }\n        if (!is.string(input) || !validateAspectRatio(input)) {\n            this.debug.error(`Invalid aspect ratio specified (${input})`);\n            return;\n        }\n        this.config.ratio = reduceAspectRatio(input);\n        setAspectRatio.call(this);\n    }\n    /**\n   * Set the autoplay state\n   * @param {boolean} input - Whether to autoplay or not\n   */ set autoplay(input) {\n        this.config.autoplay = is.boolean(input) ? input : this.config.autoplay;\n    }\n    /**\n   * Get the current autoplay state\n   */ get autoplay() {\n        return Boolean(this.config.autoplay);\n    }\n    /**\n   * Toggle captions\n   * @param {boolean} input - Whether to enable captions\n   */ toggleCaptions(input) {\n        captions.toggle.call(this, input, false);\n    }\n    /**\n   * Set the caption track by index\n   * @param {number} input - Caption index\n   */ set currentTrack(input) {\n        captions.set.call(this, input, false);\n        captions.setup.call(this);\n    }\n    /**\n   * Get the current caption track index (-1 if disabled)\n   */ get currentTrack() {\n        const { toggled, currentTrack } = this.captions;\n        return toggled ? currentTrack : -1;\n    }\n    /**\n   * Set the wanted language for captions\n   * Since tracks can be added later it won't update the actual caption track until there is a matching track\n   * @param {string} input - Two character ISO language code (e.g. EN, FR, PT, etc)\n   */ set language(input) {\n        captions.setLanguage.call(this, input, false);\n    }\n    /**\n   * Get the current track's language\n   */ get language() {\n        return (captions.getCurrentTrack.call(this) || {}).language;\n    }\n    /**\n   * Toggle picture-in-picture playback on WebKit/MacOS\n   * TODO: update player with state, support, enabled\n   * TODO: detect outside changes\n   */ set pip(input) {\n        // Bail if no support\n        if (!support.pip) {\n            return;\n        }\n        // Toggle based on current state if not passed\n        const toggle = is.boolean(input) ? input : !this.pip;\n        // Toggle based on current state\n        // Safari\n        if (is.function(this.media.webkitSetPresentationMode)) {\n            this.media.webkitSetPresentationMode(toggle ? pip.active : pip.inactive);\n        }\n        // Chrome\n        if (is.function(this.media.requestPictureInPicture)) {\n            if (!this.pip && toggle) {\n                this.media.requestPictureInPicture();\n            } else if (this.pip && !toggle) {\n                document.exitPictureInPicture();\n            }\n        }\n    }\n    /**\n   * Get the current picture-in-picture state\n   */ get pip() {\n        if (!support.pip) {\n            return null;\n        }\n        // Safari\n        if (!is.empty(this.media.webkitPresentationMode)) {\n            return this.media.webkitPresentationMode === pip.active;\n        }\n        // Chrome\n        return this.media === document.pictureInPictureElement;\n    }\n    /**\n   * Sets the preview thumbnails for the current source\n   */ setPreviewThumbnails(thumbnailSource) {\n        if (this.previewThumbnails && this.previewThumbnails.loaded) {\n            this.previewThumbnails.destroy();\n            this.previewThumbnails = null;\n        }\n        Object.assign(this.config.previewThumbnails, thumbnailSource);\n        // Create new instance if it is still enabled\n        if (this.config.previewThumbnails.enabled) {\n            this.previewThumbnails = new PreviewThumbnails(this);\n        }\n    }\n    /**\n   * Check for support\n   * @param {string} type - Player type (audio/video)\n   * @param {string} provider - Provider (html5/youtube/vimeo)\n   */ static supported(type, provider) {\n        return support.check(type, provider);\n    }\n    /**\n   * Load an SVG sprite into the page\n   * @param {string} url - URL for the SVG sprite\n   * @param {string} [id] - Unique ID\n   */ static loadSprite(url, id) {\n        return loadSprite(url, id);\n    }\n    /**\n   * Setup multiple instances\n   * @param {*} selector\n   * @param {object} options\n   */ static setup(selector, options = {}) {\n        let targets = null;\n        if (is.string(selector)) {\n            targets = Array.from(document.querySelectorAll(selector));\n        } else if (is.nodeList(selector)) {\n            targets = Array.from(selector);\n        } else if (is.array(selector)) {\n            targets = selector.filter(is.element);\n        }\n        if (is.empty(targets)) {\n            return null;\n        }\n        return targets.map((t)=>new Plyr(t, options));\n    }\n}\nPlyr.defaults = cloneDeep(defaults);\n //# sourceMappingURL=plyr.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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V0FBVztZQUNoQ2hDLFVBQVUvSixNQUFNQyxJQUFJLENBQUM4TDtRQUN2QixPQUFPLElBQUl2RSxHQUFHckYsS0FBSyxDQUFDNEosV0FBVztZQUM3QmhDLFVBQVVnQyxTQUFTN00sTUFBTSxDQUFDc0ksR0FBR25GLE9BQU87UUFDdEM7UUFDQSxJQUFJbUYsR0FBR2pGLEtBQUssQ0FBQ3dILFVBQVU7WUFDckIsT0FBTztRQUNUO1FBQ0EsT0FBT0EsUUFBUTdFLEdBQUcsQ0FBQzNILENBQUFBLElBQUssSUFBSWtyQyxLQUFLbHJDLEdBQUdzUztJQUN0QztBQUNGO0FBQ0E0NEIsS0FBS3JmLFFBQVEsR0FBR3RnQixVQUFVc2dCO0FBRUMsQ0FDM0IsZ0NBQWdDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFkbWluaXN0cmF0b3JcXERlc2t0b3BcXHhLb2RhICgyKVxceEtvZGFcXG5vZGVfbW9kdWxlc1xccGx5clxcZGlzdFxccGx5ci5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5JDEoZSwgciwgdCkge1xuICByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7XG4gICAgdmFsdWU6IHQsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSkgOiBlW3JdID0gdCwgZTtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7XG4gIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGUsIHQpIHtcbiAgaWYgKCEoZSBpbnN0YW5jZW9mIHQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgdCkge1xuICBmb3IgKHZhciBuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspIHtcbiAgICB2YXIgciA9IHRbbl07XG4gICAgci5lbnVtZXJhYmxlID0gci5lbnVtZXJhYmxlIHx8IGZhbHNlLCByLmNvbmZpZ3VyYWJsZSA9IHRydWUsIFwidmFsdWVcIiBpbiByICYmIChyLndyaXRhYmxlID0gdHJ1ZSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLmtleSwgcik7XG4gIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCB0LCBuKSB7XG4gIHJldHVybiB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCB0KSwgbiAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCBuKSwgZTtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCB0LCBuKSB7XG4gIHJldHVybiB0IGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgdCwge1xuICAgIHZhbHVlOiBuLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pIDogZVt0XSA9IG4sIGU7XG59XG5mdW5jdGlvbiBvd25LZXlzKGUsIHQpIHtcbiAgdmFyIG4gPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgdCAmJiAociA9IHIuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB0KS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgbi5wdXNoLmFwcGx5KG4sIHIpO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIoZSkge1xuICBmb3IgKHZhciB0ID0gMTsgdCA8IGFyZ3VtZW50cy5sZW5ndGg7IHQrKykge1xuICAgIHZhciBuID0gbnVsbCAhPSBhcmd1bWVudHNbdF0gPyBhcmd1bWVudHNbdF0gOiB7fTtcbiAgICB0ICUgMiA/IG93bktleXMoT2JqZWN0KG4pLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoZSwgdCwgblt0XSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG4pKSA6IG93bktleXMoT2JqZWN0KG4pKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgdCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLCB0KSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG52YXIgZGVmYXVsdHMkMSA9IHtcbiAgYWRkQ1NTOiB0cnVlLFxuICB0aHVtYldpZHRoOiAxNSxcbiAgd2F0Y2g6IHRydWVcbn07XG5mdW5jdGlvbiBtYXRjaGVzJDEoZSwgdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodCkpLmluY2x1ZGVzKHRoaXMpO1xuICB9LmNhbGwoZSwgdCk7XG59XG5mdW5jdGlvbiB0cmlnZ2VyKGUsIHQpIHtcbiAgaWYgKGUgJiYgdCkge1xuICAgIHZhciBuID0gbmV3IEV2ZW50KHQsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICB9KTtcbiAgICBlLmRpc3BhdGNoRXZlbnQobik7XG4gIH1cbn1cbnZhciBnZXRDb25zdHJ1Y3RvciQxID0gZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gbnVsbCAhPSBlID8gZS5jb25zdHJ1Y3RvciA6IG51bGw7XG4gIH0sXG4gIGluc3RhbmNlT2YkMSA9IGZ1bmN0aW9uIChlLCB0KSB7XG4gICAgcmV0dXJuICEhKGUgJiYgdCAmJiBlIGluc3RhbmNlb2YgdCk7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkJDEgPSBmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBudWxsID09IGU7XG4gIH0sXG4gIGlzT2JqZWN0JDEgPSBmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBnZXRDb25zdHJ1Y3RvciQxKGUpID09PSBPYmplY3Q7XG4gIH0sXG4gIGlzTnVtYmVyJDEgPSBmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBnZXRDb25zdHJ1Y3RvciQxKGUpID09PSBOdW1iZXIgJiYgIU51bWJlci5pc05hTihlKTtcbiAgfSxcbiAgaXNTdHJpbmckMSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIGdldENvbnN0cnVjdG9yJDEoZSkgPT09IFN0cmluZztcbiAgfSxcbiAgaXNCb29sZWFuJDEgPSBmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBnZXRDb25zdHJ1Y3RvciQxKGUpID09PSBCb29sZWFuO1xuICB9LFxuICBpc0Z1bmN0aW9uJDEgPSBmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBnZXRDb25zdHJ1Y3RvciQxKGUpID09PSBGdW5jdGlvbjtcbiAgfSxcbiAgaXNBcnJheSQxID0gZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShlKTtcbiAgfSxcbiAgaXNOb2RlTGlzdCQxID0gZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gaW5zdGFuY2VPZiQxKGUsIE5vZGVMaXN0KTtcbiAgfSxcbiAgaXNFbGVtZW50JDEgPSBmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBpbnN0YW5jZU9mJDEoZSwgRWxlbWVudCk7XG4gIH0sXG4gIGlzRXZlbnQkMSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlT2YkMShlLCBFdmVudCk7XG4gIH0sXG4gIGlzRW1wdHkkMSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIGlzTnVsbE9yVW5kZWZpbmVkJDEoZSkgfHwgKGlzU3RyaW5nJDEoZSkgfHwgaXNBcnJheSQxKGUpIHx8IGlzTm9kZUxpc3QkMShlKSkgJiYgIWUubGVuZ3RoIHx8IGlzT2JqZWN0JDEoZSkgJiYgIU9iamVjdC5rZXlzKGUpLmxlbmd0aDtcbiAgfSxcbiAgaXMkMSA9IHtcbiAgICBudWxsT3JVbmRlZmluZWQ6IGlzTnVsbE9yVW5kZWZpbmVkJDEsXG4gICAgb2JqZWN0OiBpc09iamVjdCQxLFxuICAgIG51bWJlcjogaXNOdW1iZXIkMSxcbiAgICBzdHJpbmc6IGlzU3RyaW5nJDEsXG4gICAgYm9vbGVhbjogaXNCb29sZWFuJDEsXG4gICAgZnVuY3Rpb246IGlzRnVuY3Rpb24kMSxcbiAgICBhcnJheTogaXNBcnJheSQxLFxuICAgIG5vZGVMaXN0OiBpc05vZGVMaXN0JDEsXG4gICAgZWxlbWVudDogaXNFbGVtZW50JDEsXG4gICAgZXZlbnQ6IGlzRXZlbnQkMSxcbiAgICBlbXB0eTogaXNFbXB0eSQxXG4gIH07XG5mdW5jdGlvbiBnZXREZWNpbWFsUGxhY2VzKGUpIHtcbiAgdmFyIHQgPSBcIlwiLmNvbmNhdChlKS5tYXRjaCgvKD86XFwuKFxcZCspKT8oPzpbZUVdKFsrLV0/XFxkKykpPyQvKTtcbiAgcmV0dXJuIHQgPyBNYXRoLm1heCgwLCAodFsxXSA/IHRbMV0ubGVuZ3RoIDogMCkgLSAodFsyXSA/ICt0WzJdIDogMCkpIDogMDtcbn1cbmZ1bmN0aW9uIHJvdW5kKGUsIHQpIHtcbiAgaWYgKDEgPiB0KSB7XG4gICAgdmFyIG4gPSBnZXREZWNpbWFsUGxhY2VzKHQpO1xuICAgIHJldHVybiBwYXJzZUZsb2F0KGUudG9GaXhlZChuKSk7XG4gIH1cbiAgcmV0dXJuIE1hdGgucm91bmQoZSAvIHQpICogdDtcbn1cbnZhciBSYW5nZVRvdWNoID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBlKHQsIG4pIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgZSksIGlzJDEuZWxlbWVudCh0KSA/IHRoaXMuZWxlbWVudCA9IHQgOiBpcyQxLnN0cmluZyh0KSAmJiAodGhpcy5lbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0KSksIGlzJDEuZWxlbWVudCh0aGlzLmVsZW1lbnQpICYmIGlzJDEuZW1wdHkodGhpcy5lbGVtZW50LnJhbmdlVG91Y2gpICYmICh0aGlzLmNvbmZpZyA9IF9vYmplY3RTcHJlYWQyKHt9LCBkZWZhdWx0cyQxLCB7fSwgbiksIHRoaXMuaW5pdCgpKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKGUsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgZS5lbmFibGVkICYmICh0aGlzLmNvbmZpZy5hZGRDU1MgJiYgKHRoaXMuZWxlbWVudC5zdHlsZS51c2VyU2VsZWN0ID0gXCJub25lXCIsIHRoaXMuZWxlbWVudC5zdHlsZS53ZWJLaXRVc2VyU2VsZWN0ID0gXCJub25lXCIsIHRoaXMuZWxlbWVudC5zdHlsZS50b3VjaEFjdGlvbiA9IFwibWFuaXB1bGF0aW9uXCIpLCB0aGlzLmxpc3RlbmVycyh0cnVlKSwgdGhpcy5lbGVtZW50LnJhbmdlVG91Y2ggPSB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBlLmVuYWJsZWQgJiYgKHRoaXMuY29uZmlnLmFkZENTUyAmJiAodGhpcy5lbGVtZW50LnN0eWxlLnVzZXJTZWxlY3QgPSBcIlwiLCB0aGlzLmVsZW1lbnQuc3R5bGUud2ViS2l0VXNlclNlbGVjdCA9IFwiXCIsIHRoaXMuZWxlbWVudC5zdHlsZS50b3VjaEFjdGlvbiA9IFwiXCIpLCB0aGlzLmxpc3RlbmVycyhmYWxzZSksIHRoaXMuZWxlbWVudC5yYW5nZVRvdWNoID0gbnVsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIHQgPSB0aGlzLFxuICAgICAgICBuID0gZSA/IFwiYWRkRXZlbnRMaXN0ZW5lclwiIDogXCJyZW1vdmVFdmVudExpc3RlbmVyXCI7XG4gICAgICBbXCJ0b3VjaHN0YXJ0XCIsIFwidG91Y2htb3ZlXCIsIFwidG91Y2hlbmRcIl0uZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICB0LmVsZW1lbnRbbl0oZSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gdC5zZXQoZSk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHQpIHtcbiAgICAgIGlmICghZS5lbmFibGVkIHx8ICFpcyQxLmV2ZW50KHQpKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBuLFxuICAgICAgICByID0gdC50YXJnZXQsXG4gICAgICAgIGkgPSB0LmNoYW5nZWRUb3VjaGVzWzBdLFxuICAgICAgICBvID0gcGFyc2VGbG9hdChyLmdldEF0dHJpYnV0ZShcIm1pblwiKSkgfHwgMCxcbiAgICAgICAgcyA9IHBhcnNlRmxvYXQoci5nZXRBdHRyaWJ1dGUoXCJtYXhcIikpIHx8IDEwMCxcbiAgICAgICAgdSA9IHBhcnNlRmxvYXQoci5nZXRBdHRyaWJ1dGUoXCJzdGVwXCIpKSB8fCAxLFxuICAgICAgICBjID0gci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgYSA9IDEwMCAvIGMud2lkdGggKiAodGhpcy5jb25maWcudGh1bWJXaWR0aCAvIDIpIC8gMTAwO1xuICAgICAgcmV0dXJuIDAgPiAobiA9IDEwMCAvIGMud2lkdGggKiAoaS5jbGllbnRYIC0gYy5sZWZ0KSkgPyBuID0gMCA6IDEwMCA8IG4gJiYgKG4gPSAxMDApLCA1MCA+IG4gPyBuIC09ICgxMDAgLSAyICogbikgKiBhIDogNTAgPCBuICYmIChuICs9IDIgKiAobiAtIDUwKSAqIGEpLCBvICsgcm91bmQobiAvIDEwMCAqIChzIC0gbyksIHUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHQpIHtcbiAgICAgIGUuZW5hYmxlZCAmJiBpcyQxLmV2ZW50KHQpICYmICF0LnRhcmdldC5kaXNhYmxlZCAmJiAodC5wcmV2ZW50RGVmYXVsdCgpLCB0LnRhcmdldC52YWx1ZSA9IHRoaXMuZ2V0KHQpLCB0cmlnZ2VyKHQudGFyZ2V0LCBcInRvdWNoZW5kXCIgPT09IHQudHlwZSA/IFwiY2hhbmdlXCIgOiBcImlucHV0XCIpKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJzZXR1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIG4gPSAxIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1sxXSA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgICByID0gbnVsbDtcbiAgICAgIGlmIChpcyQxLmVtcHR5KHQpIHx8IGlzJDEuc3RyaW5nKHQpID8gciA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChpcyQxLnN0cmluZyh0KSA/IHQgOiAnaW5wdXRbdHlwZT1cInJhbmdlXCJdJykpIDogaXMkMS5lbGVtZW50KHQpID8gciA9IFt0XSA6IGlzJDEubm9kZUxpc3QodCkgPyByID0gQXJyYXkuZnJvbSh0KSA6IGlzJDEuYXJyYXkodCkgJiYgKHIgPSB0LmZpbHRlcihpcyQxLmVsZW1lbnQpKSwgaXMkMS5lbXB0eShyKSkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgaSA9IF9vYmplY3RTcHJlYWQyKHt9LCBkZWZhdWx0cyQxLCB7fSwgbik7XG4gICAgICBpZiAoaXMkMS5zdHJpbmcodCkgJiYgaS53YXRjaCkge1xuICAgICAgICB2YXIgbyA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgQXJyYXkuZnJvbShuKS5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICBBcnJheS5mcm9tKG4uYWRkZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICBpcyQxLmVsZW1lbnQobikgJiYgbWF0Y2hlcyQxKG4sIHQpICYmIG5ldyBlKG4sIGkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBvLm9ic2VydmUoZG9jdW1lbnQuYm9keSwge1xuICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHIubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgZSh0LCBuKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmFibGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfVxuICB9XSksIGU7XG59KCk7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBUeXBlIGNoZWNraW5nIHV0aWxzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBnZXRDb25zdHJ1Y3RvciA9IGlucHV0ID0+IGlucHV0ICE9PSBudWxsICYmIHR5cGVvZiBpbnB1dCAhPT0gJ3VuZGVmaW5lZCcgPyBpbnB1dC5jb25zdHJ1Y3RvciA6IG51bGw7XG5jb25zdCBpbnN0YW5jZU9mID0gKGlucHV0LCBjb25zdHJ1Y3RvcikgPT4gQm9vbGVhbihpbnB1dCAmJiBjb25zdHJ1Y3RvciAmJiBpbnB1dCBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKTtcbmNvbnN0IGlzTnVsbE9yVW5kZWZpbmVkID0gaW5wdXQgPT4gaW5wdXQgPT09IG51bGwgfHwgdHlwZW9mIGlucHV0ID09PSAndW5kZWZpbmVkJztcbmNvbnN0IGlzT2JqZWN0ID0gaW5wdXQgPT4gZ2V0Q29uc3RydWN0b3IoaW5wdXQpID09PSBPYmplY3Q7XG5jb25zdCBpc051bWJlciA9IGlucHV0ID0+IGdldENvbnN0cnVjdG9yKGlucHV0KSA9PT0gTnVtYmVyICYmICFOdW1iZXIuaXNOYU4oaW5wdXQpO1xuY29uc3QgaXNTdHJpbmcgPSBpbnB1dCA9PiBnZXRDb25zdHJ1Y3RvcihpbnB1dCkgPT09IFN0cmluZztcbmNvbnN0IGlzQm9vbGVhbiA9IGlucHV0ID0+IGdldENvbnN0cnVjdG9yKGlucHV0KSA9PT0gQm9vbGVhbjtcbmNvbnN0IGlzRnVuY3Rpb24gPSBpbnB1dCA9PiB0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbic7XG5jb25zdCBpc0FycmF5ID0gaW5wdXQgPT4gQXJyYXkuaXNBcnJheShpbnB1dCk7XG5jb25zdCBpc1dlYWtNYXAgPSBpbnB1dCA9PiBpbnN0YW5jZU9mKGlucHV0LCBXZWFrTWFwKTtcbmNvbnN0IGlzTm9kZUxpc3QgPSBpbnB1dCA9PiBpbnN0YW5jZU9mKGlucHV0LCBOb2RlTGlzdCk7XG5jb25zdCBpc1RleHROb2RlID0gaW5wdXQgPT4gZ2V0Q29uc3RydWN0b3IoaW5wdXQpID09PSBUZXh0O1xuY29uc3QgaXNFdmVudCA9IGlucHV0ID0+IGluc3RhbmNlT2YoaW5wdXQsIEV2ZW50KTtcbmNvbnN0IGlzS2V5Ym9hcmRFdmVudCA9IGlucHV0ID0+IGluc3RhbmNlT2YoaW5wdXQsIEtleWJvYXJkRXZlbnQpO1xuY29uc3QgaXNDdWUgPSBpbnB1dCA9PiBpbnN0YW5jZU9mKGlucHV0LCB3aW5kb3cuVGV4dFRyYWNrQ3VlKSB8fCBpbnN0YW5jZU9mKGlucHV0LCB3aW5kb3cuVlRUQ3VlKTtcbmNvbnN0IGlzVHJhY2sgPSBpbnB1dCA9PiBpbnN0YW5jZU9mKGlucHV0LCBUZXh0VHJhY2spIHx8ICFpc051bGxPclVuZGVmaW5lZChpbnB1dCkgJiYgaXNTdHJpbmcoaW5wdXQua2luZCk7XG5jb25zdCBpc1Byb21pc2UgPSBpbnB1dCA9PiBpbnN0YW5jZU9mKGlucHV0LCBQcm9taXNlKSAmJiBpc0Z1bmN0aW9uKGlucHV0LnRoZW4pO1xuZnVuY3Rpb24gaXNFbGVtZW50KGlucHV0KSB7XG4gIHJldHVybiBpbnB1dCAhPT0gbnVsbCAmJiB0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0Lm5vZGVUeXBlID09PSAxICYmIHR5cGVvZiBpbnB1dC5zdHlsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGlucHV0Lm93bmVyRG9jdW1lbnQgPT09ICdvYmplY3QnO1xufVxuZnVuY3Rpb24gaXNFbXB0eShpbnB1dCkge1xuICByZXR1cm4gaXNOdWxsT3JVbmRlZmluZWQoaW5wdXQpIHx8IChpc1N0cmluZyhpbnB1dCkgfHwgaXNBcnJheShpbnB1dCkgfHwgaXNOb2RlTGlzdChpbnB1dCkpICYmICFpbnB1dC5sZW5ndGggfHwgaXNPYmplY3QoaW5wdXQpICYmICFPYmplY3Qua2V5cyhpbnB1dCkubGVuZ3RoO1xufVxuZnVuY3Rpb24gaXNVcmwoaW5wdXQpIHtcbiAgLy8gQWNjZXB0IGEgVVJMIG9iamVjdFxuICBpZiAoaW5zdGFuY2VPZihpbnB1dCwgd2luZG93LlVSTCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIE11c3QgYmUgc3RyaW5nIGZyb20gaGVyZVxuICBpZiAoIWlzU3RyaW5nKGlucHV0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEFkZCB0aGUgcHJvdG9jb2wgaWYgcmVxdWlyZWRcbiAgbGV0IHN0cmluZyA9IGlucHV0O1xuICBpZiAoIWlucHV0LnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nKSB8fCAhaW5wdXQuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSkge1xuICAgIHN0cmluZyA9IGBodHRwOi8vJHtpbnB1dH1gO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuICFpc0VtcHR5KG5ldyBVUkwoc3RyaW5nKS5ob3N0bmFtZSk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxudmFyIGlzID0ge1xuICBudWxsT3JVbmRlZmluZWQ6IGlzTnVsbE9yVW5kZWZpbmVkLFxuICBvYmplY3Q6IGlzT2JqZWN0LFxuICBudW1iZXI6IGlzTnVtYmVyLFxuICBzdHJpbmc6IGlzU3RyaW5nLFxuICBib29sZWFuOiBpc0Jvb2xlYW4sXG4gIGZ1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBhcnJheTogaXNBcnJheSxcbiAgd2Vha01hcDogaXNXZWFrTWFwLFxuICBub2RlTGlzdDogaXNOb2RlTGlzdCxcbiAgZWxlbWVudDogaXNFbGVtZW50LFxuICB0ZXh0Tm9kZTogaXNUZXh0Tm9kZSxcbiAgZXZlbnQ6IGlzRXZlbnQsXG4gIGtleWJvYXJkRXZlbnQ6IGlzS2V5Ym9hcmRFdmVudCxcbiAgY3VlOiBpc0N1ZSxcbiAgdHJhY2s6IGlzVHJhY2ssXG4gIHByb21pc2U6IGlzUHJvbWlzZSxcbiAgdXJsOiBpc1VybCxcbiAgZW1wdHk6IGlzRW1wdHlcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBBbmltYXRpb24gdXRpbHNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmNvbnN0IHRyYW5zaXRpb25FbmRFdmVudCA9ICgoKSA9PiB7XG4gIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGNvbnN0IGV2ZW50cyA9IHtcbiAgICBXZWJraXRUcmFuc2l0aW9uOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgTW96VHJhbnNpdGlvbjogJ3RyYW5zaXRpb25lbmQnLFxuICAgIE9UcmFuc2l0aW9uOiAnb1RyYW5zaXRpb25FbmQgb3RyYW5zaXRpb25lbmQnLFxuICAgIHRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJ1xuICB9O1xuICBjb25zdCB0eXBlID0gT2JqZWN0LmtleXMoZXZlbnRzKS5maW5kKGV2ZW50ID0+IGVsZW1lbnQuc3R5bGVbZXZlbnRdICE9PSB1bmRlZmluZWQpO1xuICByZXR1cm4gaXMuc3RyaW5nKHR5cGUpID8gZXZlbnRzW3R5cGVdIDogZmFsc2U7XG59KSgpO1xuXG4vLyBGb3JjZSByZXBhaW50IG9mIGVsZW1lbnRcbmZ1bmN0aW9uIHJlcGFpbnQoZWxlbWVudCwgZGVsYXkpIHtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGVsZW1lbnQuaGlkZGVuID0gdHJ1ZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgICAgIGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgZWxlbWVudC5oaWRkZW4gPSBmYWxzZTtcbiAgICB9IGNhdGNoIHt9XG4gIH0sIGRlbGF5KTtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIE9iamVjdCB1dGlsc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4vLyBDbG9uZSBuZXN0ZWQgb2JqZWN0c1xuZnVuY3Rpb24gY2xvbmVEZWVwKG9iamVjdCkge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmplY3QpKTtcbn1cblxuLy8gR2V0IGEgbmVzdGVkIHZhbHVlIGluIGFuIG9iamVjdFxuZnVuY3Rpb24gZ2V0RGVlcChvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguc3BsaXQoJy4nKS5yZWR1Y2UoKG9iaiwga2V5KSA9PiBvYmogJiYgb2JqW2tleV0sIG9iamVjdCk7XG59XG5cbi8vIERlZXAgZXh0ZW5kIGRlc3RpbmF0aW9uIG9iamVjdCB3aXRoIE4gbW9yZSBvYmplY3RzXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0ID0ge30sIC4uLnNvdXJjZXMpIHtcbiAgaWYgKCFzb3VyY2VzLmxlbmd0aCkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgY29uc3Qgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICBpZiAoIWlzLm9iamVjdChzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goa2V5ID0+IHtcbiAgICBpZiAoaXMub2JqZWN0KHNvdXJjZVtrZXldKSkge1xuICAgICAgaWYgKCFPYmplY3Qua2V5cyh0YXJnZXQpLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHtcbiAgICAgICAgICBba2V5XToge31cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBleHRlbmQodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHtcbiAgICAgICAgW2tleV06IHNvdXJjZVtrZXldXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZXh0ZW5kKHRhcmdldCwgLi4uc291cmNlcyk7XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBFbGVtZW50IHV0aWxzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbi8vIFdyYXAgYW4gZWxlbWVudFxuZnVuY3Rpb24gd3JhcChlbGVtZW50cywgd3JhcHBlcikge1xuICAvLyBDb252ZXJ0IGBlbGVtZW50c2AgdG8gYW4gYXJyYXksIGlmIG5lY2Vzc2FyeS5cbiAgY29uc3QgdGFyZ2V0cyA9IGVsZW1lbnRzLmxlbmd0aCA/IGVsZW1lbnRzIDogW2VsZW1lbnRzXTtcblxuICAvLyBMb29wcyBiYWNrd2FyZHMgdG8gcHJldmVudCBoYXZpbmcgdG8gY2xvbmUgdGhlIHdyYXBwZXIgb24gdGhlXG4gIC8vIGZpcnN0IGVsZW1lbnQgKHNlZSBgY2hpbGRgIGJlbG93KS5cbiAgQXJyYXkuZnJvbSh0YXJnZXRzKS5yZXZlcnNlKCkuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBjaGlsZCA9IGluZGV4ID4gMCA/IHdyYXBwZXIuY2xvbmVOb2RlKHRydWUpIDogd3JhcHBlcjtcbiAgICAvLyBDYWNoZSB0aGUgY3VycmVudCBwYXJlbnQgYW5kIHNpYmxpbmcuXG4gICAgY29uc3QgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIGNvbnN0IHNpYmxpbmcgPSBlbGVtZW50Lm5leHRTaWJsaW5nO1xuXG4gICAgLy8gV3JhcCB0aGUgZWxlbWVudCAoaXMgYXV0b21hdGljYWxseSByZW1vdmVkIGZyb20gaXRzIGN1cnJlbnRcbiAgICAvLyBwYXJlbnQpLlxuICAgIGNoaWxkLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXG4gICAgLy8gSWYgdGhlIGVsZW1lbnQgaGFkIGEgc2libGluZywgaW5zZXJ0IHRoZSB3cmFwcGVyIGJlZm9yZVxuICAgIC8vIHRoZSBzaWJsaW5nIHRvIG1haW50YWluIHRoZSBIVE1MIHN0cnVjdHVyZTsgb3RoZXJ3aXNlLCBqdXN0XG4gICAgLy8gYXBwZW5kIGl0IHRvIHRoZSBwYXJlbnQuXG4gICAgaWYgKHNpYmxpbmcpIHtcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHNpYmxpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIFNldCBhdHRyaWJ1dGVzXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgaWYgKCFpcy5lbGVtZW50KGVsZW1lbnQpIHx8IGlzLmVtcHR5KGF0dHJpYnV0ZXMpKSByZXR1cm47XG5cbiAgLy8gQXNzdW1lIG51bGwgYW5kIHVuZGVmaW5lZCBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsZWZ0IG91dCxcbiAgLy8gU2V0dGluZyB0aGVtIHdvdWxkIG90aGVyd2lzZSBjb252ZXJ0IHRoZW0gdG8gXCJudWxsXCIgYW5kIFwidW5kZWZpbmVkXCJcbiAgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykuZmlsdGVyKChbLCB2YWx1ZV0pID0+ICFpcy5udWxsT3JVbmRlZmluZWQodmFsdWUpKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpKTtcbn1cblxuLy8gQ3JlYXRlIGEgRG9jdW1lbnRGcmFnbWVudFxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBhdHRyaWJ1dGVzLCB0ZXh0KSB7XG4gIC8vIENyZWF0ZSBhIG5ldyA8ZWxlbWVudD5cbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG5cbiAgLy8gU2V0IGFsbCBwYXNzZWQgYXR0cmlidXRlc1xuICBpZiAoaXMub2JqZWN0KGF0dHJpYnV0ZXMpKSB7XG4gICAgc2V0QXR0cmlidXRlcyhlbGVtZW50LCBhdHRyaWJ1dGVzKTtcbiAgfVxuXG4gIC8vIEFkZCB0ZXh0IG5vZGVcbiAgaWYgKGlzLnN0cmluZyh0ZXh0KSkge1xuICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSB0ZXh0O1xuICB9XG5cbiAgLy8gUmV0dXJuIGJ1aWx0IGVsZW1lbnRcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbi8vIEluc2VydCBhbiBlbGVtZW50IGFmdGVyIGFub3RoZXJcbmZ1bmN0aW9uIGluc2VydEFmdGVyKGVsZW1lbnQsIHRhcmdldCkge1xuICBpZiAoIWlzLmVsZW1lbnQoZWxlbWVudCkgfHwgIWlzLmVsZW1lbnQodGFyZ2V0KSkgcmV0dXJuO1xuICB0YXJnZXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgdGFyZ2V0Lm5leHRTaWJsaW5nKTtcbn1cblxuLy8gSW5zZXJ0IGEgRG9jdW1lbnRGcmFnbWVudFxuZnVuY3Rpb24gaW5zZXJ0RWxlbWVudCh0eXBlLCBwYXJlbnQsIGF0dHJpYnV0ZXMsIHRleHQpIHtcbiAgaWYgKCFpcy5lbGVtZW50KHBhcmVudCkpIHJldHVybjtcbiAgcGFyZW50LmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQodHlwZSwgYXR0cmlidXRlcywgdGV4dCkpO1xufVxuXG4vLyBSZW1vdmUgZWxlbWVudChzKVxuZnVuY3Rpb24gcmVtb3ZlRWxlbWVudChlbGVtZW50KSB7XG4gIGlmIChpcy5ub2RlTGlzdChlbGVtZW50KSB8fCBpcy5hcnJheShlbGVtZW50KSkge1xuICAgIEFycmF5LmZyb20oZWxlbWVudCkuZm9yRWFjaChyZW1vdmVFbGVtZW50KTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFpcy5lbGVtZW50KGVsZW1lbnQpIHx8ICFpcy5lbGVtZW50KGVsZW1lbnQucGFyZW50Tm9kZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xufVxuXG4vLyBSZW1vdmUgYWxsIGNoaWxkIGVsZW1lbnRzXG5mdW5jdGlvbiBlbXB0eUVsZW1lbnQoZWxlbWVudCkge1xuICBpZiAoIWlzLmVsZW1lbnQoZWxlbWVudCkpIHJldHVybjtcbiAgbGV0IHtcbiAgICBsZW5ndGhcbiAgfSA9IGVsZW1lbnQuY2hpbGROb2RlcztcbiAgd2hpbGUgKGxlbmd0aCA+IDApIHtcbiAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQubGFzdENoaWxkKTtcbiAgICBsZW5ndGggLT0gMTtcbiAgfVxufVxuXG4vLyBSZXBsYWNlIGVsZW1lbnRcbmZ1bmN0aW9uIHJlcGxhY2VFbGVtZW50KG5ld0NoaWxkLCBvbGRDaGlsZCkge1xuICBpZiAoIWlzLmVsZW1lbnQob2xkQ2hpbGQpIHx8ICFpcy5lbGVtZW50KG9sZENoaWxkLnBhcmVudE5vZGUpIHx8ICFpcy5lbGVtZW50KG5ld0NoaWxkKSkgcmV0dXJuIG51bGw7XG4gIG9sZENoaWxkLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld0NoaWxkLCBvbGRDaGlsZCk7XG4gIHJldHVybiBuZXdDaGlsZDtcbn1cblxuLy8gR2V0IGFuIGF0dHJpYnV0ZSBvYmplY3QgZnJvbSBhIHN0cmluZyBzZWxlY3RvclxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlc0Zyb21TZWxlY3RvcihzZWwsIGV4aXN0aW5nQXR0cmlidXRlcykge1xuICAvLyBGb3IgZXhhbXBsZTpcbiAgLy8gJy50ZXN0JyB0byB7IGNsYXNzOiAndGVzdCcgfVxuICAvLyAnI3Rlc3QnIHRvIHsgaWQ6ICd0ZXN0JyB9XG4gIC8vICdbZGF0YS10ZXN0PVwidGVzdFwiXScgdG8geyAnZGF0YS10ZXN0JzogJ3Rlc3QnIH1cblxuICBpZiAoIWlzLnN0cmluZyhzZWwpIHx8IGlzLmVtcHR5KHNlbCkpIHJldHVybiB7fTtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICBjb25zdCBleGlzdGluZyA9IGV4dGVuZCh7fSwgZXhpc3RpbmdBdHRyaWJ1dGVzKTtcbiAgc2VsLnNwbGl0KCcsJykuZm9yRWFjaChzID0+IHtcbiAgICAvLyBSZW1vdmUgd2hpdGVzcGFjZVxuICAgIGNvbnN0IHNlbGVjdG9yID0gcy50cmltKCk7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gc2VsZWN0b3IucmVwbGFjZSgnLicsICcnKTtcbiAgICBjb25zdCBzdHJpcHBlZCA9IHNlbGVjdG9yLnJlcGxhY2UoL1tbXFxdXS9nLCAnJyk7XG4gICAgLy8gR2V0IHRoZSBwYXJ0cyBhbmQgdmFsdWVcbiAgICBjb25zdCBwYXJ0cyA9IHN0cmlwcGVkLnNwbGl0KCc9Jyk7XG4gICAgY29uc3QgW2tleV0gPSBwYXJ0cztcbiAgICBjb25zdCB2YWx1ZSA9IHBhcnRzLmxlbmd0aCA+IDEgPyBwYXJ0c1sxXS5yZXBsYWNlKC9bXCInXS9nLCAnJykgOiAnJztcbiAgICAvLyBHZXQgdGhlIGZpcnN0IGNoYXJhY3RlclxuICAgIGNvbnN0IHN0YXJ0ID0gc2VsZWN0b3IuY2hhckF0KDApO1xuICAgIHN3aXRjaCAoc3RhcnQpIHtcbiAgICAgIGNhc2UgJy4nOlxuICAgICAgICAvLyBBZGQgdG8gZXhpc3RpbmcgY2xhc3NuYW1lXG4gICAgICAgIGlmIChpcy5zdHJpbmcoZXhpc3RpbmcuY2xhc3MpKSB7XG4gICAgICAgICAgYXR0cmlidXRlcy5jbGFzcyA9IGAke2V4aXN0aW5nLmNsYXNzfSAke2NsYXNzTmFtZX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF0dHJpYnV0ZXMuY2xhc3MgPSBjbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICcjJzpcbiAgICAgICAgLy8gSUQgc2VsZWN0b3JcbiAgICAgICAgYXR0cmlidXRlcy5pZCA9IHNlbGVjdG9yLnJlcGxhY2UoJyMnLCAnJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnWyc6XG4gICAgICAgIC8vIEF0dHJpYnV0ZSBzZWxlY3RvclxuICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGV4dGVuZChleGlzdGluZywgYXR0cmlidXRlcyk7XG59XG5cbi8vIFRvZ2dsZSBoaWRkZW5cbmZ1bmN0aW9uIHRvZ2dsZUhpZGRlbihlbGVtZW50LCBoaWRkZW4pIHtcbiAgaWYgKCFpcy5lbGVtZW50KGVsZW1lbnQpKSByZXR1cm47XG4gIGxldCBoaWRlID0gaGlkZGVuO1xuICBpZiAoIWlzLmJvb2xlYW4oaGlkZSkpIHtcbiAgICBoaWRlID0gIWVsZW1lbnQuaGlkZGVuO1xuICB9XG4gIGVsZW1lbnQuaGlkZGVuID0gaGlkZTtcbn1cblxuLy8gTWlycm9yIEVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZSwgd2l0aCBJRSBjb21wYXRpYmlsaXR5IGZvciBcImZvcmNlXCIgYXJndW1lbnRcbmZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSwgZm9yY2UpIHtcbiAgaWYgKGlzLm5vZGVMaXN0KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZWxlbWVudCkubWFwKGUgPT4gdG9nZ2xlQ2xhc3MoZSwgY2xhc3NOYW1lLCBmb3JjZSkpO1xuICB9XG4gIGlmIChpcy5lbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgbGV0IG1ldGhvZCA9ICd0b2dnbGUnO1xuICAgIGlmICh0eXBlb2YgZm9yY2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBtZXRob2QgPSBmb3JjZSA/ICdhZGQnIDogJ3JlbW92ZSc7XG4gICAgfVxuICAgIGVsZW1lbnQuY2xhc3NMaXN0W21ldGhvZF0oY2xhc3NOYW1lKTtcbiAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIEhhcyBjbGFzcyBuYW1lXG5mdW5jdGlvbiBoYXNDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgcmV0dXJuIGlzLmVsZW1lbnQoZWxlbWVudCkgJiYgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTtcbn1cblxuLy8gRWxlbWVudCBtYXRjaGVzIHNlbGVjdG9yXG5mdW5jdGlvbiBtYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gIGNvbnN0IHtcbiAgICBwcm90b3R5cGVcbiAgfSA9IEVsZW1lbnQ7XG4gIGZ1bmN0aW9uIG1hdGNoKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKS5pbmNsdWRlcyh0aGlzKTtcbiAgfVxuICBjb25zdCBtZXRob2QgPSBwcm90b3R5cGUubWF0Y2hlcyB8fCBwcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IHByb3RvdHlwZS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgcHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IG1hdGNoO1xuICByZXR1cm4gbWV0aG9kLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpO1xufVxuXG4vLyBDbG9zZXN0IGFuY2VzdG9yIGVsZW1lbnQgbWF0Y2hpbmcgc2VsZWN0b3IgKGFsc28gdGVzdHMgZWxlbWVudCBpdHNlbGYpXG5mdW5jdGlvbiBjbG9zZXN0JDEoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgY29uc3Qge1xuICAgIHByb3RvdHlwZVxuICB9ID0gRWxlbWVudDtcblxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9jbG9zZXN0I1BvbHlmaWxsXG4gIGZ1bmN0aW9uIGNsb3Nlc3RFbGVtZW50KCkge1xuICAgIGxldCBlbCA9IHRoaXM7XG4gICAgZG8ge1xuICAgICAgaWYgKG1hdGNoZXMubWF0Y2hlcyhlbCwgc2VsZWN0b3IpKSByZXR1cm4gZWw7XG4gICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQgfHwgZWwucGFyZW50Tm9kZTtcbiAgICB9IHdoaWxlIChlbCAhPT0gbnVsbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgbWV0aG9kID0gcHJvdG90eXBlLmNsb3Nlc3QgfHwgY2xvc2VzdEVsZW1lbnQ7XG4gIHJldHVybiBtZXRob2QuY2FsbChlbGVtZW50LCBzZWxlY3Rvcik7XG59XG5cbi8vIEZpbmQgYWxsIGVsZW1lbnRzXG5mdW5jdGlvbiBnZXRFbGVtZW50cyhzZWxlY3Rvcikge1xuICByZXR1cm4gdGhpcy5lbGVtZW50cy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG59XG5cbi8vIEZpbmQgYSBzaW5nbGUgZWxlbWVudFxuZnVuY3Rpb24gZ2V0RWxlbWVudChzZWxlY3Rvcikge1xuICByZXR1cm4gdGhpcy5lbGVtZW50cy5jb250YWluZXIucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG59XG5cbi8vIFNldCBmb2N1cyBhbmQgdGFiIGZvY3VzIGNsYXNzXG5mdW5jdGlvbiBzZXRGb2N1cyhlbGVtZW50ID0gbnVsbCwgZm9jdXNWaXNpYmxlID0gZmFsc2UpIHtcbiAgaWYgKCFpcy5lbGVtZW50KGVsZW1lbnQpKSByZXR1cm47XG5cbiAgLy8gU2V0IHJlZ3VsYXIgZm9jdXNcbiAgZWxlbWVudC5mb2N1cyh7XG4gICAgcHJldmVudFNjcm9sbDogdHJ1ZSxcbiAgICBmb2N1c1Zpc2libGVcbiAgfSk7XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBQbHlyIHN1cHBvcnQgY2hlY2tzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbi8vIERlZmF1bHQgY29kZWNzIGZvciBjaGVja2luZyBtaW1ldHlwZSBzdXBwb3J0XG5jb25zdCBkZWZhdWx0Q29kZWNzID0ge1xuICAnYXVkaW8vb2dnJzogJ3ZvcmJpcycsXG4gICdhdWRpby93YXYnOiAnMScsXG4gICd2aWRlby93ZWJtJzogJ3ZwOCwgdm9yYmlzJyxcbiAgJ3ZpZGVvL21wNCc6ICdhdmMxLjQyRTAxRSwgbXA0YS40MC4yJyxcbiAgJ3ZpZGVvL29nZyc6ICd0aGVvcmEnXG59O1xuXG4vLyBDaGVjayBmb3IgZmVhdHVyZSBzdXBwb3J0XG5jb25zdCBzdXBwb3J0ID0ge1xuICAvLyBCYXNpYyBzdXBwb3J0XG4gIGF1ZGlvOiAnY2FuUGxheVR5cGUnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2F1ZGlvJyksXG4gIHZpZGVvOiAnY2FuUGxheVR5cGUnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyksXG4gIC8vIENoZWNrIGZvciBzdXBwb3J0XG4gIC8vIEJhc2ljIGZ1bmN0aW9uYWxpdHkgdnMgZnVsbCBVSVxuICBjaGVjayh0eXBlLCBwcm92aWRlcikge1xuICAgIGNvbnN0IGFwaSA9IHN1cHBvcnRbdHlwZV0gfHwgcHJvdmlkZXIgIT09ICdodG1sNSc7XG4gICAgY29uc3QgdWkgPSBhcGkgJiYgc3VwcG9ydC5yYW5nZUlucHV0O1xuICAgIHJldHVybiB7XG4gICAgICBhcGksXG4gICAgICB1aVxuICAgIH07XG4gIH0sXG4gIC8vIFBpY3R1cmUtaW4tcGljdHVyZSBzdXBwb3J0XG4gIHBpcDogKCgpID0+IHtcbiAgICByZXR1cm4gZG9jdW1lbnQucGljdHVyZUluUGljdHVyZUVuYWJsZWQgJiYgIWNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJykuZGlzYWJsZVBpY3R1cmVJblBpY3R1cmU7XG4gIH0pKCksXG4gIC8vIEFpcnBsYXkgc3VwcG9ydFxuICAvLyBTYWZhcmkgb25seSBjdXJyZW50bHlcbiAgYWlycGxheTogaXMuZnVuY3Rpb24od2luZG93LldlYktpdFBsYXliYWNrVGFyZ2V0QXZhaWxhYmlsaXR5RXZlbnQpLFxuICAvLyBJbmxpbmUgcGxheWJhY2sgc3VwcG9ydFxuICAvLyBodHRwczovL3dlYmtpdC5vcmcvYmxvZy82Nzg0L25ldy12aWRlby1wb2xpY2llcy1mb3ItaW9zL1xuICBwbGF5c2lubGluZTogJ3BsYXlzSW5saW5lJyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpLFxuICAvLyBDaGVjayBmb3IgbWltZSB0eXBlIHN1cHBvcnQgYWdhaW5zdCBhIHBsYXllciBpbnN0YW5jZVxuICAvLyBDcmVkaXRzOiBodHRwOi8vZGl2ZWludG9odG1sNS5pbmZvL2V2ZXJ5dGhpbmcuaHRtbFxuICAvLyBSZWxhdGVkOiBodHRwOi8vd3d3LmxlYW5iYWNrcGxheWVyLmNvbS90ZXN0L2g1bXQuaHRtbFxuICBtaW1lKGlucHV0KSB7XG4gICAgaWYgKGlzLmVtcHR5KGlucHV0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBbbWVkaWFUeXBlXSA9IGlucHV0LnNwbGl0KCcvJyk7XG4gICAgbGV0IHR5cGUgPSBpbnB1dDtcblxuICAgIC8vIFZlcmlmeSB3ZSdyZSB1c2luZyBIVE1MNSBhbmQgdGhlcmUncyBubyBtZWRpYSB0eXBlIG1pc21hdGNoXG4gICAgaWYgKCF0aGlzLmlzSFRNTDUgfHwgbWVkaWFUeXBlICE9PSB0aGlzLnR5cGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBBZGQgY29kZWMgaWYgcmVxdWlyZWRcbiAgICBpZiAoT2JqZWN0LmtleXMoZGVmYXVsdENvZGVjcykuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgIHR5cGUgKz0gYDsgY29kZWNzPVwiJHtkZWZhdWx0Q29kZWNzW2lucHV0XX1cImA7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gQm9vbGVhbih0eXBlICYmIHRoaXMubWVkaWEuY2FuUGxheVR5cGUodHlwZSkucmVwbGFjZSgvbm8vLCAnJykpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcbiAgLy8gQ2hlY2sgZm9yIHRleHRUcmFja3Mgc3VwcG9ydFxuICB0ZXh0VHJhY2tzOiAndGV4dFRyYWNrcycgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKSxcbiAgLy8gPGlucHV0IHR5cGU9XCJyYW5nZVwiPiBTbGlkZXJzXG4gIHJhbmdlSW5wdXQ6ICgoKSA9PiB7XG4gICAgY29uc3QgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIHJhbmdlLnR5cGUgPSAncmFuZ2UnO1xuICAgIHJldHVybiByYW5nZS50eXBlID09PSAncmFuZ2UnO1xuICB9KSgpLFxuICAvLyBUb3VjaFxuICAvLyBOT1RFOiBSZW1lbWJlciBhIGRldmljZSBjYW4gYmUgbW91c2UgKyB0b3VjaCBlbmFibGVkIHNvIHdlIGNoZWNrIG9uIGZpcnN0IHRvdWNoIGV2ZW50XG4gIHRvdWNoOiAnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gIC8vIERldGVjdCB0cmFuc2l0aW9ucyBzdXBwb3J0XG4gIHRyYW5zaXRpb25zOiB0cmFuc2l0aW9uRW5kRXZlbnQgIT09IGZhbHNlLFxuICAvLyBSZWR1Y2VkIG1vdGlvbiBpT1MgJiBNYWNPUyBzZXR0aW5nXG4gIC8vIGh0dHBzOi8vd2Via2l0Lm9yZy9ibG9nLzc1NTEvcmVzcG9uc2l2ZS1kZXNpZ24tZm9yLW1vdGlvbi9cbiAgcmVkdWNlZE1vdGlvbjogJ21hdGNoTWVkaWEnIGluIHdpbmRvdyAmJiB3aW5kb3cubWF0Y2hNZWRpYSgnKHByZWZlcnMtcmVkdWNlZC1tb3Rpb24pJykubWF0Y2hlc1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEV2ZW50IHV0aWxzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbi8vIENoZWNrIGZvciBwYXNzaXZlIGV2ZW50IGxpc3RlbmVyIHN1cHBvcnRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL0V2ZW50TGlzdGVuZXJPcHRpb25zL2Jsb2IvZ2gtcGFnZXMvZXhwbGFpbmVyLm1kXG4vLyBodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PU5QTTYxNzJKMjJnXG5jb25zdCBzdXBwb3J0c1Bhc3NpdmVMaXN0ZW5lcnMgPSAoKCkgPT4ge1xuICAvLyBUZXN0IHZpYSBhIGdldHRlciBpbiB0aGUgb3B0aW9ucyBvYmplY3QgdG8gc2VlIGlmIHRoZSBwYXNzaXZlIHByb3BlcnR5IGlzIGFjY2Vzc2VkXG4gIGxldCBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdGlvbnMpO1xuICB9IGNhdGNoIHt9XG4gIHJldHVybiBzdXBwb3J0ZWQ7XG59KSgpO1xuXG4vLyBUb2dnbGUgZXZlbnQgbGlzdGVuZXJcbmZ1bmN0aW9uIHRvZ2dsZUxpc3RlbmVyKGVsZW1lbnQsIGV2ZW50LCBjYWxsYmFjaywgdG9nZ2xlID0gZmFsc2UsIHBhc3NpdmUgPSB0cnVlLCBjYXB0dXJlID0gZmFsc2UpIHtcbiAgLy8gQmFpbCBpZiBubyBlbGVtZW50LCBldmVudCwgb3IgY2FsbGJhY2tcbiAgaWYgKCFlbGVtZW50IHx8ICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGVsZW1lbnQpIHx8IGlzLmVtcHR5KGV2ZW50KSB8fCAhaXMuZnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQWxsb3cgbXVsdGlwbGUgZXZlbnRzXG4gIGNvbnN0IGV2ZW50cyA9IGV2ZW50LnNwbGl0KCcgJyk7XG4gIC8vIEJ1aWxkIG9wdGlvbnNcbiAgLy8gRGVmYXVsdCB0byBqdXN0IHRoZSBjYXB0dXJlIGJvb2xlYW4gZm9yIGJyb3dzZXJzIHdpdGggbm8gcGFzc2l2ZSBsaXN0ZW5lciBzdXBwb3J0XG4gIGxldCBvcHRpb25zID0gY2FwdHVyZTtcblxuICAvLyBJZiBwYXNzaXZlIGV2ZW50cyBsaXN0ZW5lcnMgYXJlIHN1cHBvcnRlZFxuICBpZiAoc3VwcG9ydHNQYXNzaXZlTGlzdGVuZXJzKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIC8vIFdoZXRoZXIgdGhlIGxpc3RlbmVyIGNhbiBiZSBwYXNzaXZlIChpLmUuIGRlZmF1bHQgbmV2ZXIgcHJldmVudGVkKVxuICAgICAgcGFzc2l2ZSxcbiAgICAgIC8vIFdoZXRoZXIgdGhlIGxpc3RlbmVyIGlzIGEgY2FwdHVyaW5nIGxpc3RlbmVyIG9yIG5vdFxuICAgICAgY2FwdHVyZVxuICAgIH07XG4gIH1cblxuICAvLyBJZiBhIHNpbmdsZSBub2RlIGlzIHBhc3NlZCwgYmluZCB0aGUgZXZlbnQgbGlzdGVuZXJcbiAgZXZlbnRzLmZvckVhY2godHlwZSA9PiB7XG4gICAgaWYgKHRoaXMgJiYgdGhpcy5ldmVudExpc3RlbmVycyAmJiB0b2dnbGUpIHtcbiAgICAgIC8vIENhY2hlIGV2ZW50IGxpc3RlbmVyXG4gICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLnB1c2goe1xuICAgICAgICBlbGVtZW50LFxuICAgICAgICB0eXBlLFxuICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGVsZW1lbnRbdG9nZ2xlID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInXSh0eXBlLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gIH0pO1xufVxuXG4vLyBCaW5kIGV2ZW50IGhhbmRsZXJcbmZ1bmN0aW9uIG9uKGVsZW1lbnQsIGV2ZW50cyA9ICcnLCBjYWxsYmFjaywgcGFzc2l2ZSA9IHRydWUsIGNhcHR1cmUgPSBmYWxzZSkge1xuICB0b2dnbGVMaXN0ZW5lci5jYWxsKHRoaXMsIGVsZW1lbnQsIGV2ZW50cywgY2FsbGJhY2ssIHRydWUsIHBhc3NpdmUsIGNhcHR1cmUpO1xufVxuXG4vLyBVbmJpbmQgZXZlbnQgaGFuZGxlclxuZnVuY3Rpb24gb2ZmKGVsZW1lbnQsIGV2ZW50cyA9ICcnLCBjYWxsYmFjaywgcGFzc2l2ZSA9IHRydWUsIGNhcHR1cmUgPSBmYWxzZSkge1xuICB0b2dnbGVMaXN0ZW5lci5jYWxsKHRoaXMsIGVsZW1lbnQsIGV2ZW50cywgY2FsbGJhY2ssIGZhbHNlLCBwYXNzaXZlLCBjYXB0dXJlKTtcbn1cblxuLy8gQmluZCBvbmNlLW9ubHkgZXZlbnQgaGFuZGxlclxuZnVuY3Rpb24gb25jZShlbGVtZW50LCBldmVudHMgPSAnJywgY2FsbGJhY2ssIHBhc3NpdmUgPSB0cnVlLCBjYXB0dXJlID0gZmFsc2UpIHtcbiAgY29uc3Qgb25jZUNhbGxiYWNrID0gKC4uLmFyZ3MpID0+IHtcbiAgICBvZmYoZWxlbWVudCwgZXZlbnRzLCBvbmNlQ2FsbGJhY2ssIHBhc3NpdmUsIGNhcHR1cmUpO1xuICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9O1xuICB0b2dnbGVMaXN0ZW5lci5jYWxsKHRoaXMsIGVsZW1lbnQsIGV2ZW50cywgb25jZUNhbGxiYWNrLCB0cnVlLCBwYXNzaXZlLCBjYXB0dXJlKTtcbn1cblxuLy8gVHJpZ2dlciBldmVudFxuZnVuY3Rpb24gdHJpZ2dlckV2ZW50KGVsZW1lbnQsIHR5cGUgPSAnJywgYnViYmxlcyA9IGZhbHNlLCBkZXRhaWwgPSB7fSkge1xuICAvLyBCYWlsIGlmIG5vIGVsZW1lbnRcbiAgaWYgKCFpcy5lbGVtZW50KGVsZW1lbnQpIHx8IGlzLmVtcHR5KHR5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGFuZCBkaXNwYXRjaCB0aGUgZXZlbnRcbiAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQodHlwZSwge1xuICAgIGJ1YmJsZXMsXG4gICAgZGV0YWlsOiB7XG4gICAgICAuLi5kZXRhaWwsXG4gICAgICBwbHlyOiB0aGlzXG4gICAgfVxuICB9KTtcblxuICAvLyBEaXNwYXRjaCB0aGUgZXZlbnRcbiAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn1cblxuLy8gVW5iaW5kIGFsbCBjYWNoZWQgZXZlbnQgbGlzdGVuZXJzXG5mdW5jdGlvbiB1bmJpbmRMaXN0ZW5lcnMoKSB7XG4gIGlmICh0aGlzICYmIHRoaXMuZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9ID0gaXRlbTtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgfSk7XG4gICAgdGhpcy5ldmVudExpc3RlbmVycyA9IFtdO1xuICB9XG59XG5cbi8vIFJ1biBtZXRob2Qgd2hlbiAvIGlmIHBsYXllciBpcyByZWFkeVxuZnVuY3Rpb24gcmVhZHkoKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHRoaXMucmVhZHkgPyBzZXRUaW1lb3V0KHJlc29sdmUsIDApIDogb24uY2FsbCh0aGlzLCB0aGlzLmVsZW1lbnRzLmNvbnRhaW5lciwgJ3JlYWR5JywgcmVzb2x2ZSkpLnRoZW4oKCkgPT4ge30pO1xufVxuXG4vKipcbiAqIFNpbGVuY2UgYSBQcm9taXNlLWxpa2Ugb2JqZWN0LlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIGF2b2lkaW5nIG5vbi1oYXJtZnVsLCBidXQgcG90ZW50aWFsbHkgY29uZnVzaW5nIFwidW5jYXVnaHRcbiAqIHBsYXkgcHJvbWlzZVwiIHJlamVjdGlvbiBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSAge29iamVjdH0gdmFsdWUgQW4gb2JqZWN0IHRoYXQgbWF5IG9yIG1heSBub3QgYmUgYFByb21pc2VgLWxpa2UuXG4gKi9cbmZ1bmN0aW9uIHNpbGVuY2VQcm9taXNlKHZhbHVlKSB7XG4gIGlmIChpcy5wcm9taXNlKHZhbHVlKSkge1xuICAgIHZhbHVlLnRoZW4obnVsbCwgKCkgPT4ge30pO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBBcnJheSB1dGlsc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4vLyBSZW1vdmUgZHVwbGljYXRlcyBpbiBhbiBhcnJheVxuZnVuY3Rpb24gZGVkdXBlKGFycmF5KSB7XG4gIGlmICghaXMuYXJyYXkoYXJyYXkpKSB7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG4gIHJldHVybiBhcnJheS5maWx0ZXIoKGl0ZW0sIGluZGV4KSA9PiBhcnJheS5pbmRleE9mKGl0ZW0pID09PSBpbmRleCk7XG59XG5cbi8vIEdldCB0aGUgY2xvc2VzdCB2YWx1ZSBpbiBhbiBhcnJheVxuZnVuY3Rpb24gY2xvc2VzdChhcnJheSwgdmFsdWUpIHtcbiAgaWYgKCFpcy5hcnJheShhcnJheSkgfHwgIWFycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBhcnJheS5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IE1hdGguYWJzKGN1cnIgLSB2YWx1ZSkgPCBNYXRoLmFicyhwcmV2IC0gdmFsdWUpID8gY3VyciA6IHByZXYpO1xufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU3R5bGUgdXRpbHNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuLy8gQ2hlY2sgc3VwcG9ydCBmb3IgYSBDU1MgZGVjbGFyYXRpb25cbmZ1bmN0aW9uIHN1cHBvcnRzQ1NTKGRlY2xhcmF0aW9uKSB7XG4gIGlmICghd2luZG93IHx8ICF3aW5kb3cuQ1NTKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB3aW5kb3cuQ1NTLnN1cHBvcnRzKGRlY2xhcmF0aW9uKTtcbn1cblxuLy8gU3RhbmRhcmQvY29tbW9uIGFzcGVjdCByYXRpb3NcbmNvbnN0IHN0YW5kYXJkUmF0aW9zID0gW1sxLCAxXSwgWzQsIDNdLCBbMywgNF0sIFs1LCA0XSwgWzQsIDVdLCBbMywgMl0sIFsyLCAzXSwgWzE2LCAxMF0sIFsxMCwgMTZdLCBbMTYsIDldLCBbOSwgMTZdLCBbMjEsIDldLCBbOSwgMjFdLCBbMzIsIDldLCBbOSwgMzJdXS5yZWR1Y2UoKG91dCwgW3gsIHldKSA9PiAoe1xuICAuLi5vdXQsXG4gIFt4IC8geV06IFt4LCB5XVxufSksIHt9KTtcblxuLy8gVmFsaWRhdGUgYW4gYXNwZWN0IHJhdGlvXG5mdW5jdGlvbiB2YWxpZGF0ZUFzcGVjdFJhdGlvKGlucHV0KSB7XG4gIGlmICghaXMuYXJyYXkoaW5wdXQpICYmICghaXMuc3RyaW5nKGlucHV0KSB8fCAhaW5wdXQuaW5jbHVkZXMoJzonKSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgcmF0aW8gPSBpcy5hcnJheShpbnB1dCkgPyBpbnB1dCA6IGlucHV0LnNwbGl0KCc6Jyk7XG4gIHJldHVybiByYXRpby5tYXAoTnVtYmVyKS5ldmVyeShpcy5udW1iZXIpO1xufVxuXG4vLyBSZWR1Y2UgYW4gYXNwZWN0IHJhdGlvIHRvIGl0J3MgbG93ZXN0IGZvcm1cbmZ1bmN0aW9uIHJlZHVjZUFzcGVjdFJhdGlvKHJhdGlvKSB7XG4gIGlmICghaXMuYXJyYXkocmF0aW8pIHx8ICFyYXRpby5ldmVyeShpcy5udW1iZXIpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gcmF0aW87XG4gIGNvbnN0IGdldERpdmlkZXIgPSAodywgaCkgPT4gaCA9PT0gMCA/IHcgOiBnZXREaXZpZGVyKGgsIHcgJSBoKTtcbiAgY29uc3QgZGl2aWRlciA9IGdldERpdmlkZXIod2lkdGgsIGhlaWdodCk7XG4gIHJldHVybiBbd2lkdGggLyBkaXZpZGVyLCBoZWlnaHQgLyBkaXZpZGVyXTtcbn1cblxuLy8gQ2FsY3VsYXRlIGFuIGFzcGVjdCByYXRpb1xuZnVuY3Rpb24gZ2V0QXNwZWN0UmF0aW8oaW5wdXQpIHtcbiAgY29uc3QgcGFyc2UgPSByYXRpbyA9PiB2YWxpZGF0ZUFzcGVjdFJhdGlvKHJhdGlvKSA/IHJhdGlvLnNwbGl0KCc6JykubWFwKE51bWJlcikgOiBudWxsO1xuICAvLyBUcnkgcHJvdmlkZWQgcmF0aW9cbiAgbGV0IHJhdGlvID0gcGFyc2UoaW5wdXQpO1xuXG4gIC8vIEdldCBmcm9tIGNvbmZpZ1xuICBpZiAocmF0aW8gPT09IG51bGwpIHtcbiAgICByYXRpbyA9IHBhcnNlKHRoaXMuY29uZmlnLnJhdGlvKTtcbiAgfVxuXG4gIC8vIEdldCBmcm9tIGVtYmVkXG4gIGlmIChyYXRpbyA9PT0gbnVsbCAmJiAhaXMuZW1wdHkodGhpcy5lbWJlZCkgJiYgaXMuYXJyYXkodGhpcy5lbWJlZC5yYXRpbykpIHtcbiAgICAoe1xuICAgICAgcmF0aW9cbiAgICB9ID0gdGhpcy5lbWJlZCk7XG4gIH1cblxuICAvLyBHZXQgZnJvbSBIVE1MNSB2aWRlb1xuICBpZiAocmF0aW8gPT09IG51bGwgJiYgdGhpcy5pc0hUTUw1KSB7XG4gICAgY29uc3Qge1xuICAgICAgdmlkZW9XaWR0aCxcbiAgICAgIHZpZGVvSGVpZ2h0XG4gICAgfSA9IHRoaXMubWVkaWE7XG4gICAgcmF0aW8gPSBbdmlkZW9XaWR0aCwgdmlkZW9IZWlnaHRdO1xuICB9XG4gIHJldHVybiByZWR1Y2VBc3BlY3RSYXRpbyhyYXRpbyk7XG59XG5cbi8vIFNldCBhc3BlY3QgcmF0aW8gZm9yIHJlc3BvbnNpdmUgY29udGFpbmVyXG5mdW5jdGlvbiBzZXRBc3BlY3RSYXRpbyhpbnB1dCkge1xuICBpZiAoIXRoaXMuaXNWaWRlbykge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgd3JhcHBlclxuICB9ID0gdGhpcy5lbGVtZW50cztcbiAgY29uc3QgcmF0aW8gPSBnZXRBc3BlY3RSYXRpby5jYWxsKHRoaXMsIGlucHV0KTtcbiAgaWYgKCFpcy5hcnJheShyYXRpbykpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgW3gsIHldID0gcmVkdWNlQXNwZWN0UmF0aW8ocmF0aW8pO1xuICBjb25zdCB1c2VOYXRpdmUgPSBzdXBwb3J0c0NTUyhgYXNwZWN0LXJhdGlvOiAke3h9LyR7eX1gKTtcbiAgY29uc3QgcGFkZGluZyA9IDEwMCAvIHggKiB5O1xuICBpZiAodXNlTmF0aXZlKSB7XG4gICAgd3JhcHBlci5zdHlsZS5hc3BlY3RSYXRpbyA9IGAke3h9LyR7eX1gO1xuICB9IGVsc2Uge1xuICAgIHdyYXBwZXIuc3R5bGUucGFkZGluZ0JvdHRvbSA9IGAke3BhZGRpbmd9JWA7XG4gIH1cblxuICAvLyBGb3IgVmltZW8gd2UgaGF2ZSBhbiBleHRyYSA8ZGl2PiB0byBoaWRlIHRoZSBzdGFuZGFyZCBjb250cm9scyBhbmQgVUlcbiAgaWYgKHRoaXMuaXNWaW1lbyAmJiAhdGhpcy5jb25maWcudmltZW8ucHJlbWl1bSAmJiB0aGlzLnN1cHBvcnRlZC51aSkge1xuICAgIGNvbnN0IGhlaWdodCA9IDEwMCAvIHRoaXMubWVkaWEub2Zmc2V0V2lkdGggKiBOdW1iZXIucGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5tZWRpYSkucGFkZGluZ0JvdHRvbSwgMTApO1xuICAgIGNvbnN0IG9mZnNldCA9IChoZWlnaHQgLSBwYWRkaW5nKSAvIChoZWlnaHQgLyA1MCk7XG4gICAgaWYgKHRoaXMuZnVsbHNjcmVlbi5hY3RpdmUpIHtcbiAgICAgIHdyYXBwZXIuc3R5bGUucGFkZGluZ0JvdHRvbSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVkaWEuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVkoLSR7b2Zmc2V0fSUpYDtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5pc0hUTUw1KSB7XG4gICAgd3JhcHBlci5jbGFzc0xpc3QuYWRkKHRoaXMuY29uZmlnLmNsYXNzTmFtZXMudmlkZW9GaXhlZFJhdGlvKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHBhZGRpbmcsXG4gICAgcmF0aW9cbiAgfTtcbn1cblxuLy8gUm91bmQgYW4gYXNwZWN0IHJhdGlvIHRvIGNsb3Nlc3Qgc3RhbmRhcmQgcmF0aW9cbmZ1bmN0aW9uIHJvdW5kQXNwZWN0UmF0aW8oeCwgeSwgdG9sZXJhbmNlID0gMC4wNSkge1xuICBjb25zdCByYXRpbyA9IHggLyB5O1xuICBjb25zdCBjbG9zZXN0UmF0aW8gPSBjbG9zZXN0KE9iamVjdC5rZXlzKHN0YW5kYXJkUmF0aW9zKSwgcmF0aW8pO1xuXG4gIC8vIENoZWNrIG1hdGNoIGlzIHdpdGhpbiB0b2xlcmFuY2VcbiAgaWYgKE1hdGguYWJzKGNsb3Nlc3RSYXRpbyAtIHJhdGlvKSA8PSB0b2xlcmFuY2UpIHtcbiAgICByZXR1cm4gc3RhbmRhcmRSYXRpb3NbY2xvc2VzdFJhdGlvXTtcbiAgfVxuXG4gIC8vIE5vIG1hdGNoXG4gIHJldHVybiBbeCwgeV07XG59XG5cbi8vIEdldCB0aGUgc2l6ZSBvZiB0aGUgdmlld3BvcnRcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyNDgwODEvaG93LXRvLWdldC10aGUtYnJvd3Nlci12aWV3cG9ydC1kaW1lbnNpb25zXG5mdW5jdGlvbiBnZXRWaWV3cG9ydFNpemUoKSB7XG4gIGNvbnN0IHdpZHRoID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIHx8IDAsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICBjb25zdCBoZWlnaHQgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IDAsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcbiAgcmV0dXJuIFt3aWR0aCwgaGVpZ2h0XTtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFBseXIgSFRNTDUgaGVscGVyc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgaHRtbDUgPSB7XG4gIGdldFNvdXJjZXMoKSB7XG4gICAgaWYgKCF0aGlzLmlzSFRNTDUpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlcyA9IEFycmF5LmZyb20odGhpcy5tZWRpYS5xdWVyeVNlbGVjdG9yQWxsKCdzb3VyY2UnKSk7XG5cbiAgICAvLyBGaWx0ZXIgb3V0IHVuc3VwcG9ydGVkIHNvdXJjZXMgKGlmIHR5cGUgaXMgc3BlY2lmaWVkKVxuICAgIHJldHVybiBzb3VyY2VzLmZpbHRlcihzb3VyY2UgPT4ge1xuICAgICAgY29uc3QgdHlwZSA9IHNvdXJjZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgIGlmIChpcy5lbXB0eSh0eXBlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdXBwb3J0Lm1pbWUuY2FsbCh0aGlzLCB0eXBlKTtcbiAgICB9KTtcbiAgfSxcbiAgLy8gR2V0IHF1YWxpdHkgbGV2ZWxzXG4gIGdldFF1YWxpdHlPcHRpb25zKCkge1xuICAgIC8vIFdoZXRoZXIgd2UncmUgZm9yY2luZyBhbGwgb3B0aW9ucyAoZS5nLiBmb3Igc3RyZWFtaW5nKVxuICAgIGlmICh0aGlzLmNvbmZpZy5xdWFsaXR5LmZvcmNlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnF1YWxpdHkub3B0aW9ucztcbiAgICB9XG5cbiAgICAvLyBHZXQgc2l6ZXMgZnJvbSA8c291cmNlPiBlbGVtZW50c1xuICAgIHJldHVybiBodG1sNS5nZXRTb3VyY2VzLmNhbGwodGhpcykubWFwKHNvdXJjZSA9PiBOdW1iZXIoc291cmNlLmdldEF0dHJpYnV0ZSgnc2l6ZScpKSkuZmlsdGVyKEJvb2xlYW4pO1xuICB9LFxuICBzZXR1cCgpIHtcbiAgICBpZiAoIXRoaXMuaXNIVE1MNSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwbGF5ZXIgPSB0aGlzO1xuXG4gICAgLy8gU2V0IHNwZWVkIG9wdGlvbnMgZnJvbSBjb25maWdcbiAgICBwbGF5ZXIub3B0aW9ucy5zcGVlZCA9IHBsYXllci5jb25maWcuc3BlZWQub3B0aW9ucztcblxuICAgIC8vIFNldCBhc3BlY3QgcmF0aW8gaWYgZml4ZWRcbiAgICBpZiAoIWlzLmVtcHR5KHRoaXMuY29uZmlnLnJhdGlvKSkge1xuICAgICAgc2V0QXNwZWN0UmF0aW8uY2FsbChwbGF5ZXIpO1xuICAgIH1cblxuICAgIC8vIFF1YWxpdHlcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGxheWVyLm1lZGlhLCAncXVhbGl0eScsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgLy8gR2V0IHNvdXJjZXNcbiAgICAgICAgY29uc3Qgc291cmNlcyA9IGh0bWw1LmdldFNvdXJjZXMuY2FsbChwbGF5ZXIpO1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzLmZpbmQocyA9PiBzLmdldEF0dHJpYnV0ZSgnc3JjJykgPT09IHBsYXllci5zb3VyY2UpO1xuXG4gICAgICAgIC8vIFJldHVybiBzaXplLCBpZiBtYXRjaCBpcyBmb3VuZFxuICAgICAgICByZXR1cm4gc291cmNlICYmIE51bWJlcihzb3VyY2UuZ2V0QXR0cmlidXRlKCdzaXplJykpO1xuICAgICAgfSxcbiAgICAgIHNldChpbnB1dCkge1xuICAgICAgICBpZiAocGxheWVyLnF1YWxpdHkgPT09IGlucHV0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UncmUgdXNpbmcgYW4gZXh0ZXJuYWwgaGFuZGxlci4uLlxuICAgICAgICBpZiAocGxheWVyLmNvbmZpZy5xdWFsaXR5LmZvcmNlZCAmJiBpcy5mdW5jdGlvbihwbGF5ZXIuY29uZmlnLnF1YWxpdHkub25DaGFuZ2UpKSB7XG4gICAgICAgICAgcGxheWVyLmNvbmZpZy5xdWFsaXR5Lm9uQ2hhbmdlKGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBHZXQgc291cmNlc1xuICAgICAgICAgIGNvbnN0IHNvdXJjZXMgPSBodG1sNS5nZXRTb3VyY2VzLmNhbGwocGxheWVyKTtcbiAgICAgICAgICAvLyBHZXQgZmlyc3QgbWF0Y2ggZm9yIHJlcXVlc3RlZCBzaXplXG4gICAgICAgICAgY29uc3Qgc291cmNlID0gc291cmNlcy5maW5kKHMgPT4gTnVtYmVyKHMuZ2V0QXR0cmlidXRlKCdzaXplJykpID09PSBpbnB1dCk7XG5cbiAgICAgICAgICAvLyBObyBtYXRjaGluZyBzb3VyY2UgZm91bmRcbiAgICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEdldCBjdXJyZW50IHN0YXRlXG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY3VycmVudFRpbWUsXG4gICAgICAgICAgICBwYXVzZWQsXG4gICAgICAgICAgICBwcmVsb2FkLFxuICAgICAgICAgICAgcmVhZHlTdGF0ZSxcbiAgICAgICAgICAgIHBsYXliYWNrUmF0ZVxuICAgICAgICAgIH0gPSBwbGF5ZXIubWVkaWE7XG5cbiAgICAgICAgICAvLyBTZXQgbmV3IHNvdXJjZVxuICAgICAgICAgIHBsYXllci5tZWRpYS5zcmMgPSBzb3VyY2UuZ2V0QXR0cmlidXRlKCdzcmMnKTtcblxuICAgICAgICAgIC8vIFByZXZlbnQgbG9hZGluZyBpZiBwcmVsb2FkPVwibm9uZVwiIGFuZCB0aGUgY3VycmVudCBzb3VyY2UgaXNuJ3QgbG9hZGVkICgjMTA0NClcbiAgICAgICAgICBpZiAocHJlbG9hZCAhPT0gJ25vbmUnIHx8IHJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIC8vIFJlc3RvcmUgdGltZVxuICAgICAgICAgICAgcGxheWVyLm9uY2UoJ2xvYWRlZG1ldGFkYXRhJywgKCkgPT4ge1xuICAgICAgICAgICAgICBwbGF5ZXIuc3BlZWQgPSBwbGF5YmFja1JhdGU7XG4gICAgICAgICAgICAgIHBsYXllci5jdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xuXG4gICAgICAgICAgICAgIC8vIFJlc3VtZSBwbGF5aW5nXG4gICAgICAgICAgICAgIGlmICghcGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgc2lsZW5jZVByb21pc2UocGxheWVyLnBsYXkoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBMb2FkIG5ldyBzb3VyY2VcbiAgICAgICAgICAgIHBsYXllci5tZWRpYS5sb2FkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJpZ2dlciBjaGFuZ2UgZXZlbnRcbiAgICAgICAgdHJpZ2dlckV2ZW50LmNhbGwocGxheWVyLCBwbGF5ZXIubWVkaWEsICdxdWFsaXR5Y2hhbmdlJywgZmFsc2UsIHtcbiAgICAgICAgICBxdWFsaXR5OiBpbnB1dFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgLy8gQ2FuY2VsIGN1cnJlbnQgbmV0d29yayByZXF1ZXN0c1xuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NhbXBvdHRzL3BseXIvaXNzdWVzLzE3NFxuICBjYW5jZWxSZXF1ZXN0cygpIHtcbiAgICBpZiAoIXRoaXMuaXNIVE1MNSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBjaGlsZCBzb3VyY2VzXG4gICAgcmVtb3ZlRWxlbWVudChodG1sNS5nZXRTb3VyY2VzLmNhbGwodGhpcykpO1xuXG4gICAgLy8gU2V0IGJsYW5rIHZpZGVvIHNyYyBhdHRyaWJ1dGVcbiAgICAvLyBUaGlzIGlzIHRvIHByZXZlbnQgYSBNRURJQV9FUlJfU1JDX05PVF9TVVBQT1JURUQgZXJyb3JcbiAgICAvLyBJbmZvOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMyMjMxNTc5L2hvdy10by1wcm9wZXJseS1kaXNwb3NlLW9mLWFuLWh0bWw1LXZpZGVvLWFuZC1jbG9zZS1zb2NrZXQtb3ItY29ubmVjdGlvblxuICAgIHRoaXMubWVkaWEuc2V0QXR0cmlidXRlKCdzcmMnLCB0aGlzLmNvbmZpZy5ibGFua1ZpZGVvKTtcblxuICAgIC8vIExvYWQgdGhlIG5ldyBlbXB0eSBzb3VyY2VcbiAgICAvLyBUaGlzIHdpbGwgY2FuY2VsIGV4aXN0aW5nIHJlcXVlc3RzXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zYW1wb3R0cy9wbHlyL2lzc3Vlcy8xNzRcbiAgICB0aGlzLm1lZGlhLmxvYWQoKTtcblxuICAgIC8vIERlYnVnZ2luZ1xuICAgIHRoaXMuZGVidWcubG9nKCdDYW5jZWxsZWQgbmV0d29yayByZXF1ZXN0cycpO1xuICB9XG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gQnJvd3NlciBzbmlmZmluZ1xuLy8gVW5mb3J0dW5hdGVseSwgZHVlIHRvIG1peGVkIHN1cHBvcnQsIFVBIHNuaWZmaW5nIGlzIHJlcXVpcmVkXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBpc0lFID0gQm9vbGVhbih3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTtcbmNvbnN0IGlzRWRnZSA9IC9FZGdlLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgaXNXZWJLaXQgPSAnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmICEvRWRnZS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbi8vIG5hdmlnYXRvci5wbGF0Zm9ybSBtYXkgYmUgZGVwcmVjYXRlZCBidXQgdGhpcyBjaGVjayBpcyBzdGlsbCByZXF1aXJlZFxuY29uc3QgaXNJUGFkT1MgPSBuYXZpZ2F0b3IucGxhdGZvcm0gPT09ICdNYWNJbnRlbCcgJiYgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMTtcbmNvbnN0IGlzSW9zID0gL2lQYWR8aVBob25lfGlQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDE7XG52YXIgYnJvd3NlciA9IHtcbiAgaXNJRSxcbiAgaXNFZGdlLFxuICBpc1dlYktpdCxcbiAgaXNJUGFkT1MsXG4gIGlzSW9zXG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gU3RyaW5nIHV0aWxzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbi8vIEdlbmVyYXRlIGEgcmFuZG9tIElEXG5mdW5jdGlvbiBnZW5lcmF0ZUlkKHByZWZpeCkge1xuICByZXR1cm4gYCR7cHJlZml4fS0ke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKX1gO1xufVxuXG4vLyBGb3JtYXQgc3RyaW5nXG5mdW5jdGlvbiBmb3JtYXQoaW5wdXQsIC4uLmFyZ3MpIHtcbiAgaWYgKGlzLmVtcHR5KGlucHV0KSkgcmV0dXJuIGlucHV0O1xuICByZXR1cm4gaW5wdXQudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHsoXFxkKylcXH0vZywgKF8sIGkpID0+IGFyZ3NbaV0udG9TdHJpbmcoKSk7XG59XG5cbi8vIEdldCBwZXJjZW50YWdlXG5mdW5jdGlvbiBnZXRQZXJjZW50YWdlKGN1cnJlbnQsIG1heCkge1xuICBpZiAoY3VycmVudCA9PT0gMCB8fCBtYXggPT09IDAgfHwgTnVtYmVyLmlzTmFOKGN1cnJlbnQpIHx8IE51bWJlci5pc05hTihtYXgpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIChjdXJyZW50IC8gbWF4ICogMTAwKS50b0ZpeGVkKDIpO1xufVxuXG4vLyBSZXBsYWNlIGFsbCBvY2N1cnJlbmNlcyBvZiBhIHN0cmluZyBpbiBhIHN0cmluZ1xuZnVuY3Rpb24gcmVwbGFjZUFsbChpbnB1dCA9ICcnLCBmaW5kID0gJycsIHJlcGxhY2UgPSAnJykge1xuICByZXR1cm4gaW5wdXQucmVwbGFjZShuZXcgUmVnRXhwKGZpbmQudG9TdHJpbmcoKS5yZXBsYWNlKC8oWy4qKz9ePSE6JHt9KCl8W1xcXS9cXFxcXSkvZywgJ1xcXFwkMScpLCAnZycpLCByZXBsYWNlLnRvU3RyaW5nKCkpO1xufVxuXG4vLyBDb252ZXJ0IHRvIHRpdGxlIGNhc2VcbmZ1bmN0aW9uIHRvVGl0bGVDYXNlKGlucHV0ID0gJycpIHtcbiAgcmV0dXJuIGlucHV0LnRvU3RyaW5nKCkucmVwbGFjZSgvXFx3XFxTKi9nLCB0ZXh0ID0+IHRleHQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXh0LnNsaWNlKDEpLnRvTG93ZXJDYXNlKCkpO1xufVxuXG4vLyBDb252ZXJ0IHN0cmluZyB0byBwYXNjYWxDYXNlXG5mdW5jdGlvbiB0b1Bhc2NhbENhc2UoaW5wdXQgPSAnJykge1xuICBsZXQgc3RyaW5nID0gaW5wdXQudG9TdHJpbmcoKTtcblxuICAvLyBDb252ZXJ0IGtlYmFiIGNhc2VcbiAgc3RyaW5nID0gcmVwbGFjZUFsbChzdHJpbmcsICctJywgJyAnKTtcblxuICAvLyBDb252ZXJ0IHNuYWtlIGNhc2VcbiAgc3RyaW5nID0gcmVwbGFjZUFsbChzdHJpbmcsICdfJywgJyAnKTtcblxuICAvLyBDb252ZXJ0IHRvIHRpdGxlIGNhc2VcbiAgc3RyaW5nID0gdG9UaXRsZUNhc2Uoc3RyaW5nKTtcblxuICAvLyBDb252ZXJ0IHRvIHBhc2NhbCBjYXNlXG4gIHJldHVybiByZXBsYWNlQWxsKHN0cmluZywgJyAnLCAnJyk7XG59XG5cbi8vIENvbnZlcnQgc3RyaW5nIHRvIHBhc2NhbENhc2VcbmZ1bmN0aW9uIHRvQ2FtZWxDYXNlKGlucHV0ID0gJycpIHtcbiAgbGV0IHN0cmluZyA9IGlucHV0LnRvU3RyaW5nKCk7XG5cbiAgLy8gQ29udmVydCB0byBwYXNjYWwgY2FzZVxuICBzdHJpbmcgPSB0b1Bhc2NhbENhc2Uoc3RyaW5nKTtcblxuICAvLyBDb252ZXJ0IGZpcnN0IGNoYXJhY3RlciB0byBsb3dlcmNhc2VcbiAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbn1cblxuLy8gUmVtb3ZlIEhUTUwgZnJvbSBhIHN0cmluZ1xuZnVuY3Rpb24gc3RyaXBIVE1MKHNvdXJjZSkge1xuICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBmcmFnbWVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgZWxlbWVudC5pbm5lckhUTUwgPSBzb3VyY2U7XG4gIHJldHVybiBmcmFnbWVudC5maXJzdENoaWxkLnRleHRDb250ZW50O1xufVxuXG4vLyBMaWtlIG91dGVySFRNTCwgYnV0IGFsc28gd29ya3MgZm9yIERvY3VtZW50RnJhZ21lbnRcbmZ1bmN0aW9uIGdldEhUTUwoZWxlbWVudCkge1xuICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHdyYXBwZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gIHJldHVybiB3cmFwcGVyLmlubmVySFRNTDtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFBseXIgaW50ZXJuYXRpb25hbGl6YXRpb25cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuLy8gU2tpcCBpMThuIGZvciBhYmJyZXZpYXRpb25zIGFuZCBicmFuZCBuYW1lc1xuY29uc3QgcmVzb3VyY2VzID0ge1xuICBwaXA6ICdQSVAnLFxuICBhaXJwbGF5OiAnQWlyUGxheScsXG4gIGh0bWw1OiAnSFRNTDUnLFxuICB2aW1lbzogJ1ZpbWVvJyxcbiAgeW91dHViZTogJ1lvdVR1YmUnXG59O1xuY29uc3QgaTE4biA9IHtcbiAgZ2V0KGtleSA9ICcnLCBjb25maWcgPSB7fSkge1xuICAgIGlmIChpcy5lbXB0eShrZXkpIHx8IGlzLmVtcHR5KGNvbmZpZykpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgbGV0IHN0cmluZyA9IGdldERlZXAoY29uZmlnLmkxOG4sIGtleSk7XG4gICAgaWYgKGlzLmVtcHR5KHN0cmluZykpIHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhyZXNvdXJjZXMpLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIHJlc291cmNlc1trZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjb25zdCByZXBsYWNlID0ge1xuICAgICAgJ3tzZWVrdGltZX0nOiBjb25maWcuc2Vla1RpbWUsXG4gICAgICAne3RpdGxlfSc6IGNvbmZpZy50aXRsZVxuICAgIH07XG4gICAgT2JqZWN0LmVudHJpZXMocmVwbGFjZSkuZm9yRWFjaCgoW2ssIHZdKSA9PiB7XG4gICAgICBzdHJpbmcgPSByZXBsYWNlQWxsKHN0cmluZywgaywgdik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cmluZztcbiAgfVxufTtcblxuY2xhc3MgU3RvcmFnZSB7XG4gIGNvbnN0cnVjdG9yKHBsYXllcikge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwiZ2V0XCIsIGtleSA9PiB7XG4gICAgICBpZiAoIVN0b3JhZ2Uuc3VwcG9ydGVkIHx8ICF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBzdG9yZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLmtleSk7XG4gICAgICBpZiAoaXMuZW1wdHkoc3RvcmUpKSByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKHN0b3JlKTtcbiAgICAgIHJldHVybiBpcy5zdHJpbmcoa2V5KSAmJiBrZXkubGVuZ3RoID8ganNvbltrZXldIDoganNvbjtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkkMSh0aGlzLCBcInNldFwiLCBvYmplY3QgPT4ge1xuICAgICAgLy8gQmFpbCBpZiB3ZSBkb24ndCBoYXZlIGxvY2FsU3RvcmFnZSBzdXBwb3J0IG9yIGl0J3MgZGlzYWJsZWRcbiAgICAgIGlmICghU3RvcmFnZS5zdXBwb3J0ZWQgfHwgIXRoaXMuZW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENhbiBvbmx5IHN0b3JlIG9iamVjdHNcbiAgICAgIGlmICghaXMub2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgY3VycmVudCBzdG9yYWdlXG4gICAgICBsZXQgc3RvcmFnZSA9IHRoaXMuZ2V0KCk7XG5cbiAgICAgIC8vIERlZmF1bHQgdG8gZW1wdHkgb2JqZWN0XG4gICAgICBpZiAoaXMuZW1wdHkoc3RvcmFnZSkpIHtcbiAgICAgICAgc3RvcmFnZSA9IHt9O1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdGhlIHdvcmtpbmcgY29weSBvZiB0aGUgdmFsdWVzXG4gICAgICBleHRlbmQoc3RvcmFnZSwgb2JqZWN0KTtcblxuICAgICAgLy8gVXBkYXRlIHN0b3JhZ2VcbiAgICAgIHRyeSB7XG4gICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0aGlzLmtleSwgSlNPTi5zdHJpbmdpZnkoc3RvcmFnZSkpO1xuICAgICAgfSBjYXRjaCB7fVxuICAgIH0pO1xuICAgIHRoaXMuZW5hYmxlZCA9IHBsYXllci5jb25maWcuc3RvcmFnZS5lbmFibGVkO1xuICAgIHRoaXMua2V5ID0gcGxheWVyLmNvbmZpZy5zdG9yYWdlLmtleTtcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBhY3R1YWwgc3VwcG9ydCAoc2VlIGlmIHdlIGNhbiB1c2UgaXQpXG4gIHN0YXRpYyBnZXQgc3VwcG9ydGVkKCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoISgnbG9jYWxTdG9yYWdlJyBpbiB3aW5kb3cpKSByZXR1cm4gZmFsc2U7XG4gICAgICBjb25zdCB0ZXN0ID0gJ19fX3Rlc3QnO1xuICAgICAgLy8gVHJ5IHRvIHVzZSBpdCAoaXQgbWlnaHQgYmUgZGlzYWJsZWQsIGUuZy4gdXNlciBpcyBpbiBwcml2YXRlIG1vZGUpXG4gICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9zYW1wb3R0cy9wbHlyL2lzc3Vlcy8xMzFcbiAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0ZXN0LCB0ZXN0KTtcbiAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0ZXN0KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRmV0Y2ggd3JhcHBlclxuLy8gVXNpbmcgWEhSIHRvIGF2b2lkIGlzc3VlcyB3aXRoIG9sZGVyIGJyb3dzZXJzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBmZXRjaCh1cmwsIHJlc3BvbnNlVHlwZSA9ICd0ZXh0Jywgd2l0aENyZWRlbnRpYWxzID0gZmFsc2UpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICAvLyBDaGVjayBmb3IgQ09SUyBzdXBwb3J0XG4gICAgICBpZiAoISgnd2l0aENyZWRlbnRpYWxzJyBpbiByZXF1ZXN0KSkgcmV0dXJuO1xuXG4gICAgICAvLyBTZXQgdG8gdHJ1ZSBpZiBuZWVkZWQgZm9yIENPUlNcbiAgICAgIGlmICh3aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgICAgICBpZiAocmVzcG9uc2VUeXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzb2x2ZShKU09OLnBhcnNlKHJlcXVlc3QucmVzcG9uc2VUZXh0KSk7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVxdWVzdC5zdGF0dXMpO1xuICAgICAgfSk7XG4gICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcbiAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBTcHJpdGUgbG9hZGVyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbi8vIExvYWQgYW4gZXh0ZXJuYWwgU1ZHIHNwcml0ZVxuZnVuY3Rpb24gbG9hZFNwcml0ZSh1cmwsIGlkKSB7XG4gIGlmICghaXMuc3RyaW5nKHVybCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJlZml4ID0gJ2NhY2hlJztcbiAgY29uc3QgaGFzSWQgPSBpcy5zdHJpbmcoaWQpO1xuICBsZXQgaXNDYWNoZWQgPSBmYWxzZTtcbiAgY29uc3QgZXhpc3RzID0gKCkgPT4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpICE9PSBudWxsO1xuICBjb25zdCB1cGRhdGUgPSAoY29udGFpbmVyLCBkYXRhKSA9PiB7XG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9IGRhdGE7XG5cbiAgICAvLyBDaGVjayBhZ2FpbiBpbmNhc2Ugb2YgcmFjZSBjb25kaXRpb25cbiAgICBpZiAoaGFzSWQgJiYgZXhpc3RzKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJbmplY3QgdGhlIFNWRyB0byB0aGUgYm9keVxuICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmJlZ2luJywgY29udGFpbmVyKTtcbiAgfTtcblxuICAvLyBPbmx5IGxvYWQgb25jZSBpZiBJRCBzZXRcbiAgaWYgKCFoYXNJZCB8fCAhZXhpc3RzKCkpIHtcbiAgICBjb25zdCB1c2VTdG9yYWdlID0gU3RvcmFnZS5zdXBwb3J0ZWQ7XG4gICAgLy8gQ3JlYXRlIGNvbnRhaW5lclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2hpZGRlbicsICcnKTtcbiAgICBpZiAoaGFzSWQpIHtcbiAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2lkJywgaWQpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGluIGNhY2hlXG4gICAgaWYgKHVzZVN0b3JhZ2UpIHtcbiAgICAgIGNvbnN0IGNhY2hlZCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShgJHtwcmVmaXh9LSR7aWR9YCk7XG4gICAgICBpc0NhY2hlZCA9IGNhY2hlZCAhPT0gbnVsbDtcbiAgICAgIGlmIChpc0NhY2hlZCkge1xuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShjYWNoZWQpO1xuICAgICAgICB1cGRhdGUoY29udGFpbmVyLCBkYXRhLmNvbnRlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdldCB0aGUgc3ByaXRlXG4gICAgZmV0Y2godXJsKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICBpZiAoaXMuZW1wdHkocmVzdWx0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodXNlU3RvcmFnZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShgJHtwcmVmaXh9LSR7aWR9YCwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgY29udGVudDogcmVzdWx0XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9XG4gICAgICB1cGRhdGUoY29udGFpbmVyLCByZXN1bHQpO1xuICAgIH0pLmNhdGNoKCgpID0+IHt9KTtcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gVGltZSB1dGlsc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4vLyBUaW1lIGhlbHBlcnNcbmNvbnN0IGdldEhvdXJzID0gdmFsdWUgPT4gTWF0aC50cnVuYyh2YWx1ZSAvIDYwIC8gNjAgJSA2MCwgMTApO1xuY29uc3QgZ2V0TWludXRlcyA9IHZhbHVlID0+IE1hdGgudHJ1bmModmFsdWUgLyA2MCAlIDYwLCAxMCk7XG5jb25zdCBnZXRTZWNvbmRzID0gdmFsdWUgPT4gTWF0aC50cnVuYyh2YWx1ZSAlIDYwLCAxMCk7XG5cbi8vIEZvcm1hdCB0aW1lIHRvIFVJIGZyaWVuZGx5IHN0cmluZ1xuZnVuY3Rpb24gZm9ybWF0VGltZSh0aW1lID0gMCwgZGlzcGxheUhvdXJzID0gZmFsc2UsIGludmVydGVkID0gZmFsc2UpIHtcbiAgLy8gQmFpbCBpZiB0aGUgdmFsdWUgaXNuJ3QgYSBudW1iZXJcbiAgaWYgKCFpcy5udW1iZXIodGltZSkpIHtcbiAgICByZXR1cm4gZm9ybWF0VGltZSh1bmRlZmluZWQsIGRpc3BsYXlIb3VycywgaW52ZXJ0ZWQpO1xuICB9XG5cbiAgLy8gRm9ybWF0IHRpbWUgY29tcG9uZW50IHRvIGFkZCBsZWFkaW5nIHplcm9cbiAgY29uc3QgZm9ybWF0ID0gdmFsdWUgPT4gYDAke3ZhbHVlfWAuc2xpY2UoLTIpO1xuICAvLyBCcmVha2Rvd24gdG8gaG91cnMsIG1pbnMsIHNlY3NcbiAgbGV0IGhvdXJzID0gZ2V0SG91cnModGltZSk7XG4gIGNvbnN0IG1pbnMgPSBnZXRNaW51dGVzKHRpbWUpO1xuICBjb25zdCBzZWNzID0gZ2V0U2Vjb25kcyh0aW1lKTtcblxuICAvLyBEbyB3ZSBuZWVkIHRvIGRpc3BsYXkgaG91cnM/XG4gIGlmIChkaXNwbGF5SG91cnMgfHwgaG91cnMgPiAwKSB7XG4gICAgaG91cnMgPSBgJHtob3Vyc306YDtcbiAgfSBlbHNlIHtcbiAgICBob3VycyA9ICcnO1xuICB9XG5cbiAgLy8gUmVuZGVyXG4gIHJldHVybiBgJHtpbnZlcnRlZCAmJiB0aW1lID4gMCA/ICctJyA6ICcnfSR7aG91cnN9JHtmb3JtYXQobWlucyl9OiR7Zm9ybWF0KHNlY3MpfWA7XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBQbHlyIGNvbnRyb2xzXG4vLyBUT0RPOiBUaGlzIG5lZWRzIHRvIGJlIHNwbGl0IGludG8gc21hbGxlciBmaWxlcyBhbmQgY2xlYW5lZCB1cFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4vLyBUT0RPOiBEb24ndCBleHBvcnQgYSBtYXNzaXZlIG9iamVjdCAtIGJyZWFrIGRvd24gYW5kIGNyZWF0ZSBjbGFzc1xuY29uc3QgY29udHJvbHMgPSB7XG4gIC8vIEdldCBpY29uIFVSTFxuICBnZXRJY29uVXJsKCkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodGhpcy5jb25maWcuaWNvblVybCwgd2luZG93LmxvY2F0aW9uKTtcbiAgICBjb25zdCBob3N0ID0gd2luZG93LmxvY2F0aW9uLmhvc3QgPyB3aW5kb3cubG9jYXRpb24uaG9zdCA6IHdpbmRvdy50b3AubG9jYXRpb24uaG9zdDtcbiAgICBjb25zdCBjb3JzID0gdXJsLmhvc3QgIT09IGhvc3QgfHwgYnJvd3Nlci5pc0lFICYmICF3aW5kb3cuc3ZnNGV2ZXJ5Ym9keTtcbiAgICByZXR1cm4ge1xuICAgICAgdXJsOiB0aGlzLmNvbmZpZy5pY29uVXJsLFxuICAgICAgY29yc1xuICAgIH07XG4gIH0sXG4gIC8vIEZpbmQgdGhlIFVJIGNvbnRyb2xzXG4gIGZpbmRFbGVtZW50cygpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5lbGVtZW50cy5jb250cm9scyA9IGdldEVsZW1lbnQuY2FsbCh0aGlzLCB0aGlzLmNvbmZpZy5zZWxlY3RvcnMuY29udHJvbHMud3JhcHBlcik7XG5cbiAgICAgIC8vIEJ1dHRvbnNcbiAgICAgIHRoaXMuZWxlbWVudHMuYnV0dG9ucyA9IHtcbiAgICAgICAgcGxheTogZ2V0RWxlbWVudHMuY2FsbCh0aGlzLCB0aGlzLmNvbmZpZy5zZWxlY3RvcnMuYnV0dG9ucy5wbGF5KSxcbiAgICAgICAgcGF1c2U6IGdldEVsZW1lbnQuY2FsbCh0aGlzLCB0aGlzLmNvbmZpZy5zZWxlY3RvcnMuYnV0dG9ucy5wYXVzZSksXG4gICAgICAgIHJlc3RhcnQ6IGdldEVsZW1lbnQuY2FsbCh0aGlzLCB0aGlzLmNvbmZpZy5zZWxlY3RvcnMuYnV0dG9ucy5yZXN0YXJ0KSxcbiAgICAgICAgcmV3aW5kOiBnZXRFbGVtZW50LmNhbGwodGhpcywgdGhpcy5jb25maWcuc2VsZWN0b3JzLmJ1dHRvbnMucmV3aW5kKSxcbiAgICAgICAgZmFzdEZvcndhcmQ6IGdldEVsZW1lbnQuY2FsbCh0aGlzLCB0aGlzLmNvbmZpZy5zZWxlY3RvcnMuYnV0dG9ucy5mYXN0Rm9yd2FyZCksXG4gICAgICAgIG11dGU6IGdldEVsZW1lbnQuY2FsbCh0aGlzLCB0aGlzLmNvbmZpZy5zZWxlY3RvcnMuYnV0dG9ucy5tdXRlKSxcbiAgICAgICAgcGlwOiBnZXRFbGVtZW50LmNhbGwodGhpcywgdGhpcy5jb25maWcuc2VsZWN0b3JzLmJ1dHRvbnMucGlwKSxcbiAgICAgICAgYWlycGxheTogZ2V0RWxlbWVudC5jYWxsKHRoaXMsIHRoaXMuY29uZmlnLnNlbGVjdG9ycy5idXR0b25zLmFpcnBsYXkpLFxuICAgICAgICBzZXR0aW5nczogZ2V0RWxlbWVudC5jYWxsKHRoaXMsIHRoaXMuY29uZmlnLnNlbGVjdG9ycy5idXR0b25zLnNldHRpbmdzKSxcbiAgICAgICAgY2FwdGlvbnM6IGdldEVsZW1lbnQuY2FsbCh0aGlzLCB0aGlzLmNvbmZpZy5zZWxlY3RvcnMuYnV0dG9ucy5jYXB0aW9ucyksXG4gICAgICAgIGZ1bGxzY3JlZW46IGdldEVsZW1lbnQuY2FsbCh0aGlzLCB0aGlzLmNvbmZpZy5zZWxlY3RvcnMuYnV0dG9ucy5mdWxsc2NyZWVuKVxuICAgICAgfTtcblxuICAgICAgLy8gUHJvZ3Jlc3NcbiAgICAgIHRoaXMuZWxlbWVudHMucHJvZ3Jlc3MgPSBnZXRFbGVtZW50LmNhbGwodGhpcywgdGhpcy5jb25maWcuc2VsZWN0b3JzLnByb2dyZXNzKTtcblxuICAgICAgLy8gSW5wdXRzXG4gICAgICB0aGlzLmVsZW1lbnRzLmlucHV0cyA9IHtcbiAgICAgICAgc2VlazogZ2V0RWxlbWVudC5jYWxsKHRoaXMsIHRoaXMuY29uZmlnLnNlbGVjdG9ycy5pbnB1dHMuc2VlayksXG4gICAgICAgIHZvbHVtZTogZ2V0RWxlbWVudC5jYWxsKHRoaXMsIHRoaXMuY29uZmlnLnNlbGVjdG9ycy5pbnB1dHMudm9sdW1lKVxuICAgICAgfTtcblxuICAgICAgLy8gRGlzcGxheVxuICAgICAgdGhpcy5lbGVtZW50cy5kaXNwbGF5ID0ge1xuICAgICAgICBidWZmZXI6IGdldEVsZW1lbnQuY2FsbCh0aGlzLCB0aGlzLmNvbmZpZy5zZWxlY3RvcnMuZGlzcGxheS5idWZmZXIpLFxuICAgICAgICBjdXJyZW50VGltZTogZ2V0RWxlbWVudC5jYWxsKHRoaXMsIHRoaXMuY29uZmlnLnNlbGVjdG9ycy5kaXNwbGF5LmN1cnJlbnRUaW1lKSxcbiAgICAgICAgZHVyYXRpb246IGdldEVsZW1lbnQuY2FsbCh0aGlzLCB0aGlzLmNvbmZpZy5zZWxlY3RvcnMuZGlzcGxheS5kdXJhdGlvbilcbiAgICAgIH07XG5cbiAgICAgIC8vIFNlZWsgdG9vbHRpcFxuICAgICAgaWYgKGlzLmVsZW1lbnQodGhpcy5lbGVtZW50cy5wcm9ncmVzcykpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5kaXNwbGF5LnNlZWtUb29sdGlwID0gdGhpcy5lbGVtZW50cy5wcm9ncmVzcy5xdWVyeVNlbGVjdG9yKGAuJHt0aGlzLmNvbmZpZy5jbGFzc05hbWVzLnRvb2x0aXB9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gTG9nIGl0XG4gICAgICB0aGlzLmRlYnVnLndhcm4oJ0l0IGxvb2tzIGxpa2UgdGhlcmUgaXMgYSBwcm9ibGVtIHdpdGggeW91ciBjdXN0b20gY29udHJvbHMgSFRNTCcsIGVycm9yKTtcblxuICAgICAgLy8gUmVzdG9yZSBuYXRpdmUgdmlkZW8gY29udHJvbHNcbiAgICAgIHRoaXMudG9nZ2xlTmF0aXZlQ29udHJvbHModHJ1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuICAvLyBDcmVhdGUgPHN2Zz4gaWNvblxuICBjcmVhdGVJY29uKHR5cGUsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBuYW1lc3BhY2UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICAgIGNvbnN0IGljb25VcmwgPSBjb250cm9scy5nZXRJY29uVXJsLmNhbGwodGhpcyk7XG4gICAgY29uc3QgaWNvblBhdGggPSBgJHshaWNvblVybC5jb3JzID8gaWNvblVybC51cmwgOiAnJ30jJHt0aGlzLmNvbmZpZy5pY29uUHJlZml4fWA7XG4gICAgLy8gQ3JlYXRlIDxzdmc+XG4gICAgY29uc3QgaWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsICdzdmcnKTtcbiAgICBzZXRBdHRyaWJ1dGVzKGljb24sIGV4dGVuZChhdHRyaWJ1dGVzLCB7XG4gICAgICAnYXJpYS1oaWRkZW4nOiAndHJ1ZScsXG4gICAgICAnZm9jdXNhYmxlJzogJ2ZhbHNlJ1xuICAgIH0pKTtcblxuICAgIC8vIENyZWF0ZSB0aGUgPHVzZT4gdG8gcmVmZXJlbmNlIHNwcml0ZVxuICAgIGNvbnN0IHVzZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsICd1c2UnKTtcbiAgICBjb25zdCBwYXRoID0gYCR7aWNvblBhdGh9LSR7dHlwZX1gO1xuXG4gICAgLy8gU2V0IGBocmVmYCBhdHRyaWJ1dGVzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NhbXBvdHRzL3BseXIvaXNzdWVzLzQ2MFxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUveGxpbms6aHJlZlxuICAgIGlmICgnaHJlZicgaW4gdXNlKSB7XG4gICAgICB1c2Uuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCAnaHJlZicsIHBhdGgpO1xuICAgIH1cblxuICAgIC8vIEFsd2F5cyBzZXQgdGhlIG9sZGVyIGF0dHJpYnV0ZSBldmVuIHRob3VnaCBpdCdzIFwiZGVwcmVjYXRlZFwiIChpdCdsbCBiZSBhcm91bmQgZm9yIGFnZXMpXG4gICAgdXNlLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgJ3hsaW5rOmhyZWYnLCBwYXRoKTtcblxuICAgIC8vIEFkZCA8dXNlPiB0byA8c3ZnPlxuICAgIGljb24uYXBwZW5kQ2hpbGQodXNlKTtcbiAgICByZXR1cm4gaWNvbjtcbiAgfSxcbiAgLy8gQ3JlYXRlIGhpZGRlbiB0ZXh0IGxhYmVsXG4gIGNyZWF0ZUxhYmVsKGtleSwgYXR0ciA9IHt9KSB7XG4gICAgY29uc3QgdGV4dCA9IGkxOG4uZ2V0KGtleSwgdGhpcy5jb25maWcpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7XG4gICAgICAuLi5hdHRyLFxuICAgICAgY2xhc3M6IFthdHRyLmNsYXNzLCB0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmhpZGRlbl0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJyAnKVxuICAgIH07XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCBhdHRyaWJ1dGVzLCB0ZXh0KTtcbiAgfSxcbiAgLy8gQ3JlYXRlIGEgYmFkZ2VcbiAgY3JlYXRlQmFkZ2UodGV4dCkge1xuICAgIGlmIChpcy5lbXB0eSh0ZXh0KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGJhZGdlID0gY3JlYXRlRWxlbWVudCgnc3BhbicsIHtcbiAgICAgIGNsYXNzOiB0aGlzLmNvbmZpZy5jbGFzc05hbWVzLm1lbnUudmFsdWVcbiAgICB9KTtcbiAgICBiYWRnZS5hcHBlbmRDaGlsZChjcmVhdGVFbGVtZW50KCdzcGFuJywge1xuICAgICAgY2xhc3M6IHRoaXMuY29uZmlnLmNsYXNzTmFtZXMubWVudS5iYWRnZVxuICAgIH0sIHRleHQpKTtcbiAgICByZXR1cm4gYmFkZ2U7XG4gIH0sXG4gIC8vIENyZWF0ZSBhIDxidXR0b24+XG4gIGNyZWF0ZUJ1dHRvbihidXR0b25UeXBlLCBhdHRyKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGV4dGVuZCh7fSwgYXR0cik7XG4gICAgbGV0IHR5cGUgPSB0b0NhbWVsQ2FzZShidXR0b25UeXBlKTtcbiAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgIGVsZW1lbnQ6ICdidXR0b24nLFxuICAgICAgdG9nZ2xlOiBmYWxzZSxcbiAgICAgIGxhYmVsOiBudWxsLFxuICAgICAgaWNvbjogbnVsbCxcbiAgICAgIGxhYmVsUHJlc3NlZDogbnVsbCxcbiAgICAgIGljb25QcmVzc2VkOiBudWxsXG4gICAgfTtcbiAgICBbJ2VsZW1lbnQnLCAnaWNvbicsICdsYWJlbCddLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIHByb3BzW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBEZWZhdWx0IHRvICdidXR0b24nIHR5cGUgdG8gcHJldmVudCBmb3JtIHN1Ym1pc3Npb25cbiAgICBpZiAocHJvcHMuZWxlbWVudCA9PT0gJ2J1dHRvbicgJiYgIU9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmluY2x1ZGVzKCd0eXBlJykpIHtcbiAgICAgIGF0dHJpYnV0ZXMudHlwZSA9ICdidXR0b24nO1xuICAgIH1cblxuICAgIC8vIFNldCBjbGFzcyBuYW1lXG4gICAgaWYgKE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmluY2x1ZGVzKCdjbGFzcycpKSB7XG4gICAgICBpZiAoIWF0dHJpYnV0ZXMuY2xhc3Muc3BsaXQoJyAnKS5pbmNsdWRlcyh0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmNvbnRyb2wpKSB7XG4gICAgICAgIGV4dGVuZChhdHRyaWJ1dGVzLCB7XG4gICAgICAgICAgY2xhc3M6IGAke2F0dHJpYnV0ZXMuY2xhc3N9ICR7dGhpcy5jb25maWcuY2xhc3NOYW1lcy5jb250cm9sfWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0dHJpYnV0ZXMuY2xhc3MgPSB0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmNvbnRyb2w7XG4gICAgfVxuXG4gICAgLy8gTGFyZ2UgcGxheSBidXR0b25cbiAgICBzd2l0Y2ggKGJ1dHRvblR5cGUpIHtcbiAgICAgIGNhc2UgJ3BsYXknOlxuICAgICAgICBwcm9wcy50b2dnbGUgPSB0cnVlO1xuICAgICAgICBwcm9wcy5sYWJlbCA9ICdwbGF5JztcbiAgICAgICAgcHJvcHMubGFiZWxQcmVzc2VkID0gJ3BhdXNlJztcbiAgICAgICAgcHJvcHMuaWNvbiA9ICdwbGF5JztcbiAgICAgICAgcHJvcHMuaWNvblByZXNzZWQgPSAncGF1c2UnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ211dGUnOlxuICAgICAgICBwcm9wcy50b2dnbGUgPSB0cnVlO1xuICAgICAgICBwcm9wcy5sYWJlbCA9ICdtdXRlJztcbiAgICAgICAgcHJvcHMubGFiZWxQcmVzc2VkID0gJ3VubXV0ZSc7XG4gICAgICAgIHByb3BzLmljb24gPSAndm9sdW1lJztcbiAgICAgICAgcHJvcHMuaWNvblByZXNzZWQgPSAnbXV0ZWQnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NhcHRpb25zJzpcbiAgICAgICAgcHJvcHMudG9nZ2xlID0gdHJ1ZTtcbiAgICAgICAgcHJvcHMubGFiZWwgPSAnZW5hYmxlQ2FwdGlvbnMnO1xuICAgICAgICBwcm9wcy5sYWJlbFByZXNzZWQgPSAnZGlzYWJsZUNhcHRpb25zJztcbiAgICAgICAgcHJvcHMuaWNvbiA9ICdjYXB0aW9ucy1vZmYnO1xuICAgICAgICBwcm9wcy5pY29uUHJlc3NlZCA9ICdjYXB0aW9ucy1vbic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZnVsbHNjcmVlbic6XG4gICAgICAgIHByb3BzLnRvZ2dsZSA9IHRydWU7XG4gICAgICAgIHByb3BzLmxhYmVsID0gJ2VudGVyRnVsbHNjcmVlbic7XG4gICAgICAgIHByb3BzLmxhYmVsUHJlc3NlZCA9ICdleGl0RnVsbHNjcmVlbic7XG4gICAgICAgIHByb3BzLmljb24gPSAnZW50ZXItZnVsbHNjcmVlbic7XG4gICAgICAgIHByb3BzLmljb25QcmVzc2VkID0gJ2V4aXQtZnVsbHNjcmVlbic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncGxheS1sYXJnZSc6XG4gICAgICAgIGF0dHJpYnV0ZXMuY2xhc3MgKz0gYCAke3RoaXMuY29uZmlnLmNsYXNzTmFtZXMuY29udHJvbH0tLW92ZXJsYWlkYDtcbiAgICAgICAgdHlwZSA9ICdwbGF5JztcbiAgICAgICAgcHJvcHMubGFiZWwgPSAncGxheSc7XG4gICAgICAgIHByb3BzLmljb24gPSAncGxheSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGlzLmVtcHR5KHByb3BzLmxhYmVsKSkge1xuICAgICAgICAgIHByb3BzLmxhYmVsID0gdHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMuZW1wdHkocHJvcHMuaWNvbikpIHtcbiAgICAgICAgICBwcm9wcy5pY29uID0gYnV0dG9uVHlwZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBidXR0b24gPSBjcmVhdGVFbGVtZW50KHByb3BzLmVsZW1lbnQpO1xuXG4gICAgLy8gU2V0dXAgdG9nZ2xlIGljb24gYW5kIGxhYmVsc1xuICAgIGlmIChwcm9wcy50b2dnbGUpIHtcbiAgICAgIC8vIEljb25cbiAgICAgIGJ1dHRvbi5hcHBlbmRDaGlsZChjb250cm9scy5jcmVhdGVJY29uLmNhbGwodGhpcywgcHJvcHMuaWNvblByZXNzZWQsIHtcbiAgICAgICAgY2xhc3M6ICdpY29uLS1wcmVzc2VkJ1xuICAgICAgfSkpO1xuICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKGNvbnRyb2xzLmNyZWF0ZUljb24uY2FsbCh0aGlzLCBwcm9wcy5pY29uLCB7XG4gICAgICAgIGNsYXNzOiAnaWNvbi0tbm90LXByZXNzZWQnXG4gICAgICB9KSk7XG5cbiAgICAgIC8vIExhYmVsL1Rvb2x0aXBcbiAgICAgIGJ1dHRvbi5hcHBlbmRDaGlsZChjb250cm9scy5jcmVhdGVMYWJlbC5jYWxsKHRoaXMsIHByb3BzLmxhYmVsUHJlc3NlZCwge1xuICAgICAgICBjbGFzczogJ2xhYmVsLS1wcmVzc2VkJ1xuICAgICAgfSkpO1xuICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKGNvbnRyb2xzLmNyZWF0ZUxhYmVsLmNhbGwodGhpcywgcHJvcHMubGFiZWwsIHtcbiAgICAgICAgY2xhc3M6ICdsYWJlbC0tbm90LXByZXNzZWQnXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1dHRvbi5hcHBlbmRDaGlsZChjb250cm9scy5jcmVhdGVJY29uLmNhbGwodGhpcywgcHJvcHMuaWNvbikpO1xuICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKGNvbnRyb2xzLmNyZWF0ZUxhYmVsLmNhbGwodGhpcywgcHJvcHMubGFiZWwpKTtcbiAgICB9XG5cbiAgICAvLyBNZXJnZSBhbmQgc2V0IGF0dHJpYnV0ZXNcbiAgICBleHRlbmQoYXR0cmlidXRlcywgZ2V0QXR0cmlidXRlc0Zyb21TZWxlY3Rvcih0aGlzLmNvbmZpZy5zZWxlY3RvcnMuYnV0dG9uc1t0eXBlXSwgYXR0cmlidXRlcykpO1xuICAgIHNldEF0dHJpYnV0ZXMoYnV0dG9uLCBhdHRyaWJ1dGVzKTtcblxuICAgIC8vIFdlIGhhdmUgbXVsdGlwbGUgcGxheSBidXR0b25zXG4gICAgaWYgKHR5cGUgPT09ICdwbGF5Jykge1xuICAgICAgaWYgKCFpcy5hcnJheSh0aGlzLmVsZW1lbnRzLmJ1dHRvbnNbdHlwZV0pKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHMuYnV0dG9uc1t0eXBlXSA9IFtdO1xuICAgICAgfVxuICAgICAgdGhpcy5lbGVtZW50cy5idXR0b25zW3R5cGVdLnB1c2goYnV0dG9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbGVtZW50cy5idXR0b25zW3R5cGVdID0gYnV0dG9uO1xuICAgIH1cbiAgICByZXR1cm4gYnV0dG9uO1xuICB9LFxuICAvLyBDcmVhdGUgYW4gPGlucHV0IHR5cGU9J3JhbmdlJz5cbiAgY3JlYXRlUmFuZ2UodHlwZSwgYXR0cmlidXRlcykge1xuICAgIC8vIFNlZWsgaW5wdXRcbiAgICBjb25zdCBpbnB1dCA9IGNyZWF0ZUVsZW1lbnQoJ2lucHV0JywgZXh0ZW5kKGdldEF0dHJpYnV0ZXNGcm9tU2VsZWN0b3IodGhpcy5jb25maWcuc2VsZWN0b3JzLmlucHV0c1t0eXBlXSksIHtcbiAgICAgICd0eXBlJzogJ3JhbmdlJyxcbiAgICAgICdtaW4nOiAwLFxuICAgICAgJ21heCc6IDEwMCxcbiAgICAgICdzdGVwJzogMC4wMSxcbiAgICAgICd2YWx1ZSc6IDAsXG4gICAgICAnYXV0b2NvbXBsZXRlJzogJ29mZicsXG4gICAgICAvLyBBMTF5IGZpeGVzIGZvciBodHRwczovL2dpdGh1Yi5jb20vc2FtcG90dHMvcGx5ci9pc3N1ZXMvOTA1XG4gICAgICAncm9sZSc6ICdzbGlkZXInLFxuICAgICAgJ2FyaWEtbGFiZWwnOiBpMThuLmdldCh0eXBlLCB0aGlzLmNvbmZpZyksXG4gICAgICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICAgICAnYXJpYS12YWx1ZW1heCc6IDEwMCxcbiAgICAgICdhcmlhLXZhbHVlbm93JzogMFxuICAgIH0sIGF0dHJpYnV0ZXMpKTtcbiAgICB0aGlzLmVsZW1lbnRzLmlucHV0c1t0eXBlXSA9IGlucHV0O1xuXG4gICAgLy8gU2V0IHRoZSBmaWxsIGZvciB3ZWJraXQgbm93XG4gICAgY29udHJvbHMudXBkYXRlUmFuZ2VGaWxsLmNhbGwodGhpcywgaW5wdXQpO1xuXG4gICAgLy8gSW1wcm92ZSBzdXBwb3J0IG9uIHRvdWNoIGRldmljZXNcbiAgICBSYW5nZVRvdWNoLnNldHVwKGlucHV0KTtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH0sXG4gIC8vIENyZWF0ZSBhIDxwcm9ncmVzcz5cbiAgY3JlYXRlUHJvZ3Jlc3ModHlwZSwgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHByb2dyZXNzID0gY3JlYXRlRWxlbWVudCgncHJvZ3Jlc3MnLCBleHRlbmQoZ2V0QXR0cmlidXRlc0Zyb21TZWxlY3Rvcih0aGlzLmNvbmZpZy5zZWxlY3RvcnMuZGlzcGxheVt0eXBlXSksIHtcbiAgICAgICdtaW4nOiAwLFxuICAgICAgJ21heCc6IDEwMCxcbiAgICAgICd2YWx1ZSc6IDAsXG4gICAgICAncm9sZSc6ICdwcm9ncmVzc2JhcicsXG4gICAgICAnYXJpYS1oaWRkZW4nOiB0cnVlXG4gICAgfSwgYXR0cmlidXRlcykpO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBsYWJlbCBpbnNpZGVcbiAgICBpZiAodHlwZSAhPT0gJ3ZvbHVtZScpIHtcbiAgICAgIHByb2dyZXNzLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCBudWxsLCAnMCcpKTtcbiAgICAgIGNvbnN0IHN1ZmZpeEtleSA9IHtcbiAgICAgICAgcGxheWVkOiAncGxheWVkJyxcbiAgICAgICAgYnVmZmVyOiAnYnVmZmVyZWQnXG4gICAgICB9W3R5cGVdO1xuICAgICAgY29uc3Qgc3VmZml4ID0gc3VmZml4S2V5ID8gaTE4bi5nZXQoc3VmZml4S2V5LCB0aGlzLmNvbmZpZykgOiAnJztcbiAgICAgIHByb2dyZXNzLnRleHRDb250ZW50ID0gYCUgJHtzdWZmaXgudG9Mb3dlckNhc2UoKX1gO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnRzLmRpc3BsYXlbdHlwZV0gPSBwcm9ncmVzcztcbiAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gIH0sXG4gIC8vIENyZWF0ZSB0aW1lIGRpc3BsYXlcbiAgY3JlYXRlVGltZSh0eXBlLCBhdHRycykge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBnZXRBdHRyaWJ1dGVzRnJvbVNlbGVjdG9yKHRoaXMuY29uZmlnLnNlbGVjdG9ycy5kaXNwbGF5W3R5cGVdLCBhdHRycyk7XG4gICAgY29uc3QgY29udGFpbmVyID0gY3JlYXRlRWxlbWVudCgnZGl2JywgZXh0ZW5kKGF0dHJpYnV0ZXMsIHtcbiAgICAgICdjbGFzcyc6IGAke2F0dHJpYnV0ZXMuY2xhc3MgPyBhdHRyaWJ1dGVzLmNsYXNzIDogJyd9ICR7dGhpcy5jb25maWcuY2xhc3NOYW1lcy5kaXNwbGF5LnRpbWV9IGAudHJpbSgpLFxuICAgICAgJ2FyaWEtbGFiZWwnOiBpMThuLmdldCh0eXBlLCB0aGlzLmNvbmZpZyksXG4gICAgICAncm9sZSc6ICd0aW1lcidcbiAgICB9KSwgJzAwOjAwJyk7XG5cbiAgICAvLyBSZWZlcmVuY2UgZm9yIHVwZGF0ZXNcbiAgICB0aGlzLmVsZW1lbnRzLmRpc3BsYXlbdHlwZV0gPSBjb250YWluZXI7XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfSxcbiAgLy8gQmluZCBrZXlib2FyZCBzaG9ydGN1dHMgZm9yIGEgbWVudSBpdGVtXG4gIC8vIFdlIGhhdmUgdG8gYmluZCB0byBrZXl1cCBvdGhlcndpc2UgRmlyZWZveCB0cmlnZ2VycyBhIGNsaWNrIHdoZW4gYSBrZXlkb3duIGV2ZW50IGhhbmRsZXIgc2hpZnRzIGZvY3VzXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyMjAxNDNcbiAgYmluZE1lbnVJdGVtU2hvcnRjdXRzKG1lbnVJdGVtLCB0eXBlKSB7XG4gICAgLy8gTmF2aWdhdGUgdGhyb3VnaCBtZW51cyB2aWEgYXJyb3cga2V5cyBhbmQgc3BhY2VcbiAgICBvbi5jYWxsKHRoaXMsIG1lbnVJdGVtLCAna2V5ZG93biBrZXl1cCcsIGV2ZW50ID0+IHtcbiAgICAgIC8vIFdlIG9ubHkgY2FyZSBhYm91dCBzcGFjZSBhbmQg4qyG77iPIOKsh++4j++4jyDinqHvuI9cbiAgICAgIGlmICghWycgJywgJ0Fycm93VXAnLCAnQXJyb3dEb3duJywgJ0Fycm93UmlnaHQnXS5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUHJldmVudCBwbGF5IC8gc2Vla1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAvLyBXZSdyZSBqdXN0IGhlcmUgdG8gcHJldmVudCB0aGUga2V5ZG93biBidWJibGluZ1xuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpc1JhZGlvQnV0dG9uID0gbWF0Y2hlcyhtZW51SXRlbSwgJ1tyb2xlPVwibWVudWl0ZW1yYWRpb1wiXScpO1xuXG4gICAgICAvLyBTaG93IHRoZSByZXNwZWN0aXZlIG1lbnVcbiAgICAgIGlmICghaXNSYWRpb0J1dHRvbiAmJiBbJyAnLCAnQXJyb3dSaWdodCddLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgY29udHJvbHMuc2hvd01lbnVQYW5lbC5jYWxsKHRoaXMsIHR5cGUsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHRhcmdldDtcbiAgICAgICAgaWYgKGV2ZW50LmtleSAhPT0gJyAnKSB7XG4gICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0Fycm93RG93bicgfHwgaXNSYWRpb0J1dHRvbiAmJiBldmVudC5rZXkgPT09ICdBcnJvd1JpZ2h0Jykge1xuICAgICAgICAgICAgdGFyZ2V0ID0gbWVudUl0ZW0ubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKCFpcy5lbGVtZW50KHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0ID0gbWVudUl0ZW0ucGFyZW50Tm9kZS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0ID0gbWVudUl0ZW0ucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICAgICAgICAgIGlmICghaXMuZWxlbWVudCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgIHRhcmdldCA9IG1lbnVJdGVtLnBhcmVudE5vZGUubGFzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0Rm9jdXMuY2FsbCh0aGlzLCB0YXJnZXQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgLy8gRW50ZXIgd2lsbCBmaXJlIGEgYGNsaWNrYCBldmVudCBidXQgd2Ugc3RpbGwgbmVlZCB0byBtYW5hZ2UgZm9jdXNcbiAgICAvLyBTbyB3ZSBiaW5kIHRvIGtleXVwIHdoaWNoIGZpcmVzIGFmdGVyIGFuZCBzZXQgZm9jdXMgaGVyZVxuICAgIG9uLmNhbGwodGhpcywgbWVudUl0ZW0sICdrZXl1cCcsIGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC5rZXkgIT09ICdSZXR1cm4nKSByZXR1cm47XG4gICAgICBjb250cm9scy5mb2N1c0ZpcnN0TWVudUl0ZW0uY2FsbCh0aGlzLCBudWxsLCB0cnVlKTtcbiAgICB9KTtcbiAgfSxcbiAgLy8gQ3JlYXRlIGEgc2V0dGluZ3MgbWVudSBpdGVtXG4gIGNyZWF0ZU1lbnVJdGVtKHtcbiAgICB2YWx1ZSxcbiAgICBsaXN0LFxuICAgIHR5cGUsXG4gICAgdGl0bGUsXG4gICAgYmFkZ2UgPSBudWxsLFxuICAgIGNoZWNrZWQgPSBmYWxzZVxuICB9KSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZXNGcm9tU2VsZWN0b3IodGhpcy5jb25maWcuc2VsZWN0b3JzLmlucHV0c1t0eXBlXSk7XG4gICAgY29uc3QgbWVudUl0ZW0gPSBjcmVhdGVFbGVtZW50KCdidXR0b24nLCBleHRlbmQoYXR0cmlidXRlcywge1xuICAgICAgJ3R5cGUnOiAnYnV0dG9uJyxcbiAgICAgICdyb2xlJzogJ21lbnVpdGVtcmFkaW8nLFxuICAgICAgJ2NsYXNzJzogYCR7dGhpcy5jb25maWcuY2xhc3NOYW1lcy5jb250cm9sfSAke2F0dHJpYnV0ZXMuY2xhc3MgPyBhdHRyaWJ1dGVzLmNsYXNzIDogJyd9YC50cmltKCksXG4gICAgICAnYXJpYS1jaGVja2VkJzogY2hlY2tlZCxcbiAgICAgIHZhbHVlXG4gICAgfSkpO1xuICAgIGNvbnN0IGZsZXggPSBjcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cbiAgICAvLyBXZSBoYXZlIHRvIHNldCBhcyBIVE1MIGluY2FzZSBvZiBzcGVjaWFsIGNoYXJhY3RlcnNcbiAgICBmbGV4LmlubmVySFRNTCA9IHRpdGxlO1xuICAgIGlmIChpcy5lbGVtZW50KGJhZGdlKSkge1xuICAgICAgZmxleC5hcHBlbmRDaGlsZChiYWRnZSk7XG4gICAgfVxuICAgIG1lbnVJdGVtLmFwcGVuZENoaWxkKGZsZXgpO1xuXG4gICAgLy8gUmVwbGljYXRlIHJhZGlvIGJ1dHRvbiBiZWhhdmlvclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZW51SXRlbSwgJ2NoZWNrZWQnLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gbWVudUl0ZW0uZ2V0QXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnKSA9PT0gJ3RydWUnO1xuICAgICAgfSxcbiAgICAgIHNldChjaGVjaykge1xuICAgICAgICAvLyBFbnN1cmUgZXhjbHVzaXZpdHlcbiAgICAgICAgaWYgKGNoZWNrKSB7XG4gICAgICAgICAgQXJyYXkuZnJvbShtZW51SXRlbS5wYXJlbnROb2RlLmNoaWxkcmVuKS5maWx0ZXIobm9kZSA9PiBtYXRjaGVzKG5vZGUsICdbcm9sZT1cIm1lbnVpdGVtcmFkaW9cIl0nKSkuZm9yRWFjaChub2RlID0+IG5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnLCAnZmFsc2UnKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWVudUl0ZW0uc2V0QXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnLCBjaGVjayA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMubGlzdGVuZXJzLmJpbmQobWVudUl0ZW0sICdjbGljayBrZXl1cCcsIGV2ZW50ID0+IHtcbiAgICAgIGlmIChpcy5rZXlib2FyZEV2ZW50KGV2ZW50KSAmJiBldmVudC5rZXkgIT09ICcgJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBtZW51SXRlbS5jaGVja2VkID0gdHJ1ZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdsYW5ndWFnZSc6XG4gICAgICAgICAgdGhpcy5jdXJyZW50VHJhY2sgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdxdWFsaXR5JzpcbiAgICAgICAgICB0aGlzLnF1YWxpdHkgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3BlZWQnOlxuICAgICAgICAgIHRoaXMuc3BlZWQgPSBOdW1iZXIucGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb250cm9scy5zaG93TWVudVBhbmVsLmNhbGwodGhpcywgJ2hvbWUnLCBpcy5rZXlib2FyZEV2ZW50KGV2ZW50KSk7XG4gICAgfSwgdHlwZSwgZmFsc2UpO1xuICAgIGNvbnRyb2xzLmJpbmRNZW51SXRlbVNob3J0Y3V0cy5jYWxsKHRoaXMsIG1lbnVJdGVtLCB0eXBlKTtcbiAgICBsaXN0LmFwcGVuZENoaWxkKG1lbnVJdGVtKTtcbiAgfSxcbiAgLy8gRm9ybWF0IGEgdGltZSBmb3IgZGlzcGxheVxuICBmb3JtYXRUaW1lKHRpbWUgPSAwLCBpbnZlcnRlZCA9IGZhbHNlKSB7XG4gICAgLy8gQmFpbCBpZiB0aGUgdmFsdWUgaXNuJ3QgYSBudW1iZXJcbiAgICBpZiAoIWlzLm51bWJlcih0aW1lKSkge1xuICAgICAgcmV0dXJuIHRpbWU7XG4gICAgfVxuXG4gICAgLy8gQWx3YXlzIGRpc3BsYXkgaG91cnMgaWYgZHVyYXRpb24gaXMgb3ZlciBhbiBob3VyXG4gICAgY29uc3QgZm9yY2VIb3VycyA9IGdldEhvdXJzKHRoaXMuZHVyYXRpb24pID4gMDtcbiAgICByZXR1cm4gZm9ybWF0VGltZSh0aW1lLCBmb3JjZUhvdXJzLCBpbnZlcnRlZCk7XG4gIH0sXG4gIC8vIFVwZGF0ZSB0aGUgZGlzcGxheWVkIHRpbWVcbiAgdXBkYXRlVGltZURpc3BsYXkodGFyZ2V0ID0gbnVsbCwgdGltZSA9IDAsIGludmVydGVkID0gZmFsc2UpIHtcbiAgICAvLyBCYWlsIGlmIHRoZXJlJ3Mgbm8gZWxlbWVudCB0byBkaXNwbGF5IG9yIHRoZSB2YWx1ZSBpc24ndCBhIG51bWJlclxuICAgIGlmICghaXMuZWxlbWVudCh0YXJnZXQpIHx8ICFpcy5udW1iZXIodGltZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGFyZ2V0LnRleHRDb250ZW50ID0gY29udHJvbHMuZm9ybWF0VGltZSh0aW1lLCBpbnZlcnRlZCk7XG4gIH0sXG4gIC8vIFVwZGF0ZSB2b2x1bWUgVUkgYW5kIHN0b3JhZ2VcbiAgdXBkYXRlVm9sdW1lKCkge1xuICAgIGlmICghdGhpcy5zdXBwb3J0ZWQudWkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgcmFuZ2VcbiAgICBpZiAoaXMuZWxlbWVudCh0aGlzLmVsZW1lbnRzLmlucHV0cy52b2x1bWUpKSB7XG4gICAgICBjb250cm9scy5zZXRSYW5nZS5jYWxsKHRoaXMsIHRoaXMuZWxlbWVudHMuaW5wdXRzLnZvbHVtZSwgdGhpcy5tdXRlZCA/IDAgOiB0aGlzLnZvbHVtZSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIG11dGUgc3RhdGVcbiAgICBpZiAoaXMuZWxlbWVudCh0aGlzLmVsZW1lbnRzLmJ1dHRvbnMubXV0ZSkpIHtcbiAgICAgIHRoaXMuZWxlbWVudHMuYnV0dG9ucy5tdXRlLnByZXNzZWQgPSB0aGlzLm11dGVkIHx8IHRoaXMudm9sdW1lID09PSAwO1xuICAgIH1cbiAgfSxcbiAgLy8gVXBkYXRlIHNlZWsgdmFsdWUgYW5kIGxvd2VyIGZpbGxcbiAgc2V0UmFuZ2UodGFyZ2V0LCB2YWx1ZSA9IDApIHtcbiAgICBpZiAoIWlzLmVsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0YXJnZXQudmFsdWUgPSB2YWx1ZTtcblxuICAgIC8vIFdlYmtpdCByYW5nZSBmaWxsXG4gICAgY29udHJvbHMudXBkYXRlUmFuZ2VGaWxsLmNhbGwodGhpcywgdGFyZ2V0KTtcbiAgfSxcbiAgLy8gVXBkYXRlIDxwcm9ncmVzcz4gZWxlbWVudHNcbiAgdXBkYXRlUHJvZ3Jlc3MoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuc3VwcG9ydGVkLnVpIHx8ICFpcy5ldmVudChldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHZhbHVlID0gMDtcbiAgICBjb25zdCBzZXRQcm9ncmVzcyA9ICh0YXJnZXQsIGlucHV0KSA9PiB7XG4gICAgICBjb25zdCB2YWwgPSBpcy5udW1iZXIoaW5wdXQpID8gaW5wdXQgOiAwO1xuICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBpcy5lbGVtZW50KHRhcmdldCkgPyB0YXJnZXQgOiB0aGlzLmVsZW1lbnRzLmRpc3BsYXkuYnVmZmVyO1xuXG4gICAgICAvLyBVcGRhdGUgdmFsdWUgYW5kIGxhYmVsXG4gICAgICBpZiAoaXMuZWxlbWVudChwcm9ncmVzcykpIHtcbiAgICAgICAgcHJvZ3Jlc3MudmFsdWUgPSB2YWw7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRleHQgbGFiZWwgaW5zaWRlXG4gICAgICAgIGNvbnN0IGxhYmVsID0gcHJvZ3Jlc3MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NwYW4nKVswXTtcbiAgICAgICAgaWYgKGlzLmVsZW1lbnQobGFiZWwpKSB7XG4gICAgICAgICAgbGFiZWwuY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChldmVudCkge1xuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgIC8vIFZpZGVvIHBsYXlpbmdcbiAgICAgICAgY2FzZSAndGltZXVwZGF0ZSc6XG4gICAgICAgIGNhc2UgJ3NlZWtpbmcnOlxuICAgICAgICBjYXNlICdzZWVrZWQnOlxuICAgICAgICAgIHZhbHVlID0gZ2V0UGVyY2VudGFnZSh0aGlzLmN1cnJlbnRUaW1lLCB0aGlzLmR1cmF0aW9uKTtcblxuICAgICAgICAgIC8vIFNldCBzZWVrIHJhbmdlIHZhbHVlIG9ubHkgaWYgaXQncyBhICduYXR1cmFsJyB0aW1lIGV2ZW50XG4gICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICd0aW1ldXBkYXRlJykge1xuICAgICAgICAgICAgY29udHJvbHMuc2V0UmFuZ2UuY2FsbCh0aGlzLCB0aGlzLmVsZW1lbnRzLmlucHV0cy5zZWVrLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIENoZWNrIGJ1ZmZlciBzdGF0dXNcbiAgICAgICAgY2FzZSAncGxheWluZyc6XG4gICAgICAgIGNhc2UgJ3Byb2dyZXNzJzpcbiAgICAgICAgICBzZXRQcm9ncmVzcyh0aGlzLmVsZW1lbnRzLmRpc3BsYXkuYnVmZmVyLCB0aGlzLmJ1ZmZlcmVkICogMTAwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8vIFdlYmtpdCBwb2x5ZmlsbCBmb3IgbG93ZXIgZmlsbCByYW5nZVxuICB1cGRhdGVSYW5nZUZpbGwodGFyZ2V0KSB7XG4gICAgLy8gR2V0IHJhbmdlIGZyb20gZXZlbnQgaWYgZXZlbnQgcGFzc2VkXG4gICAgY29uc3QgcmFuZ2UgPSBpcy5ldmVudCh0YXJnZXQpID8gdGFyZ2V0LnRhcmdldCA6IHRhcmdldDtcblxuICAgIC8vIE5lZWRzIHRvIGJlIGEgdmFsaWQgPGlucHV0IHR5cGU9J3JhbmdlJz5cbiAgICBpZiAoIWlzLmVsZW1lbnQocmFuZ2UpIHx8IHJhbmdlLmdldEF0dHJpYnV0ZSgndHlwZScpICE9PSAncmFuZ2UnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2V0IGFyaWEgdmFsdWVzIGZvciBodHRwczovL2dpdGh1Yi5jb20vc2FtcG90dHMvcGx5ci9pc3N1ZXMvOTA1XG4gICAgaWYgKG1hdGNoZXMocmFuZ2UsIHRoaXMuY29uZmlnLnNlbGVjdG9ycy5pbnB1dHMuc2VlaykpIHtcbiAgICAgIHJhbmdlLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZW5vdycsIHRoaXMuY3VycmVudFRpbWUpO1xuICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBjb250cm9scy5mb3JtYXRUaW1lKHRoaXMuY3VycmVudFRpbWUpO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBjb250cm9scy5mb3JtYXRUaW1lKHRoaXMuZHVyYXRpb24pO1xuICAgICAgY29uc3QgZm9ybWF0ID0gaTE4bi5nZXQoJ3NlZWtMYWJlbCcsIHRoaXMuY29uZmlnKTtcbiAgICAgIHJhbmdlLnNldEF0dHJpYnV0ZSgnYXJpYS12YWx1ZXRleHQnLCBmb3JtYXQucmVwbGFjZSgne2N1cnJlbnRUaW1lfScsIGN1cnJlbnRUaW1lKS5yZXBsYWNlKCd7ZHVyYXRpb259JywgZHVyYXRpb24pKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoZXMocmFuZ2UsIHRoaXMuY29uZmlnLnNlbGVjdG9ycy5pbnB1dHMudm9sdW1lKSkge1xuICAgICAgY29uc3QgcGVyY2VudCA9IHJhbmdlLnZhbHVlICogMTAwO1xuICAgICAgcmFuZ2Uuc2V0QXR0cmlidXRlKCdhcmlhLXZhbHVlbm93JywgcGVyY2VudCk7XG4gICAgICByYW5nZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWV0ZXh0JywgYCR7cGVyY2VudC50b0ZpeGVkKDEpfSVgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2Uuc2V0QXR0cmlidXRlKCdhcmlhLXZhbHVlbm93JywgcmFuZ2UudmFsdWUpO1xuICAgIH1cblxuICAgIC8vIFdlYktpdCBvbmx5XG4gICAgaWYgKCFicm93c2VyLmlzV2ViS2l0ICYmICFicm93c2VyLmlzSVBhZE9TKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2V0IENTUyBjdXN0b20gcHJvcGVydHlcbiAgICByYW5nZS5zdHlsZS5zZXRQcm9wZXJ0eSgnLS12YWx1ZScsIGAke3JhbmdlLnZhbHVlIC8gcmFuZ2UubWF4ICogMTAwfSVgKTtcbiAgfSxcbiAgLy8gVXBkYXRlIGhvdmVyIHRvb2x0aXAgZm9yIHNlZWtpbmdcbiAgdXBkYXRlU2Vla1Rvb2x0aXAoZXZlbnQpIHtcbiAgICB2YXIgX3RoaXMkY29uZmlnJG1hcmtlcnMsIF90aGlzJGNvbmZpZyRtYXJrZXJzJDtcbiAgICAvLyBCYWlsIGlmIHNldHRpbmcgbm90IHRydWVcbiAgICBpZiAoIXRoaXMuY29uZmlnLnRvb2x0aXBzLnNlZWsgfHwgIWlzLmVsZW1lbnQodGhpcy5lbGVtZW50cy5pbnB1dHMuc2VlaykgfHwgIWlzLmVsZW1lbnQodGhpcy5lbGVtZW50cy5kaXNwbGF5LnNlZWtUb29sdGlwKSB8fCB0aGlzLmR1cmF0aW9uID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRpcEVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzLmRpc3BsYXkuc2Vla1Rvb2x0aXA7XG4gICAgY29uc3QgdmlzaWJsZSA9IGAke3RoaXMuY29uZmlnLmNsYXNzTmFtZXMudG9vbHRpcH0tLXZpc2libGVgO1xuICAgIGNvbnN0IHRvZ2dsZSA9IHNob3cgPT4gdG9nZ2xlQ2xhc3ModGlwRWxlbWVudCwgdmlzaWJsZSwgc2hvdyk7XG5cbiAgICAvLyBIaWRlIG9uIHRvdWNoXG4gICAgaWYgKHRoaXMudG91Y2gpIHtcbiAgICAgIHRvZ2dsZShmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGV0ZXJtaW5lIHBlcmNlbnRhZ2UsIGlmIGFscmVhZHkgdmlzaWJsZVxuICAgIGxldCBwZXJjZW50ID0gMDtcbiAgICBjb25zdCBjbGllbnRSZWN0ID0gdGhpcy5lbGVtZW50cy5wcm9ncmVzcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoaXMuZXZlbnQoZXZlbnQpKSB7XG4gICAgICBjb25zdCBzY3JvbGxMZWZ0ID0gZXZlbnQucGFnZVggLSBldmVudC5jbGllbnRYO1xuICAgICAgcGVyY2VudCA9IDEwMCAvIGNsaWVudFJlY3Qud2lkdGggKiAoZXZlbnQucGFnZVggLSBjbGllbnRSZWN0LmxlZnQgLSBzY3JvbGxMZWZ0KTtcbiAgICB9IGVsc2UgaWYgKGhhc0NsYXNzKHRpcEVsZW1lbnQsIHZpc2libGUpKSB7XG4gICAgICBwZXJjZW50ID0gTnVtYmVyLnBhcnNlRmxvYXQodGlwRWxlbWVudC5zdHlsZS5sZWZ0LCAxMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTZXQgYm91bmRzXG4gICAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgICBwZXJjZW50ID0gMDtcbiAgICB9IGVsc2UgaWYgKHBlcmNlbnQgPiAxMDApIHtcbiAgICAgIHBlcmNlbnQgPSAxMDA7XG4gICAgfVxuICAgIGNvbnN0IHRpbWUgPSB0aGlzLmR1cmF0aW9uIC8gMTAwICogcGVyY2VudDtcblxuICAgIC8vIERpc3BsYXkgdGhlIHRpbWUgYSBjbGljayB3b3VsZCBzZWVrIHRvXG4gICAgdGlwRWxlbWVudC50ZXh0Q29udGVudCA9IGNvbnRyb2xzLmZvcm1hdFRpbWUodGltZSk7XG5cbiAgICAvLyBHZXQgbWFya2VyIHBvaW50IGZvciB0aW1lXG4gICAgY29uc3QgcG9pbnQgPSAoX3RoaXMkY29uZmlnJG1hcmtlcnMgPSB0aGlzLmNvbmZpZy5tYXJrZXJzKSA9PT0gbnVsbCB8fCBfdGhpcyRjb25maWckbWFya2VycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF90aGlzJGNvbmZpZyRtYXJrZXJzJCA9IF90aGlzJGNvbmZpZyRtYXJrZXJzLnBvaW50cykgPT09IG51bGwgfHwgX3RoaXMkY29uZmlnJG1hcmtlcnMkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRjb25maWckbWFya2VycyQuZmluZCgoe1xuICAgICAgdGltZTogdFxuICAgIH0pID0+IHQgPT09IE1hdGgucm91bmQodGltZSkpO1xuXG4gICAgLy8gQXBwZW5kIHRoZSBwb2ludCBsYWJlbCB0byB0aGUgdG9vbHRpcFxuICAgIGlmIChwb2ludCkge1xuICAgICAgdGlwRWxlbWVudC5pbnNlcnRBZGphY2VudEhUTUwoJ2FmdGVyYmVnaW4nLCBgJHtwb2ludC5sYWJlbH08YnI+YCk7XG4gICAgfVxuXG4gICAgLy8gU2V0IHBvc2l0aW9uXG4gICAgdGlwRWxlbWVudC5zdHlsZS5sZWZ0ID0gYCR7cGVyY2VudH0lYDtcblxuICAgIC8vIFNob3cvaGlkZSB0aGUgdG9vbHRpcFxuICAgIC8vIElmIHRoZSBldmVudCBpcyBhIG1vdWVzIGluL291dCBhbmQgcGVyY2VudGFnZSBpcyBpbnNpZGUgYm91bmRzXG4gICAgaWYgKGlzLmV2ZW50KGV2ZW50KSAmJiBbJ21vdXNlZW50ZXInLCAnbW91c2VsZWF2ZSddLmluY2x1ZGVzKGV2ZW50LnR5cGUpKSB7XG4gICAgICB0b2dnbGUoZXZlbnQudHlwZSA9PT0gJ21vdXNlZW50ZXInKTtcbiAgICB9XG4gIH0sXG4gIC8vIEhhbmRsZSB0aW1lIGNoYW5nZSBldmVudFxuICB0aW1lVXBkYXRlKGV2ZW50KSB7XG4gICAgLy8gT25seSBpbnZlcnQgaWYgb25seSBvbmUgdGltZSBlbGVtZW50IGlzIGRpc3BsYXllZCBhbmQgdXNlZCBmb3IgYm90aCBkdXJhdGlvbiBhbmQgY3VycmVudFRpbWVcbiAgICBjb25zdCBpbnZlcnQgPSAhaXMuZWxlbWVudCh0aGlzLmVsZW1lbnRzLmRpc3BsYXkuZHVyYXRpb24pICYmIHRoaXMuY29uZmlnLmludmVydFRpbWU7XG5cbiAgICAvLyBEdXJhdGlvblxuICAgIGNvbnRyb2xzLnVwZGF0ZVRpbWVEaXNwbGF5LmNhbGwodGhpcywgdGhpcy5lbGVtZW50cy5kaXNwbGF5LmN1cnJlbnRUaW1lLCBpbnZlcnQgPyB0aGlzLmR1cmF0aW9uIC0gdGhpcy5jdXJyZW50VGltZSA6IHRoaXMuY3VycmVudFRpbWUsIGludmVydCk7XG5cbiAgICAvLyBJZ25vcmUgdXBkYXRlcyB3aGlsZSBzZWVraW5nXG4gICAgaWYgKGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09ICd0aW1ldXBkYXRlJyAmJiB0aGlzLm1lZGlhLnNlZWtpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQbGF5aW5nIHByb2dyZXNzXG4gICAgY29udHJvbHMudXBkYXRlUHJvZ3Jlc3MuY2FsbCh0aGlzLCBldmVudCk7XG4gIH0sXG4gIC8vIFNob3cgdGhlIGR1cmF0aW9uIG9uIG1ldGFkYXRhbG9hZGVkIG9yIGR1cmF0aW9uY2hhbmdlIGV2ZW50c1xuICBkdXJhdGlvblVwZGF0ZSgpIHtcbiAgICAvLyBCYWlsIGlmIG5vIFVJIG9yIGR1cmF0aW9uY2hhbmdlIGV2ZW50IHRyaWdnZXJlZCBhZnRlciBwbGF5aW5nL3NlZWsgd2hlbiBpbnZlcnRUaW1lIGlzIGZhbHNlXG4gICAgaWYgKCF0aGlzLnN1cHBvcnRlZC51aSB8fCAhdGhpcy5jb25maWcuaW52ZXJ0VGltZSAmJiB0aGlzLmN1cnJlbnRUaW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgZHVyYXRpb24gaXMgdGhlIDIqKjMyIChzaGFrYSksIEluZmluaXR5IChITFMpLCBEQVNILUlGIChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCBOdW1iZXIuTUFYX1ZBTFVFKSBpbmRpY2F0aW5nIGxpdmUgd2UgaGlkZSB0aGUgY3VycmVudFRpbWUgYW5kIHByb2dyZXNzYmFyLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92aWRlby1kZXYvaGxzLmpzL2Jsb2IvNTgyMGQyOWQzYzRjOGE0NmU4Yjc1ZjFlM2FmYTNlNjhjMWE5YTJkYi9zcmMvY29udHJvbGxlci9idWZmZXItY29udHJvbGxlci5qcyNMNDE1XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9zaGFrYS1wbGF5ZXIvYmxvYi80ZDg4OTA1NDYzMWY0ZTFjZjBmYmQ4MGRkZDJiNzE4ODdjMDJlMjMyL2xpYi9tZWRpYS9zdHJlYW1pbmdfZW5naW5lLmpzI0wxMDYyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0Rhc2gtSW5kdXN0cnktRm9ydW0vZGFzaC5qcy9ibG9iLzY5ODU5ZjUxYjk2OTY0NWIyMzQ2NjY4MDBkNGNiNTk2ZDg5YzYwMmQvc3JjL2Rhc2gvbW9kZWxzL0Rhc2hNYW5pZmVzdE1vZGVsLmpzI0wzMzhcbiAgICBpZiAodGhpcy5kdXJhdGlvbiA+PSAyICoqIDMyKSB7XG4gICAgICB0b2dnbGVIaWRkZW4odGhpcy5lbGVtZW50cy5kaXNwbGF5LmN1cnJlbnRUaW1lLCB0cnVlKTtcbiAgICAgIHRvZ2dsZUhpZGRlbih0aGlzLmVsZW1lbnRzLnByb2dyZXNzLCB0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgQVJJQSB2YWx1ZXNcbiAgICBpZiAoaXMuZWxlbWVudCh0aGlzLmVsZW1lbnRzLmlucHV0cy5zZWVrKSkge1xuICAgICAgdGhpcy5lbGVtZW50cy5pbnB1dHMuc2Vlay5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWVtYXgnLCB0aGlzLmR1cmF0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSdzIGEgc3BvdCB0byBkaXNwbGF5IGR1cmF0aW9uXG4gICAgY29uc3QgaGFzRHVyYXRpb24gPSBpcy5lbGVtZW50KHRoaXMuZWxlbWVudHMuZGlzcGxheS5kdXJhdGlvbik7XG5cbiAgICAvLyBJZiB0aGVyZSdzIG9ubHkgb25lIHRpbWUgZGlzcGxheSwgZGlzcGxheSBkdXJhdGlvbiB0aGVyZVxuICAgIGlmICghaGFzRHVyYXRpb24gJiYgdGhpcy5jb25maWcuZGlzcGxheUR1cmF0aW9uICYmIHRoaXMucGF1c2VkKSB7XG4gICAgICBjb250cm9scy51cGRhdGVUaW1lRGlzcGxheS5jYWxsKHRoaXMsIHRoaXMuZWxlbWVudHMuZGlzcGxheS5jdXJyZW50VGltZSwgdGhpcy5kdXJhdGlvbik7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUncyBhIGR1cmF0aW9uIGVsZW1lbnQsIHVwZGF0ZSBjb250ZW50XG4gICAgaWYgKGhhc0R1cmF0aW9uKSB7XG4gICAgICBjb250cm9scy51cGRhdGVUaW1lRGlzcGxheS5jYWxsKHRoaXMsIHRoaXMuZWxlbWVudHMuZGlzcGxheS5kdXJhdGlvbiwgdGhpcy5kdXJhdGlvbik7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbmZpZy5tYXJrZXJzLmVuYWJsZWQpIHtcbiAgICAgIGNvbnRyb2xzLnNldE1hcmtlcnMuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIHRvb2x0aXAgKGlmIHZpc2libGUpXG4gICAgY29udHJvbHMudXBkYXRlU2Vla1Rvb2x0aXAuY2FsbCh0aGlzKTtcbiAgfSxcbiAgLy8gSGlkZS9zaG93IGEgdGFiXG4gIHRvZ2dsZU1lbnVCdXR0b24oc2V0dGluZywgdG9nZ2xlKSB7XG4gICAgdG9nZ2xlSGlkZGVuKHRoaXMuZWxlbWVudHMuc2V0dGluZ3MuYnV0dG9uc1tzZXR0aW5nXSwgIXRvZ2dsZSk7XG4gIH0sXG4gIC8vIFVwZGF0ZSB0aGUgc2VsZWN0ZWQgc2V0dGluZ1xuICB1cGRhdGVTZXR0aW5nKHNldHRpbmcsIGNvbnRhaW5lciwgaW5wdXQpIHtcbiAgICBjb25zdCBwYW5lID0gdGhpcy5lbGVtZW50cy5zZXR0aW5ncy5wYW5lbHNbc2V0dGluZ107XG4gICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICBsZXQgbGlzdCA9IGNvbnRhaW5lcjtcbiAgICBpZiAoc2V0dGluZyA9PT0gJ2NhcHRpb25zJykge1xuICAgICAgdmFsdWUgPSB0aGlzLmN1cnJlbnRUcmFjaztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSAhaXMuZW1wdHkoaW5wdXQpID8gaW5wdXQgOiB0aGlzW3NldHRpbmddO1xuXG4gICAgICAvLyBHZXQgZGVmYXVsdFxuICAgICAgaWYgKGlzLmVtcHR5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuY29uZmlnW3NldHRpbmddLmRlZmF1bHQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFVuc3VwcG9ydGVkIHZhbHVlXG4gICAgICBpZiAoIWlzLmVtcHR5KHRoaXMub3B0aW9uc1tzZXR0aW5nXSkgJiYgIXRoaXMub3B0aW9uc1tzZXR0aW5nXS5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5kZWJ1Zy53YXJuKGBVbnN1cHBvcnRlZCB2YWx1ZSBvZiAnJHt2YWx1ZX0nIGZvciAke3NldHRpbmd9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gRGlzYWJsZWQgdmFsdWVcbiAgICAgIGlmICghdGhpcy5jb25maWdbc2V0dGluZ10ub3B0aW9ucy5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5kZWJ1Zy53YXJuKGBEaXNhYmxlZCB2YWx1ZSBvZiAnJHt2YWx1ZX0nIGZvciAke3NldHRpbmd9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZXQgdGhlIGxpc3QgaWYgd2UgbmVlZCB0b1xuICAgIGlmICghaXMuZWxlbWVudChsaXN0KSkge1xuICAgICAgbGlzdCA9IHBhbmUgJiYgcGFuZS5xdWVyeVNlbGVjdG9yKCdbcm9sZT1cIm1lbnVcIl0nKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSdzIG5vIGxpc3QgaXQgbWVhbnMgaXQncyBub3QgYmVlbiByZW5kZXJlZC4uLlxuICAgIGlmICghaXMuZWxlbWVudChsaXN0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgbGFiZWxcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuZWxlbWVudHMuc2V0dGluZ3MuYnV0dG9uc1tzZXR0aW5nXS5xdWVyeVNlbGVjdG9yKGAuJHt0aGlzLmNvbmZpZy5jbGFzc05hbWVzLm1lbnUudmFsdWV9YCk7XG4gICAgbGFiZWwuaW5uZXJIVE1MID0gY29udHJvbHMuZ2V0TGFiZWwuY2FsbCh0aGlzLCBzZXR0aW5nLCB2YWx1ZSk7XG5cbiAgICAvLyBGaW5kIHRoZSByYWRpbyBvcHRpb24gYW5kIGNoZWNrIGl0XG4gICAgY29uc3QgdGFyZ2V0ID0gbGlzdCAmJiBsaXN0LnF1ZXJ5U2VsZWN0b3IoYFt2YWx1ZT1cIiR7dmFsdWV9XCJdYCk7XG4gICAgaWYgKGlzLmVsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgdGFyZ2V0LmNoZWNrZWQgPSB0cnVlO1xuICAgIH1cbiAgfSxcbiAgLy8gVHJhbnNsYXRlIGEgdmFsdWUgaW50byBhIG5pY2UgbGFiZWxcbiAgZ2V0TGFiZWwoc2V0dGluZywgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHNldHRpbmcpIHtcbiAgICAgIGNhc2UgJ3NwZWVkJzpcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAxID8gaTE4bi5nZXQoJ25vcm1hbCcsIHRoaXMuY29uZmlnKSA6IGAke3ZhbHVlfSZ0aW1lcztgO1xuICAgICAgY2FzZSAncXVhbGl0eSc6XG4gICAgICAgIGlmIChpcy5udW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgY29uc3QgbGFiZWwgPSBpMThuLmdldChgcXVhbGl0eUxhYmVsLiR7dmFsdWV9YCwgdGhpcy5jb25maWcpO1xuICAgICAgICAgIGlmICghbGFiZWwubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dmFsdWV9cGA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9UaXRsZUNhc2UodmFsdWUpO1xuICAgICAgY2FzZSAnY2FwdGlvbnMnOlxuICAgICAgICByZXR1cm4gY2FwdGlvbnMuZ2V0TGFiZWwuY2FsbCh0aGlzKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcbiAgLy8gU2V0IHRoZSBxdWFsaXR5IG1lbnVcbiAgc2V0UXVhbGl0eU1lbnUob3B0aW9ucykge1xuICAgIC8vIE1lbnUgcmVxdWlyZWRcbiAgICBpZiAoIWlzLmVsZW1lbnQodGhpcy5lbGVtZW50cy5zZXR0aW5ncy5wYW5lbHMucXVhbGl0eSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9ICdxdWFsaXR5JztcbiAgICBjb25zdCBsaXN0ID0gdGhpcy5lbGVtZW50cy5zZXR0aW5ncy5wYW5lbHMucXVhbGl0eS5xdWVyeVNlbGVjdG9yKCdbcm9sZT1cIm1lbnVcIl0nKTtcblxuICAgIC8vIFNldCBvcHRpb25zIGlmIHBhc3NlZCBhbmQgZmlsdGVyIGJhc2VkIG9uIHVuaXF1ZW5lc3MgYW5kIGNvbmZpZ1xuICAgIGlmIChpcy5hcnJheShvcHRpb25zKSkge1xuICAgICAgdGhpcy5vcHRpb25zLnF1YWxpdHkgPSBkZWR1cGUob3B0aW9ucykuZmlsdGVyKHF1YWxpdHkgPT4gdGhpcy5jb25maWcucXVhbGl0eS5vcHRpb25zLmluY2x1ZGVzKHF1YWxpdHkpKTtcbiAgICB9XG5cbiAgICAvLyBUb2dnbGUgdGhlIHBhbmUgYW5kIHRhYlxuICAgIGNvbnN0IHRvZ2dsZSA9ICFpcy5lbXB0eSh0aGlzLm9wdGlvbnMucXVhbGl0eSkgJiYgdGhpcy5vcHRpb25zLnF1YWxpdHkubGVuZ3RoID4gMTtcbiAgICBjb250cm9scy50b2dnbGVNZW51QnV0dG9uLmNhbGwodGhpcywgdHlwZSwgdG9nZ2xlKTtcblxuICAgIC8vIEVtcHR5IHRoZSBtZW51XG4gICAgZW1wdHlFbGVtZW50KGxpc3QpO1xuXG4gICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byB0b2dnbGUgdGhlIHBhcmVudFxuICAgIGNvbnRyb2xzLmNoZWNrTWVudS5jYWxsKHRoaXMpO1xuXG4gICAgLy8gSWYgd2UncmUgaGlkaW5nLCBub3RoaW5nIG1vcmUgdG8gZG9cbiAgICBpZiAoIXRvZ2dsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgYmFkZ2UgSFRNTCBmb3IgSEQsIDRLIGV0Y1xuICAgIGNvbnN0IGdldEJhZGdlID0gcXVhbGl0eSA9PiB7XG4gICAgICBjb25zdCBsYWJlbCA9IGkxOG4uZ2V0KGBxdWFsaXR5QmFkZ2UuJHtxdWFsaXR5fWAsIHRoaXMuY29uZmlnKTtcbiAgICAgIGlmICghbGFiZWwubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRyb2xzLmNyZWF0ZUJhZGdlLmNhbGwodGhpcywgbGFiZWwpO1xuICAgIH07XG5cbiAgICAvLyBTb3J0IG9wdGlvbnMgYnkgdGhlIGNvbmZpZyBhbmQgdGhlbiByZW5kZXIgb3B0aW9uc1xuICAgIHRoaXMub3B0aW9ucy5xdWFsaXR5LnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IHNvcnRpbmcgPSB0aGlzLmNvbmZpZy5xdWFsaXR5Lm9wdGlvbnM7XG4gICAgICByZXR1cm4gc29ydGluZy5pbmRleE9mKGEpID4gc29ydGluZy5pbmRleE9mKGIpID8gMSA6IC0xO1xuICAgIH0pLmZvckVhY2gocXVhbGl0eSA9PiB7XG4gICAgICBjb250cm9scy5jcmVhdGVNZW51SXRlbS5jYWxsKHRoaXMsIHtcbiAgICAgICAgdmFsdWU6IHF1YWxpdHksXG4gICAgICAgIGxpc3QsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHRpdGxlOiBjb250cm9scy5nZXRMYWJlbC5jYWxsKHRoaXMsICdxdWFsaXR5JywgcXVhbGl0eSksXG4gICAgICAgIGJhZGdlOiBnZXRCYWRnZShxdWFsaXR5KVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29udHJvbHMudXBkYXRlU2V0dGluZy5jYWxsKHRoaXMsIHR5cGUsIGxpc3QpO1xuICB9LFxuICAvLyBTZXQgdGhlIGxvb3Bpbmcgb3B0aW9uc1xuICAvKiBzZXRMb29wTWVudSgpIHtcbiAgICAgICAgLy8gTWVudSByZXF1aXJlZFxuICAgICAgICBpZiAoIWlzLmVsZW1lbnQodGhpcy5lbGVtZW50cy5zZXR0aW5ncy5wYW5lbHMubG9vcCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IFsnc3RhcnQnLCAnZW5kJywgJ2FsbCcsICdyZXNldCddO1xuICAgICAgICBjb25zdCBsaXN0ID0gdGhpcy5lbGVtZW50cy5zZXR0aW5ncy5wYW5lbHMubG9vcC5xdWVyeVNlbGVjdG9yKCdbcm9sZT1cIm1lbnVcIl0nKTtcbiAgICAgICAgIC8vIFNob3cgdGhlIHBhbmUgYW5kIHRhYlxuICAgICAgICB0b2dnbGVIaWRkZW4odGhpcy5lbGVtZW50cy5zZXR0aW5ncy5idXR0b25zLmxvb3AsIGZhbHNlKTtcbiAgICAgICAgdG9nZ2xlSGlkZGVuKHRoaXMuZWxlbWVudHMuc2V0dGluZ3MucGFuZWxzLmxvb3AsIGZhbHNlKTtcbiAgICAgICAgIC8vIFRvZ2dsZSB0aGUgcGFuZSBhbmQgdGFiXG4gICAgICAgIGNvbnN0IHRvZ2dsZSA9ICFpcy5lbXB0eSh0aGlzLmxvb3Aub3B0aW9ucyk7XG4gICAgICAgIGNvbnRyb2xzLnRvZ2dsZU1lbnVCdXR0b24uY2FsbCh0aGlzLCAnbG9vcCcsIHRvZ2dsZSk7XG4gICAgICAgICAvLyBFbXB0eSB0aGUgbWVudVxuICAgICAgICBlbXB0eUVsZW1lbnQobGlzdCk7XG4gICAgICAgICBvcHRpb25zLmZvckVhY2gob3B0aW9uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBjcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICAgICAgIGNvbnN0IGJ1dHRvbiA9IGNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ2J1dHRvbicsXG4gICAgICAgICAgICAgICAgZXh0ZW5kKGdldEF0dHJpYnV0ZXNGcm9tU2VsZWN0b3IodGhpcy5jb25maWcuc2VsZWN0b3JzLmJ1dHRvbnMubG9vcCksIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2J1dHRvbicsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiB0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmNvbnRyb2wsXG4gICAgICAgICAgICAgICAgICAgICdkYXRhLXBseXItbG9vcC1hY3Rpb24nOiBvcHRpb24sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgaTE4bi5nZXQob3B0aW9uLCB0aGlzLmNvbmZpZylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgaWYgKFsnc3RhcnQnLCAnZW5kJ10uaW5jbHVkZXMob3B0aW9uKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhZGdlID0gY29udHJvbHMuY3JlYXRlQmFkZ2UuY2FsbCh0aGlzLCAnMDA6MDAnKTtcbiAgICAgICAgICAgICAgICBidXR0b24uYXBwZW5kQ2hpbGQoYmFkZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgIGl0ZW0uYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgICAgICAgIGxpc3QuYXBwZW5kQ2hpbGQoaXRlbSk7XG4gICAgICAgIH0pO1xuICAgIH0sICovXG5cbiAgLy8gR2V0IGN1cnJlbnQgc2VsZWN0ZWQgY2FwdGlvbiBsYW5ndWFnZVxuICAvLyBUT0RPOiByZXdvcmsgdGhpcyB0byB1c2VyIHRoZSBnZXR0ZXIgaW4gdGhlIEFQST9cblxuICAvLyBTZXQgYSBsaXN0IG9mIGF2YWlsYWJsZSBjYXB0aW9ucyBsYW5ndWFnZXNcbiAgc2V0Q2FwdGlvbnNNZW51KCkge1xuICAgIC8vIE1lbnUgcmVxdWlyZWRcbiAgICBpZiAoIWlzLmVsZW1lbnQodGhpcy5lbGVtZW50cy5zZXR0aW5ncy5wYW5lbHMuY2FwdGlvbnMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVE9ETzogQ2FwdGlvbnMgb3IgbGFuZ3VhZ2U/IEN1cnJlbnRseSBpdCdzIG1peGVkXG4gICAgY29uc3QgdHlwZSA9ICdjYXB0aW9ucyc7XG4gICAgY29uc3QgbGlzdCA9IHRoaXMuZWxlbWVudHMuc2V0dGluZ3MucGFuZWxzLmNhcHRpb25zLnF1ZXJ5U2VsZWN0b3IoJ1tyb2xlPVwibWVudVwiXScpO1xuICAgIGNvbnN0IHRyYWNrcyA9IGNhcHRpb25zLmdldFRyYWNrcy5jYWxsKHRoaXMpO1xuICAgIGNvbnN0IHRvZ2dsZSA9IEJvb2xlYW4odHJhY2tzLmxlbmd0aCk7XG5cbiAgICAvLyBUb2dnbGUgdGhlIHBhbmUgYW5kIHRhYlxuICAgIGNvbnRyb2xzLnRvZ2dsZU1lbnVCdXR0b24uY2FsbCh0aGlzLCB0eXBlLCB0b2dnbGUpO1xuXG4gICAgLy8gRW1wdHkgdGhlIG1lbnVcbiAgICBlbXB0eUVsZW1lbnQobGlzdCk7XG5cbiAgICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIHRvZ2dsZSB0aGUgcGFyZW50XG4gICAgY29udHJvbHMuY2hlY2tNZW51LmNhbGwodGhpcyk7XG5cbiAgICAvLyBJZiB0aGVyZSdzIG5vIGNhcHRpb25zLCBiYWlsXG4gICAgaWYgKCF0b2dnbGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBvcHRpb25zIGRhdGFcbiAgICBjb25zdCBvcHRpb25zID0gdHJhY2tzLm1hcCgodHJhY2ssIHZhbHVlKSA9PiAoe1xuICAgICAgdmFsdWUsXG4gICAgICBjaGVja2VkOiB0aGlzLmNhcHRpb25zLnRvZ2dsZWQgJiYgdGhpcy5jdXJyZW50VHJhY2sgPT09IHZhbHVlLFxuICAgICAgdGl0bGU6IGNhcHRpb25zLmdldExhYmVsLmNhbGwodGhpcywgdHJhY2spLFxuICAgICAgYmFkZ2U6IHRyYWNrLmxhbmd1YWdlICYmIGNvbnRyb2xzLmNyZWF0ZUJhZGdlLmNhbGwodGhpcywgdHJhY2subGFuZ3VhZ2UudG9VcHBlckNhc2UoKSksXG4gICAgICBsaXN0LFxuICAgICAgdHlwZTogJ2xhbmd1YWdlJ1xuICAgIH0pKTtcblxuICAgIC8vIEFkZCB0aGUgXCJEaXNhYmxlZFwiIG9wdGlvbiB0byB0dXJuIG9mZiBjYXB0aW9uc1xuICAgIG9wdGlvbnMudW5zaGlmdCh7XG4gICAgICB2YWx1ZTogLTEsXG4gICAgICBjaGVja2VkOiAhdGhpcy5jYXB0aW9ucy50b2dnbGVkLFxuICAgICAgdGl0bGU6IGkxOG4uZ2V0KCdkaXNhYmxlZCcsIHRoaXMuY29uZmlnKSxcbiAgICAgIGxpc3QsXG4gICAgICB0eXBlOiAnbGFuZ3VhZ2UnXG4gICAgfSk7XG5cbiAgICAvLyBHZW5lcmF0ZSBvcHRpb25zXG4gICAgb3B0aW9ucy5mb3JFYWNoKGNvbnRyb2xzLmNyZWF0ZU1lbnVJdGVtLmJpbmQodGhpcykpO1xuICAgIGNvbnRyb2xzLnVwZGF0ZVNldHRpbmcuY2FsbCh0aGlzLCB0eXBlLCBsaXN0KTtcbiAgfSxcbiAgLy8gU2V0IGEgbGlzdCBvZiBhdmFpbGFibGUgY2FwdGlvbnMgbGFuZ3VhZ2VzXG4gIHNldFNwZWVkTWVudSgpIHtcbiAgICAvLyBNZW51IHJlcXVpcmVkXG4gICAgaWYgKCFpcy5lbGVtZW50KHRoaXMuZWxlbWVudHMuc2V0dGluZ3MucGFuZWxzLnNwZWVkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gJ3NwZWVkJztcbiAgICBjb25zdCBsaXN0ID0gdGhpcy5lbGVtZW50cy5zZXR0aW5ncy5wYW5lbHMuc3BlZWQucXVlcnlTZWxlY3RvcignW3JvbGU9XCJtZW51XCJdJyk7XG5cbiAgICAvLyBGaWx0ZXIgb3V0IGludmFsaWQgc3BlZWRzXG4gICAgdGhpcy5vcHRpb25zLnNwZWVkID0gdGhpcy5vcHRpb25zLnNwZWVkLmZpbHRlcihvID0+IG8gPj0gdGhpcy5taW5pbXVtU3BlZWQgJiYgbyA8PSB0aGlzLm1heGltdW1TcGVlZCk7XG5cbiAgICAvLyBUb2dnbGUgdGhlIHBhbmUgYW5kIHRhYlxuICAgIGNvbnN0IHRvZ2dsZSA9ICFpcy5lbXB0eSh0aGlzLm9wdGlvbnMuc3BlZWQpICYmIHRoaXMub3B0aW9ucy5zcGVlZC5sZW5ndGggPiAxO1xuICAgIGNvbnRyb2xzLnRvZ2dsZU1lbnVCdXR0b24uY2FsbCh0aGlzLCB0eXBlLCB0b2dnbGUpO1xuXG4gICAgLy8gRW1wdHkgdGhlIG1lbnVcbiAgICBlbXB0eUVsZW1lbnQobGlzdCk7XG5cbiAgICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIHRvZ2dsZSB0aGUgcGFyZW50XG4gICAgY29udHJvbHMuY2hlY2tNZW51LmNhbGwodGhpcyk7XG5cbiAgICAvLyBJZiB3ZSdyZSBoaWRpbmcsIG5vdGhpbmcgbW9yZSB0byBkb1xuICAgIGlmICghdG9nZ2xlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGl0ZW1zXG4gICAgdGhpcy5vcHRpb25zLnNwZWVkLmZvckVhY2goc3BlZWQgPT4ge1xuICAgICAgY29udHJvbHMuY3JlYXRlTWVudUl0ZW0uY2FsbCh0aGlzLCB7XG4gICAgICAgIHZhbHVlOiBzcGVlZCxcbiAgICAgICAgbGlzdCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdGl0bGU6IGNvbnRyb2xzLmdldExhYmVsLmNhbGwodGhpcywgJ3NwZWVkJywgc3BlZWQpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjb250cm9scy51cGRhdGVTZXR0aW5nLmNhbGwodGhpcywgdHlwZSwgbGlzdCk7XG4gIH0sXG4gIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gaGlkZS9zaG93IHRoZSBzZXR0aW5ncyBtZW51XG4gIGNoZWNrTWVudSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBidXR0b25zXG4gICAgfSA9IHRoaXMuZWxlbWVudHMuc2V0dGluZ3M7XG4gICAgY29uc3QgdmlzaWJsZSA9ICFpcy5lbXB0eShidXR0b25zKSAmJiBPYmplY3QudmFsdWVzKGJ1dHRvbnMpLnNvbWUoYnV0dG9uID0+ICFidXR0b24uaGlkZGVuKTtcbiAgICB0b2dnbGVIaWRkZW4odGhpcy5lbGVtZW50cy5zZXR0aW5ncy5tZW51LCAhdmlzaWJsZSk7XG4gIH0sXG4gIC8vIEZvY3VzIHRoZSBmaXJzdCBtZW51IGl0ZW0gaW4gYSBnaXZlbiAob3IgdmlzaWJsZSkgbWVudVxuICBmb2N1c0ZpcnN0TWVudUl0ZW0ocGFuZSwgZm9jdXNWaXNpYmxlID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50cy5zZXR0aW5ncy5wb3B1cC5oaWRkZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHRhcmdldCA9IHBhbmU7XG4gICAgaWYgKCFpcy5lbGVtZW50KHRhcmdldCkpIHtcbiAgICAgIHRhcmdldCA9IE9iamVjdC52YWx1ZXModGhpcy5lbGVtZW50cy5zZXR0aW5ncy5wYW5lbHMpLmZpbmQocCA9PiAhcC5oaWRkZW4pO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdEl0ZW0gPSB0YXJnZXQucXVlcnlTZWxlY3RvcignW3JvbGVePVwibWVudWl0ZW1cIl0nKTtcbiAgICBzZXRGb2N1cy5jYWxsKHRoaXMsIGZpcnN0SXRlbSwgZm9jdXNWaXNpYmxlKTtcbiAgfSxcbiAgLy8gU2hvdy9oaWRlIG1lbnVcbiAgdG9nZ2xlTWVudShpbnB1dCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBvcHVwXG4gICAgfSA9IHRoaXMuZWxlbWVudHMuc2V0dGluZ3M7XG4gICAgY29uc3QgYnV0dG9uID0gdGhpcy5lbGVtZW50cy5idXR0b25zLnNldHRpbmdzO1xuXG4gICAgLy8gTWVudSBhbmQgYnV0dG9uIGFyZSByZXF1aXJlZFxuICAgIGlmICghaXMuZWxlbWVudChwb3B1cCkgfHwgIWlzLmVsZW1lbnQoYnV0dG9uKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRydWUgdG9nZ2xlIGJ5IGRlZmF1bHRcbiAgICBjb25zdCB7XG4gICAgICBoaWRkZW5cbiAgICB9ID0gcG9wdXA7XG4gICAgbGV0IHNob3cgPSBoaWRkZW47XG4gICAgaWYgKGlzLmJvb2xlYW4oaW5wdXQpKSB7XG4gICAgICBzaG93ID0gaW5wdXQ7XG4gICAgfSBlbHNlIGlmIChpcy5rZXlib2FyZEV2ZW50KGlucHV0KSAmJiBpbnB1dC5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICBzaG93ID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpcy5ldmVudChpbnB1dCkpIHtcbiAgICAgIC8vIElmIFBseXIgaXMgaW4gYSBzaGFkb3dET00sIHRoZSBldmVudCB0YXJnZXQgaXMgc2V0IHRvIHRoZSBjb21wb25lbnQsIGluc3RlYWQgb2YgdGhlXG4gICAgICAvLyBFbGVtZW50IGluIHRoZSBzaGFkb3dET00uIFRoZSBwYXRoLCBpZiBhdmFpbGFibGUsIGlzIGNvbXBsZXRlLlxuICAgICAgY29uc3QgdGFyZ2V0ID0gaXMuZnVuY3Rpb24oaW5wdXQuY29tcG9zZWRQYXRoKSA/IGlucHV0LmNvbXBvc2VkUGF0aCgpWzBdIDogaW5wdXQudGFyZ2V0O1xuICAgICAgY29uc3QgaXNNZW51SXRlbSA9IHBvcHVwLmNvbnRhaW5zKHRhcmdldCk7XG5cbiAgICAgIC8vIElmIHRoZSBjbGljayB3YXMgaW5zaWRlIHRoZSBtZW51IG9yIGlmIHRoZSBjbGlja1xuICAgICAgLy8gd2Fzbid0IHRoZSBidXR0b24gb3IgbWVudSBpdGVtIGFuZCB3ZSdyZSB0cnlpbmcgdG9cbiAgICAgIC8vIHNob3cgdGhlIG1lbnUgKGEgZG9jIGNsaWNrIHNob3VsZG4ndCBzaG93IHRoZSBtZW51KVxuICAgICAgaWYgKGlzTWVudUl0ZW0gfHwgIWlzTWVudUl0ZW0gJiYgaW5wdXQudGFyZ2V0ICE9PSBidXR0b24gJiYgc2hvdykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IGJ1dHRvbiBhdHRyaWJ1dGVzXG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHNob3cpO1xuXG4gICAgLy8gU2hvdyB0aGUgYWN0dWFsIHBvcHVwXG4gICAgdG9nZ2xlSGlkZGVuKHBvcHVwLCAhc2hvdyk7XG5cbiAgICAvLyBBZGQgY2xhc3MgaG9va1xuICAgIHRvZ2dsZUNsYXNzKHRoaXMuZWxlbWVudHMuY29udGFpbmVyLCB0aGlzLmNvbmZpZy5jbGFzc05hbWVzLm1lbnUub3Blbiwgc2hvdyk7XG5cbiAgICAvLyBGb2N1cyB0aGUgZmlyc3QgaXRlbSBpZiBrZXkgaW50ZXJhY3Rpb25cbiAgICBpZiAoc2hvdyAmJiBpcy5rZXlib2FyZEV2ZW50KGlucHV0KSkge1xuICAgICAgY29udHJvbHMuZm9jdXNGaXJzdE1lbnVJdGVtLmNhbGwodGhpcywgbnVsbCwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICghc2hvdyAmJiAhaGlkZGVuKSB7XG4gICAgICAvLyBJZiBjbG9zaW5nLCByZS1mb2N1cyB0aGUgYnV0dG9uXG4gICAgICBzZXRGb2N1cy5jYWxsKHRoaXMsIGJ1dHRvbiwgaXMua2V5Ym9hcmRFdmVudChpbnB1dCkpO1xuICAgIH1cbiAgfSxcbiAgLy8gR2V0IHRoZSBuYXR1cmFsIHNpemUgb2YgYSBtZW51IHBhbmVsXG4gIGdldE1lbnVTaXplKHRhYikge1xuICAgIGNvbnN0IGNsb25lID0gdGFiLmNsb25lTm9kZSh0cnVlKTtcbiAgICBjbG9uZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgY2xvbmUuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgY2xvbmUucmVtb3ZlQXR0cmlidXRlKCdoaWRkZW4nKTtcblxuICAgIC8vIEFwcGVuZCB0byBwYXJlbnQgc28gd2UgZ2V0IHRoZSBcInJlYWxcIiBzaXplXG4gICAgdGFiLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuXG4gICAgLy8gR2V0IHRoZSBzaXplcyBiZWZvcmUgd2UgcmVtb3ZlXG4gICAgY29uc3Qgd2lkdGggPSBjbG9uZS5zY3JvbGxXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBjbG9uZS5zY3JvbGxIZWlnaHQ7XG5cbiAgICAvLyBSZW1vdmUgZnJvbSB0aGUgRE9NXG4gICAgcmVtb3ZlRWxlbWVudChjbG9uZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfTtcbiAgfSxcbiAgLy8gU2hvdyBhIHBhbmVsIGluIHRoZSBtZW51XG4gIHNob3dNZW51UGFuZWwodHlwZSA9ICcnLCBmb2N1c1Zpc2libGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZWxlbWVudHMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoYCNwbHlyLXNldHRpbmdzLSR7dGhpcy5pZH0tJHt0eXBlfWApO1xuXG4gICAgLy8gTm90aGluZyB0byBzaG93LCBiYWlsXG4gICAgaWYgKCFpcy5lbGVtZW50KHRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBIaWRlIGFsbCBvdGhlciBwYW5lbHNcbiAgICBjb25zdCBjb250YWluZXIgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICBjb25zdCBjdXJyZW50ID0gQXJyYXkuZnJvbShjb250YWluZXIuY2hpbGRyZW4pLmZpbmQobm9kZSA9PiAhbm9kZS5oaWRkZW4pO1xuXG4gICAgLy8gSWYgd2UgY2FuIGRvIGZhbmN5IGFuaW1hdGlvbnMsIHdlJ2xsIGFuaW1hdGUgdGhlIGhlaWdodC93aWR0aFxuICAgIGlmIChzdXBwb3J0LnRyYW5zaXRpb25zICYmICFzdXBwb3J0LnJlZHVjZWRNb3Rpb24pIHtcbiAgICAgIC8vIFNldCB0aGUgY3VycmVudCB3aWR0aCBhcyBhIGJhc2VcbiAgICAgIGNvbnRhaW5lci5zdHlsZS53aWR0aCA9IGAke2N1cnJlbnQuc2Nyb2xsV2lkdGh9cHhgO1xuICAgICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGAke2N1cnJlbnQuc2Nyb2xsSGVpZ2h0fXB4YDtcblxuICAgICAgLy8gR2V0IHBvdGVudGlhbCBzaXplc1xuICAgICAgY29uc3Qgc2l6ZSA9IGNvbnRyb2xzLmdldE1lbnVTaXplLmNhbGwodGhpcywgdGFyZ2V0KTtcblxuICAgICAgLy8gUmVzdG9yZSBhdXRvIGhlaWdodC93aWR0aFxuICAgICAgY29uc3QgcmVzdG9yZSA9IGV2ZW50ID0+IHtcbiAgICAgICAgLy8gV2UncmUgb25seSBib3RoZXJlZCBhYm91dCBoZWlnaHQgYW5kIHdpZHRoIG9uIHRoZSBjb250YWluZXJcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gY29udGFpbmVyIHx8ICFbJ3dpZHRoJywgJ2hlaWdodCddLmluY2x1ZGVzKGV2ZW50LnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXZlcnQgYmFjayB0byBhdXRvXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS53aWR0aCA9ICcnO1xuICAgICAgICBjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gJyc7XG5cbiAgICAgICAgLy8gT25seSBsaXN0ZW4gb25jZVxuICAgICAgICBvZmYuY2FsbCh0aGlzLCBjb250YWluZXIsIHRyYW5zaXRpb25FbmRFdmVudCwgcmVzdG9yZSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBMaXN0ZW4gZm9yIHRoZSB0cmFuc2l0aW9uIGZpbmlzaGluZyBhbmQgcmVzdG9yZSBhdXRvIGhlaWdodC93aWR0aFxuICAgICAgb24uY2FsbCh0aGlzLCBjb250YWluZXIsIHRyYW5zaXRpb25FbmRFdmVudCwgcmVzdG9yZSk7XG5cbiAgICAgIC8vIFNldCBkaW1lbnNpb25zIHRvIHRhcmdldFxuICAgICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gYCR7c2l6ZS53aWR0aH1weGA7XG4gICAgICBjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gYCR7c2l6ZS5oZWlnaHR9cHhgO1xuICAgIH1cblxuICAgIC8vIFNldCBhdHRyaWJ1dGVzIG9uIGN1cnJlbnQgdGFiXG4gICAgdG9nZ2xlSGlkZGVuKGN1cnJlbnQsIHRydWUpO1xuXG4gICAgLy8gU2V0IGF0dHJpYnV0ZXMgb24gdGFyZ2V0XG4gICAgdG9nZ2xlSGlkZGVuKHRhcmdldCwgZmFsc2UpO1xuXG4gICAgLy8gRm9jdXMgdGhlIGZpcnN0IGl0ZW1cbiAgICBjb250cm9scy5mb2N1c0ZpcnN0TWVudUl0ZW0uY2FsbCh0aGlzLCB0YXJnZXQsIGZvY3VzVmlzaWJsZSk7XG4gIH0sXG4gIC8vIFNldCB0aGUgZG93bmxvYWQgVVJMXG4gIHNldERvd25sb2FkVXJsKCkge1xuICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuZWxlbWVudHMuYnV0dG9ucy5kb3dubG9hZDtcblxuICAgIC8vIEJhaWwgaWYgbm8gYnV0dG9uXG4gICAgaWYgKCFpcy5lbGVtZW50KGJ1dHRvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTZXQgYXR0cmlidXRlXG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgnaHJlZicsIHRoaXMuZG93bmxvYWQpO1xuICB9LFxuICAvLyBCdWlsZCB0aGUgZGVmYXVsdCBIVE1MXG4gIGNyZWF0ZShkYXRhKSB7XG4gICAgY29uc3Qge1xuICAgICAgYmluZE1lbnVJdGVtU2hvcnRjdXRzLFxuICAgICAgY3JlYXRlQnV0dG9uLFxuICAgICAgY3JlYXRlUHJvZ3Jlc3MsXG4gICAgICBjcmVhdGVSYW5nZSxcbiAgICAgIGNyZWF0ZVRpbWUsXG4gICAgICBzZXRRdWFsaXR5TWVudSxcbiAgICAgIHNldFNwZWVkTWVudSxcbiAgICAgIHNob3dNZW51UGFuZWxcbiAgICB9ID0gY29udHJvbHM7XG4gICAgdGhpcy5lbGVtZW50cy5jb250cm9scyA9IG51bGw7XG5cbiAgICAvLyBMYXJnZXIgb3ZlcmxhaWQgcGxheSBidXR0b25cbiAgICBpZiAoaXMuYXJyYXkodGhpcy5jb25maWcuY29udHJvbHMpICYmIHRoaXMuY29uZmlnLmNvbnRyb2xzLmluY2x1ZGVzKCdwbGF5LWxhcmdlJykpIHtcbiAgICAgIHRoaXMuZWxlbWVudHMuY29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZUJ1dHRvbi5jYWxsKHRoaXMsICdwbGF5LWxhcmdlJykpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSB0aGUgY29udGFpbmVyXG4gICAgY29uc3QgY29udGFpbmVyID0gY3JlYXRlRWxlbWVudCgnZGl2JywgZ2V0QXR0cmlidXRlc0Zyb21TZWxlY3Rvcih0aGlzLmNvbmZpZy5zZWxlY3RvcnMuY29udHJvbHMud3JhcHBlcikpO1xuICAgIHRoaXMuZWxlbWVudHMuY29udHJvbHMgPSBjb250YWluZXI7XG5cbiAgICAvLyBEZWZhdWx0IGl0ZW0gYXR0cmlidXRlc1xuICAgIGNvbnN0IGRlZmF1bHRBdHRyaWJ1dGVzID0ge1xuICAgICAgY2xhc3M6ICdwbHlyX19jb250cm9sc19faXRlbSdcbiAgICB9O1xuXG4gICAgLy8gTG9vcCB0aHJvdWdoIGNvbnRyb2xzIGluIG9yZGVyXG4gICAgZGVkdXBlKGlzLmFycmF5KHRoaXMuY29uZmlnLmNvbnRyb2xzKSA/IHRoaXMuY29uZmlnLmNvbnRyb2xzIDogW10pLmZvckVhY2goY29udHJvbCA9PiB7XG4gICAgICAvLyBSZXN0YXJ0IGJ1dHRvblxuICAgICAgaWYgKGNvbnRyb2wgPT09ICdyZXN0YXJ0Jykge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY3JlYXRlQnV0dG9uLmNhbGwodGhpcywgJ3Jlc3RhcnQnLCBkZWZhdWx0QXR0cmlidXRlcykpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXdpbmQgYnV0dG9uXG4gICAgICBpZiAoY29udHJvbCA9PT0gJ3Jld2luZCcpIHtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZUJ1dHRvbi5jYWxsKHRoaXMsICdyZXdpbmQnLCBkZWZhdWx0QXR0cmlidXRlcykpO1xuICAgICAgfVxuXG4gICAgICAvLyBQbGF5L1BhdXNlIGJ1dHRvblxuICAgICAgaWYgKGNvbnRyb2wgPT09ICdwbGF5Jykge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY3JlYXRlQnV0dG9uLmNhbGwodGhpcywgJ3BsYXknLCBkZWZhdWx0QXR0cmlidXRlcykpO1xuICAgICAgfVxuXG4gICAgICAvLyBGYXN0IGZvcndhcmQgYnV0dG9uXG4gICAgICBpZiAoY29udHJvbCA9PT0gJ2Zhc3QtZm9yd2FyZCcpIHtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZUJ1dHRvbi5jYWxsKHRoaXMsICdmYXN0LWZvcndhcmQnLCBkZWZhdWx0QXR0cmlidXRlcykpO1xuICAgICAgfVxuXG4gICAgICAvLyBQcm9ncmVzc1xuICAgICAgaWYgKGNvbnRyb2wgPT09ICdwcm9ncmVzcycpIHtcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3NDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgY2xhc3M6IGAke2RlZmF1bHRBdHRyaWJ1dGVzLmNsYXNzfSBwbHlyX19wcm9ncmVzc19fY29udGFpbmVyYFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBjcmVhdGVFbGVtZW50KCdkaXYnLCBnZXRBdHRyaWJ1dGVzRnJvbVNlbGVjdG9yKHRoaXMuY29uZmlnLnNlbGVjdG9ycy5wcm9ncmVzcykpO1xuXG4gICAgICAgIC8vIFNlZWsgcmFuZ2Ugc2xpZGVyXG4gICAgICAgIHByb2dyZXNzLmFwcGVuZENoaWxkKGNyZWF0ZVJhbmdlLmNhbGwodGhpcywgJ3NlZWsnLCB7XG4gICAgICAgICAgaWQ6IGBwbHlyLXNlZWstJHtkYXRhLmlkfWBcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIC8vIEJ1ZmZlciBwcm9ncmVzc1xuICAgICAgICBwcm9ncmVzcy5hcHBlbmRDaGlsZChjcmVhdGVQcm9ncmVzcy5jYWxsKHRoaXMsICdidWZmZXInKSk7XG5cbiAgICAgICAgLy8gVE9ETzogQWRkIGxvb3AgZGlzcGxheSBpbmRpY2F0b3JcblxuICAgICAgICAvLyBTZWVrIHRvb2x0aXBcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRvb2x0aXBzLnNlZWspIHtcbiAgICAgICAgICBjb25zdCB0b29sdGlwID0gY3JlYXRlRWxlbWVudCgnc3BhbicsIHtcbiAgICAgICAgICAgIGNsYXNzOiB0aGlzLmNvbmZpZy5jbGFzc05hbWVzLnRvb2x0aXBcbiAgICAgICAgICB9LCAnMDA6MDAnKTtcbiAgICAgICAgICBwcm9ncmVzcy5hcHBlbmRDaGlsZCh0b29sdGlwKTtcbiAgICAgICAgICB0aGlzLmVsZW1lbnRzLmRpc3BsYXkuc2Vla1Rvb2x0aXAgPSB0b29sdGlwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudHMucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgICAgcHJvZ3Jlc3NDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50cy5wcm9ncmVzcyk7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChwcm9ncmVzc0NvbnRhaW5lcik7XG4gICAgICB9XG5cbiAgICAgIC8vIE1lZGlhIGN1cnJlbnQgdGltZSBkaXNwbGF5XG4gICAgICBpZiAoY29udHJvbCA9PT0gJ2N1cnJlbnQtdGltZScpIHtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZVRpbWUuY2FsbCh0aGlzLCAnY3VycmVudFRpbWUnLCBkZWZhdWx0QXR0cmlidXRlcykpO1xuICAgICAgfVxuXG4gICAgICAvLyBNZWRpYSBkdXJhdGlvbiBkaXNwbGF5XG4gICAgICBpZiAoY29udHJvbCA9PT0gJ2R1cmF0aW9uJykge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY3JlYXRlVGltZS5jYWxsKHRoaXMsICdkdXJhdGlvbicsIGRlZmF1bHRBdHRyaWJ1dGVzKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFZvbHVtZSBjb250cm9sc1xuICAgICAgaWYgKGNvbnRyb2wgPT09ICdtdXRlJyB8fCBjb250cm9sID09PSAndm9sdW1lJykge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIHZvbHVtZVxuICAgICAgICB9ID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICAvLyBDcmVhdGUgdGhlIHZvbHVtZSBjb250YWluZXIgaWYgbmVlZGVkXG4gICAgICAgIGlmICghaXMuZWxlbWVudCh2b2x1bWUpIHx8ICFjb250YWluZXIuY29udGFpbnModm9sdW1lKSkge1xuICAgICAgICAgIHZvbHVtZSA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicsIGV4dGVuZCh7fSwgZGVmYXVsdEF0dHJpYnV0ZXMsIHtcbiAgICAgICAgICAgIGNsYXNzOiBgJHtkZWZhdWx0QXR0cmlidXRlcy5jbGFzc30gcGx5cl9fdm9sdW1lYC50cmltKClcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgdGhpcy5lbGVtZW50cy52b2x1bWUgPSB2b2x1bWU7XG4gICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHZvbHVtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUb2dnbGUgbXV0ZSBidXR0b25cbiAgICAgICAgaWYgKGNvbnRyb2wgPT09ICdtdXRlJykge1xuICAgICAgICAgIHZvbHVtZS5hcHBlbmRDaGlsZChjcmVhdGVCdXR0b24uY2FsbCh0aGlzLCAnbXV0ZScpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZvbHVtZSByYW5nZSBjb250cm9sXG4gICAgICAgIC8vIElnbm9yZWQgb24gaU9TIGFzIGl0J3MgaGFuZGxlZCBnbG9iYWxseVxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vbGlicmFyeS9zYWZhcmkvZG9jdW1lbnRhdGlvbi9BdWRpb1ZpZGVvL0NvbmNlcHR1YWwvVXNpbmdfSFRNTDVfQXVkaW9fVmlkZW8vRGV2aWNlLVNwZWNpZmljQ29uc2lkZXJhdGlvbnMvRGV2aWNlLVNwZWNpZmljQ29uc2lkZXJhdGlvbnMuaHRtbFxuICAgICAgICBpZiAoY29udHJvbCA9PT0gJ3ZvbHVtZScgJiYgIWJyb3dzZXIuaXNJb3MgJiYgIWJyb3dzZXIuaXNJUGFkT1MpIHtcbiAgICAgICAgICAvLyBTZXQgdGhlIGF0dHJpYnV0ZXNcbiAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgICAgICAgICAgbWF4OiAxLFxuICAgICAgICAgICAgc3RlcDogMC4wNSxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmNvbmZpZy52b2x1bWVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gQ3JlYXRlIHRoZSB2b2x1bWUgcmFuZ2Ugc2xpZGVyXG4gICAgICAgICAgdm9sdW1lLmFwcGVuZENoaWxkKGNyZWF0ZVJhbmdlLmNhbGwodGhpcywgJ3ZvbHVtZScsIGV4dGVuZChhdHRyaWJ1dGVzLCB7XG4gICAgICAgICAgICBpZDogYHBseXItdm9sdW1lLSR7ZGF0YS5pZH1gXG4gICAgICAgICAgfSkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUb2dnbGUgY2FwdGlvbnMgYnV0dG9uXG4gICAgICBpZiAoY29udHJvbCA9PT0gJ2NhcHRpb25zJykge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY3JlYXRlQnV0dG9uLmNhbGwodGhpcywgJ2NhcHRpb25zJywgZGVmYXVsdEF0dHJpYnV0ZXMpKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0dGluZ3MgYnV0dG9uIC8gbWVudVxuICAgICAgaWYgKGNvbnRyb2wgPT09ICdzZXR0aW5ncycgJiYgIWlzLmVtcHR5KHRoaXMuY29uZmlnLnNldHRpbmdzKSkge1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gY3JlYXRlRWxlbWVudCgnZGl2JywgZXh0ZW5kKHt9LCBkZWZhdWx0QXR0cmlidXRlcywge1xuICAgICAgICAgIGNsYXNzOiBgJHtkZWZhdWx0QXR0cmlidXRlcy5jbGFzc30gcGx5cl9fbWVudWAudHJpbSgpLFxuICAgICAgICAgIGhpZGRlbjogJydcbiAgICAgICAgfSkpO1xuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGNyZWF0ZUJ1dHRvbi5jYWxsKHRoaXMsICdzZXR0aW5ncycsIHtcbiAgICAgICAgICAnYXJpYS1oYXNwb3B1cCc6IHRydWUsXG4gICAgICAgICAgJ2FyaWEtY29udHJvbHMnOiBgcGx5ci1zZXR0aW5ncy0ke2RhdGEuaWR9YCxcbiAgICAgICAgICAnYXJpYS1leHBhbmRlZCc6IGZhbHNlXG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3QgcG9wdXAgPSBjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgY2xhc3M6ICdwbHlyX19tZW51X19jb250YWluZXInLFxuICAgICAgICAgIGlkOiBgcGx5ci1zZXR0aW5ncy0ke2RhdGEuaWR9YCxcbiAgICAgICAgICBoaWRkZW46ICcnXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBpbm5lciA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb25zdCBob21lID0gY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICAgIGlkOiBgcGx5ci1zZXR0aW5ncy0ke2RhdGEuaWR9LWhvbWVgXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgbWVudVxuICAgICAgICBjb25zdCBtZW51ID0gY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICAgIHJvbGU6ICdtZW51J1xuICAgICAgICB9KTtcbiAgICAgICAgaG9tZS5hcHBlbmRDaGlsZChtZW51KTtcbiAgICAgICAgaW5uZXIuYXBwZW5kQ2hpbGQoaG9tZSk7XG4gICAgICAgIHRoaXMuZWxlbWVudHMuc2V0dGluZ3MucGFuZWxzLmhvbWUgPSBob21lO1xuXG4gICAgICAgIC8vIEJ1aWxkIHRoZSBtZW51IGl0ZW1zXG4gICAgICAgIHRoaXMuY29uZmlnLnNldHRpbmdzLmZvckVhY2godHlwZSA9PiB7XG4gICAgICAgICAgLy8gVE9ETzogYnVuZGxlIHRoaXMgd2l0aCB0aGUgY3JlYXRlTWVudUl0ZW0gaGVscGVyIGFuZCBiaW5kaW5nc1xuICAgICAgICAgIGNvbnN0IG1lbnVJdGVtID0gY3JlYXRlRWxlbWVudCgnYnV0dG9uJywgZXh0ZW5kKGdldEF0dHJpYnV0ZXNGcm9tU2VsZWN0b3IodGhpcy5jb25maWcuc2VsZWN0b3JzLmJ1dHRvbnMuc2V0dGluZ3MpLCB7XG4gICAgICAgICAgICAndHlwZSc6ICdidXR0b24nLFxuICAgICAgICAgICAgJ2NsYXNzJzogYCR7dGhpcy5jb25maWcuY2xhc3NOYW1lcy5jb250cm9sfSAke3RoaXMuY29uZmlnLmNsYXNzTmFtZXMuY29udHJvbH0tLWZvcndhcmRgLFxuICAgICAgICAgICAgJ3JvbGUnOiAnbWVudWl0ZW0nLFxuICAgICAgICAgICAgJ2FyaWEtaGFzcG9wdXAnOiB0cnVlLFxuICAgICAgICAgICAgJ2hpZGRlbic6ICcnXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgLy8gQmluZCBtZW51IHNob3J0Y3V0cyBmb3Iga2V5Ym9hcmQgdXNlcnNcbiAgICAgICAgICBiaW5kTWVudUl0ZW1TaG9ydGN1dHMuY2FsbCh0aGlzLCBtZW51SXRlbSwgdHlwZSk7XG5cbiAgICAgICAgICAvLyBTaG93IG1lbnUgb24gY2xpY2tcbiAgICAgICAgICBvbi5jYWxsKHRoaXMsIG1lbnVJdGVtLCAnY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICBzaG93TWVudVBhbmVsLmNhbGwodGhpcywgdHlwZSwgZmFsc2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IGZsZXggPSBjcmVhdGVFbGVtZW50KCdzcGFuJywgbnVsbCwgaTE4bi5nZXQodHlwZSwgdGhpcy5jb25maWcpKTtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCB7XG4gICAgICAgICAgICBjbGFzczogdGhpcy5jb25maWcuY2xhc3NOYW1lcy5tZW51LnZhbHVlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBTcGVlZCBjb250YWlucyBIVE1MIGVudGl0aWVzXG4gICAgICAgICAgdmFsdWUuaW5uZXJIVE1MID0gZGF0YVt0eXBlXTtcbiAgICAgICAgICBmbGV4LmFwcGVuZENoaWxkKHZhbHVlKTtcbiAgICAgICAgICBtZW51SXRlbS5hcHBlbmRDaGlsZChmbGV4KTtcbiAgICAgICAgICBtZW51LmFwcGVuZENoaWxkKG1lbnVJdGVtKTtcblxuICAgICAgICAgIC8vIEJ1aWxkIHRoZSBwYW5lc1xuICAgICAgICAgIGNvbnN0IHBhbmUgPSBjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgICAgICBpZDogYHBseXItc2V0dGluZ3MtJHtkYXRhLmlkfS0ke3R5cGV9YCxcbiAgICAgICAgICAgIGhpZGRlbjogJydcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIEJhY2sgYnV0dG9uXG4gICAgICAgICAgY29uc3QgYmFja0J1dHRvbiA9IGNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicsIHtcbiAgICAgICAgICAgIHR5cGU6ICdidXR0b24nLFxuICAgICAgICAgICAgY2xhc3M6IGAke3RoaXMuY29uZmlnLmNsYXNzTmFtZXMuY29udHJvbH0gJHt0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmNvbnRyb2x9LS1iYWNrYFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gVmlzaWJsZSBsYWJlbFxuICAgICAgICAgIGJhY2tCdXR0b24uYXBwZW5kQ2hpbGQoY3JlYXRlRWxlbWVudCgnc3BhbicsIHtcbiAgICAgICAgICAgICdhcmlhLWhpZGRlbic6IHRydWVcbiAgICAgICAgICB9LCBpMThuLmdldCh0eXBlLCB0aGlzLmNvbmZpZykpKTtcblxuICAgICAgICAgIC8vIFNjcmVlbiByZWFkZXIgbGFiZWxcbiAgICAgICAgICBiYWNrQnV0dG9uLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCB7XG4gICAgICAgICAgICBjbGFzczogdGhpcy5jb25maWcuY2xhc3NOYW1lcy5oaWRkZW5cbiAgICAgICAgICB9LCBpMThuLmdldCgnbWVudUJhY2snLCB0aGlzLmNvbmZpZykpKTtcblxuICAgICAgICAgIC8vIEdvIGJhY2sgdmlhIGtleWJvYXJkXG4gICAgICAgICAgb24uY2FsbCh0aGlzLCBwYW5lLCAna2V5ZG93bicsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXkgIT09ICdBcnJvd0xlZnQnKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgc2Vla1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAvLyBTaG93IHRoZSByZXNwZWN0aXZlIG1lbnVcbiAgICAgICAgICAgIHNob3dNZW51UGFuZWwuY2FsbCh0aGlzLCAnaG9tZScsIHRydWUpO1xuICAgICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICAgIC8vIEdvIGJhY2sgdmlhIGJ1dHRvbiBjbGlja1xuICAgICAgICAgIG9uLmNhbGwodGhpcywgYmFja0J1dHRvbiwgJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgc2hvd01lbnVQYW5lbC5jYWxsKHRoaXMsICdob21lJywgZmFsc2UpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gQWRkIHRvIHBhbmVcbiAgICAgICAgICBwYW5lLmFwcGVuZENoaWxkKGJhY2tCdXR0b24pO1xuXG4gICAgICAgICAgLy8gTWVudVxuICAgICAgICAgIHBhbmUuYXBwZW5kQ2hpbGQoY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICAgICAgcm9sZTogJ21lbnUnXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIGlubmVyLmFwcGVuZENoaWxkKHBhbmUpO1xuICAgICAgICAgIHRoaXMuZWxlbWVudHMuc2V0dGluZ3MuYnV0dG9uc1t0eXBlXSA9IG1lbnVJdGVtO1xuICAgICAgICAgIHRoaXMuZWxlbWVudHMuc2V0dGluZ3MucGFuZWxzW3R5cGVdID0gcGFuZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBvcHVwLmFwcGVuZENoaWxkKGlubmVyKTtcbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChwb3B1cCk7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh3cmFwcGVyKTtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5zZXR0aW5ncy5wb3B1cCA9IHBvcHVwO1xuICAgICAgICB0aGlzLmVsZW1lbnRzLnNldHRpbmdzLm1lbnUgPSB3cmFwcGVyO1xuICAgICAgfVxuXG4gICAgICAvLyBQaWN0dXJlIGluIHBpY3R1cmUgYnV0dG9uXG4gICAgICBpZiAoY29udHJvbCA9PT0gJ3BpcCcgJiYgc3VwcG9ydC5waXApIHtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZUJ1dHRvbi5jYWxsKHRoaXMsICdwaXAnLCBkZWZhdWx0QXR0cmlidXRlcykpO1xuICAgICAgfVxuXG4gICAgICAvLyBBaXJwbGF5IGJ1dHRvblxuICAgICAgaWYgKGNvbnRyb2wgPT09ICdhaXJwbGF5JyAmJiBzdXBwb3J0LmFpcnBsYXkpIHtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZUJ1dHRvbi5jYWxsKHRoaXMsICdhaXJwbGF5JywgZGVmYXVsdEF0dHJpYnV0ZXMpKTtcbiAgICAgIH1cblxuICAgICAgLy8gRG93bmxvYWQgYnV0dG9uXG4gICAgICBpZiAoY29udHJvbCA9PT0gJ2Rvd25sb2FkJykge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gZXh0ZW5kKHt9LCBkZWZhdWx0QXR0cmlidXRlcywge1xuICAgICAgICAgIGVsZW1lbnQ6ICdhJyxcbiAgICAgICAgICBocmVmOiB0aGlzLmRvd25sb2FkLFxuICAgICAgICAgIHRhcmdldDogJ19ibGFuaydcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU2V0IGRvd25sb2FkIGF0dHJpYnV0ZSBmb3IgSFRNTDUgb25seVxuICAgICAgICBpZiAodGhpcy5pc0hUTUw1KSB7XG4gICAgICAgICAgYXR0cmlidXRlcy5kb3dubG9hZCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkb3dubG9hZFxuICAgICAgICB9ID0gdGhpcy5jb25maWcudXJscztcbiAgICAgICAgaWYgKCFpcy51cmwoZG93bmxvYWQpICYmIHRoaXMuaXNFbWJlZCkge1xuICAgICAgICAgIGV4dGVuZChhdHRyaWJ1dGVzLCB7XG4gICAgICAgICAgICBpY29uOiBgbG9nby0ke3RoaXMucHJvdmlkZXJ9YCxcbiAgICAgICAgICAgIGxhYmVsOiB0aGlzLnByb3ZpZGVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZUJ1dHRvbi5jYWxsKHRoaXMsICdkb3dubG9hZCcsIGF0dHJpYnV0ZXMpKTtcbiAgICAgIH1cblxuICAgICAgLy8gVG9nZ2xlIGZ1bGxzY3JlZW4gYnV0dG9uXG4gICAgICBpZiAoY29udHJvbCA9PT0gJ2Z1bGxzY3JlZW4nKSB7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjcmVhdGVCdXR0b24uY2FsbCh0aGlzLCAnZnVsbHNjcmVlbicsIGRlZmF1bHRBdHRyaWJ1dGVzKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTZXQgYXZhaWxhYmxlIHF1YWxpdHkgbGV2ZWxzXG4gICAgaWYgKHRoaXMuaXNIVE1MNSkge1xuICAgICAgc2V0UXVhbGl0eU1lbnUuY2FsbCh0aGlzLCBodG1sNS5nZXRRdWFsaXR5T3B0aW9ucy5jYWxsKHRoaXMpKTtcbiAgICB9XG4gICAgc2V0U3BlZWRNZW51LmNhbGwodGhpcyk7XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfSxcbiAgLy8gSW5zZXJ0IGNvbnRyb2xzXG4gIGluamVjdCgpIHtcbiAgICAvLyBTcHJpdGVcbiAgICBpZiAodGhpcy5jb25maWcubG9hZFNwcml0ZSkge1xuICAgICAgY29uc3QgaWNvbiA9IGNvbnRyb2xzLmdldEljb25VcmwuY2FsbCh0aGlzKTtcblxuICAgICAgLy8gT25seSBsb2FkIGV4dGVybmFsIHNwcml0ZSB1c2luZyBBSkFYXG4gICAgICBpZiAoaWNvbi5jb3JzKSB7XG4gICAgICAgIGxvYWRTcHJpdGUoaWNvbi51cmwsICdzcHJpdGUtcGx5cicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIHVuaXF1ZSBJRFxuICAgIHRoaXMuaWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCk7XG5cbiAgICAvLyBOdWxsIGJ5IGRlZmF1bHRcbiAgICBsZXQgY29udGFpbmVyID0gbnVsbDtcbiAgICB0aGlzLmVsZW1lbnRzLmNvbnRyb2xzID0gbnVsbDtcblxuICAgIC8vIFNldCB0ZW1wbGF0ZSBwcm9wZXJ0aWVzXG4gICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIHNlZWt0aW1lOiB0aGlzLmNvbmZpZy5zZWVrVGltZSxcbiAgICAgIHRpdGxlOiB0aGlzLmNvbmZpZy50aXRsZVxuICAgIH07XG4gICAgbGV0IHVwZGF0ZSA9IHRydWU7XG5cbiAgICAvLyBJZiBmdW5jdGlvbiwgcnVuIGl0IGFuZCB1c2Ugb3V0cHV0XG4gICAgaWYgKGlzLmZ1bmN0aW9uKHRoaXMuY29uZmlnLmNvbnRyb2xzKSkge1xuICAgICAgdGhpcy5jb25maWcuY29udHJvbHMgPSB0aGlzLmNvbmZpZy5jb250cm9scy5jYWxsKHRoaXMsIHByb3BzKTtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IGZhbHN5IGNvbnRyb2xzIHRvIGVtcHR5IGFycmF5IChwcmltYXJpbHkgZm9yIGVtcHR5IHN0cmluZ3MpXG4gICAgaWYgKCF0aGlzLmNvbmZpZy5jb250cm9scykge1xuICAgICAgdGhpcy5jb25maWcuY29udHJvbHMgPSBbXTtcbiAgICB9XG4gICAgaWYgKGlzLmVsZW1lbnQodGhpcy5jb25maWcuY29udHJvbHMpIHx8IGlzLnN0cmluZyh0aGlzLmNvbmZpZy5jb250cm9scykpIHtcbiAgICAgIC8vIEhUTUxFbGVtZW50IG9yIE5vbi1lbXB0eSBzdHJpbmcgcGFzc2VkIGFzIHRoZSBvcHRpb25cbiAgICAgIGNvbnRhaW5lciA9IHRoaXMuY29uZmlnLmNvbnRyb2xzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgY29udHJvbHNcbiAgICAgIGNvbnRhaW5lciA9IGNvbnRyb2xzLmNyZWF0ZS5jYWxsKHRoaXMsIHtcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIHNlZWt0aW1lOiB0aGlzLmNvbmZpZy5zZWVrVGltZSxcbiAgICAgICAgc3BlZWQ6IHRoaXMuc3BlZWQsXG4gICAgICAgIHF1YWxpdHk6IHRoaXMucXVhbGl0eSxcbiAgICAgICAgY2FwdGlvbnM6IGNhcHRpb25zLmdldExhYmVsLmNhbGwodGhpcylcbiAgICAgICAgLy8gVE9ETzogTG9vcGluZ1xuICAgICAgICAvLyBsb29wOiAnTm9uZScsXG4gICAgICB9KTtcbiAgICAgIHVwZGF0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFJlcGxhY2UgcHJvcHMgd2l0aCB0aGVpciB2YWx1ZVxuICAgIGNvbnN0IHJlcGxhY2UgPSBpbnB1dCA9PiB7XG4gICAgICBsZXQgcmVzdWx0ID0gaW5wdXQ7XG4gICAgICBPYmplY3QuZW50cmllcyhwcm9wcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIHJlc3VsdCA9IHJlcGxhY2VBbGwocmVzdWx0LCBgeyR7a2V5fX1gLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8vIFVwZGF0ZSBtYXJrdXBcbiAgICBpZiAodXBkYXRlKSB7XG4gICAgICBpZiAoaXMuc3RyaW5nKHRoaXMuY29uZmlnLmNvbnRyb2xzKSkge1xuICAgICAgICBjb250YWluZXIgPSByZXBsYWNlKGNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29udHJvbHMgY29udGFpbmVyXG4gICAgbGV0IHRhcmdldDtcblxuICAgIC8vIEluamVjdCB0byBjdXN0b20gbG9jYXRpb25cbiAgICBpZiAoaXMuc3RyaW5nKHRoaXMuY29uZmlnLnNlbGVjdG9ycy5jb250cm9scy5jb250YWluZXIpKSB7XG4gICAgICB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuY29uZmlnLnNlbGVjdG9ycy5jb250cm9scy5jb250YWluZXIpO1xuICAgIH1cblxuICAgIC8vIEluamVjdCBpbnRvIHRoZSBjb250YWluZXIgYnkgZGVmYXVsdFxuICAgIGlmICghaXMuZWxlbWVudCh0YXJnZXQpKSB7XG4gICAgICB0YXJnZXQgPSB0aGlzLmVsZW1lbnRzLmNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICAvLyBJbmplY3QgY29udHJvbHMgSFRNTCAobmVlZHMgdG8gYmUgYmVmb3JlIGNhcHRpb25zLCBoZW5jZSBcImFmdGVyYmVnaW5cIilcbiAgICBjb25zdCBpbnNlcnRNZXRob2QgPSBpcy5lbGVtZW50KGNvbnRhaW5lcikgPyAnaW5zZXJ0QWRqYWNlbnRFbGVtZW50JyA6ICdpbnNlcnRBZGphY2VudEhUTUwnO1xuICAgIHRhcmdldFtpbnNlcnRNZXRob2RdKCdhZnRlcmJlZ2luJywgY29udGFpbmVyKTtcblxuICAgIC8vIEZpbmQgdGhlIGVsZW1lbnRzIGlmIG5lZWQgYmVcbiAgICBpZiAoIWlzLmVsZW1lbnQodGhpcy5lbGVtZW50cy5jb250cm9scykpIHtcbiAgICAgIGNvbnRyb2xzLmZpbmRFbGVtZW50cy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIEFkZCBwcmVzc2VkIHByb3BlcnR5IHRvIGJ1dHRvbnNcbiAgICBpZiAoIWlzLmVtcHR5KHRoaXMuZWxlbWVudHMuYnV0dG9ucykpIHtcbiAgICAgIGNvbnN0IGFkZFByb3BlcnR5ID0gYnV0dG9uID0+IHtcbiAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gdGhpcy5jb25maWcuY2xhc3NOYW1lcy5jb250cm9sUHJlc3NlZDtcbiAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1wcmVzc2VkJywgJ2ZhbHNlJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShidXR0b24sICdwcmVzc2VkJywge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNDbGFzcyhidXR0b24sIGNsYXNzTmFtZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQocHJlc3NlZCA9IGZhbHNlKSB7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhidXR0b24sIGNsYXNzTmFtZSwgcHJlc3NlZCk7XG4gICAgICAgICAgICBidXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLXByZXNzZWQnLCBwcmVzc2VkID8gJ3RydWUnIDogJ2ZhbHNlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFRvZ2dsZSBjbGFzc25hbWUgd2hlbiBwcmVzc2VkIHByb3BlcnR5IGlzIHNldFxuICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLmVsZW1lbnRzLmJ1dHRvbnMpLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKGJ1dHRvbiA9PiB7XG4gICAgICAgIGlmIChpcy5hcnJheShidXR0b24pIHx8IGlzLm5vZGVMaXN0KGJ1dHRvbikpIHtcbiAgICAgICAgICBBcnJheS5mcm9tKGJ1dHRvbikuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goYWRkUHJvcGVydHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZFByb3BlcnR5KGJ1dHRvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEVkZ2Ugc29tZXRpbWVzIGRvZXNuJ3QgZmluaXNoIHRoZSBwYWludCBzbyBmb3JjZSBhIHJlcGFpbnRcbiAgICBpZiAoYnJvd3Nlci5pc0VkZ2UpIHtcbiAgICAgIHJlcGFpbnQodGFyZ2V0KTtcbiAgICB9XG5cbiAgICAvLyBTZXR1cCB0b29sdGlwc1xuICAgIGlmICh0aGlzLmNvbmZpZy50b29sdGlwcy5jb250cm9scykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbGFzc05hbWVzLFxuICAgICAgICBzZWxlY3RvcnNcbiAgICAgIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgIGNvbnN0IHNlbGVjdG9yID0gYCR7c2VsZWN0b3JzLmNvbnRyb2xzLndyYXBwZXJ9ICR7c2VsZWN0b3JzLmxhYmVsc30gLiR7Y2xhc3NOYW1lcy5oaWRkZW59YDtcbiAgICAgIGNvbnN0IGxhYmVscyA9IGdldEVsZW1lbnRzLmNhbGwodGhpcywgc2VsZWN0b3IpO1xuICAgICAgQXJyYXkuZnJvbShsYWJlbHMpLmZvckVhY2gobGFiZWwgPT4ge1xuICAgICAgICB0b2dnbGVDbGFzcyhsYWJlbCwgdGhpcy5jb25maWcuY2xhc3NOYW1lcy5oaWRkZW4sIGZhbHNlKTtcbiAgICAgICAgdG9nZ2xlQ2xhc3MobGFiZWwsIHRoaXMuY29uZmlnLmNsYXNzTmFtZXMudG9vbHRpcCwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8vIFNldCBtZWRpYSBtZXRhZGF0YVxuICBzZXRNZWRpYU1ldGFkYXRhKCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoJ21lZGlhU2Vzc2lvbicgaW4gbmF2aWdhdG9yKSB7XG4gICAgICAgIG5hdmlnYXRvci5tZWRpYVNlc3Npb24ubWV0YWRhdGEgPSBuZXcgd2luZG93Lk1lZGlhTWV0YWRhdGEoe1xuICAgICAgICAgIHRpdGxlOiB0aGlzLmNvbmZpZy5tZWRpYU1ldGFkYXRhLnRpdGxlLFxuICAgICAgICAgIGFydGlzdDogdGhpcy5jb25maWcubWVkaWFNZXRhZGF0YS5hcnRpc3QsXG4gICAgICAgICAgYWxidW06IHRoaXMuY29uZmlnLm1lZGlhTWV0YWRhdGEuYWxidW0sXG4gICAgICAgICAgYXJ0d29yazogdGhpcy5jb25maWcubWVkaWFNZXRhZGF0YS5hcnR3b3JrXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gRG8gbm90aGluZ1xuICAgIH1cbiAgfSxcbiAgLy8gQWRkIG1hcmtlcnNcbiAgc2V0TWFya2VycygpIHtcbiAgICB2YXIgX3RoaXMkY29uZmlnJG1hcmtlcnMyLCBfdGhpcyRjb25maWckbWFya2VyczM7XG4gICAgaWYgKCF0aGlzLmR1cmF0aW9uIHx8IHRoaXMuZWxlbWVudHMubWFya2VycykgcmV0dXJuO1xuXG4gICAgLy8gR2V0IHZhbGlkIHBvaW50c1xuICAgIGNvbnN0IHBvaW50cyA9IChfdGhpcyRjb25maWckbWFya2VyczIgPSB0aGlzLmNvbmZpZy5tYXJrZXJzKSA9PT0gbnVsbCB8fCBfdGhpcyRjb25maWckbWFya2VyczIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfdGhpcyRjb25maWckbWFya2VyczMgPSBfdGhpcyRjb25maWckbWFya2VyczIucG9pbnRzKSA9PT0gbnVsbCB8fCBfdGhpcyRjb25maWckbWFya2VyczMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGNvbmZpZyRtYXJrZXJzMy5maWx0ZXIoKHtcbiAgICAgIHRpbWVcbiAgICB9KSA9PiB0aW1lID4gMCAmJiB0aW1lIDwgdGhpcy5kdXJhdGlvbik7XG4gICAgaWYgKCEocG9pbnRzICE9PSBudWxsICYmIHBvaW50cyAhPT0gdm9pZCAwICYmIHBvaW50cy5sZW5ndGgpKSByZXR1cm47XG4gICAgY29uc3QgY29udGFpbmVyRnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgY29uc3QgcG9pbnRzRnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgbGV0IHRpcEVsZW1lbnQgPSBudWxsO1xuICAgIGNvbnN0IHRpcFZpc2libGUgPSBgJHt0aGlzLmNvbmZpZy5jbGFzc05hbWVzLnRvb2x0aXB9LS12aXNpYmxlYDtcbiAgICBjb25zdCB0b2dnbGVUaXAgPSBzaG93ID0+IHRvZ2dsZUNsYXNzKHRpcEVsZW1lbnQsIHRpcFZpc2libGUsIHNob3cpO1xuXG4gICAgLy8gSW5qZWN0IG1hcmtlcnMgdG8gcHJvZ3Jlc3MgY29udGFpbmVyXG4gICAgcG9pbnRzLmZvckVhY2gocG9pbnQgPT4ge1xuICAgICAgY29uc3QgbWFya2VyRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCB7XG4gICAgICAgIGNsYXNzOiB0aGlzLmNvbmZpZy5jbGFzc05hbWVzLm1hcmtlclxuICAgICAgfSwgJycpO1xuICAgICAgY29uc3QgbGVmdCA9IGAke3BvaW50LnRpbWUgLyB0aGlzLmR1cmF0aW9uICogMTAwfSVgO1xuICAgICAgaWYgKHRpcEVsZW1lbnQpIHtcbiAgICAgICAgLy8gU2hvdyBvbiBob3ZlclxuICAgICAgICBtYXJrZXJFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKHBvaW50LmxhYmVsKSByZXR1cm47XG4gICAgICAgICAgdGlwRWxlbWVudC5zdHlsZS5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICB0aXBFbGVtZW50LmlubmVySFRNTCA9IHBvaW50LmxhYmVsO1xuICAgICAgICAgIHRvZ2dsZVRpcCh0cnVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSGlkZSBvbiBsZWF2ZVxuICAgICAgICBtYXJrZXJFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCAoKSA9PiB7XG4gICAgICAgICAgdG9nZ2xlVGlwKGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBtYXJrZXJFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gcG9pbnQudGltZTtcbiAgICAgIH0pO1xuICAgICAgbWFya2VyRWxlbWVudC5zdHlsZS5sZWZ0ID0gbGVmdDtcbiAgICAgIHBvaW50c0ZyYWdtZW50LmFwcGVuZENoaWxkKG1hcmtlckVsZW1lbnQpO1xuICAgIH0pO1xuICAgIGNvbnRhaW5lckZyYWdtZW50LmFwcGVuZENoaWxkKHBvaW50c0ZyYWdtZW50KTtcblxuICAgIC8vIEluamVjdCBhIHRvb2x0aXAgaWYgbmVlZGVkXG4gICAgaWYgKCF0aGlzLmNvbmZpZy50b29sdGlwcy5zZWVrKSB7XG4gICAgICB0aXBFbGVtZW50ID0gY3JlYXRlRWxlbWVudCgnc3BhbicsIHtcbiAgICAgICAgY2xhc3M6IHRoaXMuY29uZmlnLmNsYXNzTmFtZXMudG9vbHRpcFxuICAgICAgfSwgJycpO1xuICAgICAgY29udGFpbmVyRnJhZ21lbnQuYXBwZW5kQ2hpbGQodGlwRWxlbWVudCk7XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudHMubWFya2VycyA9IHtcbiAgICAgIHBvaW50czogcG9pbnRzRnJhZ21lbnQsXG4gICAgICB0aXA6IHRpcEVsZW1lbnRcbiAgICB9O1xuICAgIHRoaXMuZWxlbWVudHMucHJvZ3Jlc3MuYXBwZW5kQ2hpbGQoY29udGFpbmVyRnJhZ21lbnQpO1xuICB9XG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gVVJMIHV0aWxzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgdG8gYSBVUkwgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgLSB0aGUgVVJMIHRvIGJlIHBhcnNlZFxuICogQHBhcmFtIHtib29sZWFufSBzYWZlIC0gZmFpbHNhZmUgcGFyc2luZ1xuICovXG5mdW5jdGlvbiBwYXJzZVVybChpbnB1dCwgc2FmZSA9IHRydWUpIHtcbiAgbGV0IHVybCA9IGlucHV0O1xuICBpZiAoc2FmZSkge1xuICAgIGNvbnN0IHBhcnNlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICBwYXJzZXIuaHJlZiA9IHVybDtcbiAgICB1cmwgPSBwYXJzZXIuaHJlZjtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBuZXcgVVJMKHVybCk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vIENvbnZlcnQgb2JqZWN0IHRvIFVSTFNlYXJjaFBhcmFtc1xuZnVuY3Rpb24gYnVpbGRVcmxQYXJhbXMoaW5wdXQpIHtcbiAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBpZiAoaXMub2JqZWN0KGlucHV0KSkge1xuICAgIE9iamVjdC5lbnRyaWVzKGlucHV0KS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIHBhcmFtcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFBseXIgQ2FwdGlvbnNcbi8vIFRPRE86IENyZWF0ZSBhcyBjbGFzc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgY2FwdGlvbnMgPSB7XG4gIC8vIFNldHVwIGNhcHRpb25zXG4gIHNldHVwKCkge1xuICAgIC8vIFJlcXVpcmVzIFVJIHN1cHBvcnRcbiAgICBpZiAoIXRoaXMuc3VwcG9ydGVkLnVpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gT25seSBWaW1lbyBhbmQgSFRNTDUgdmlkZW8gc3VwcG9ydGVkIGF0IHRoaXMgcG9pbnRcbiAgICBpZiAoIXRoaXMuaXNWaWRlbyB8fCB0aGlzLmlzWW91VHViZSB8fCB0aGlzLmlzSFRNTDUgJiYgIXN1cHBvcnQudGV4dFRyYWNrcykge1xuICAgICAgLy8gQ2xlYXIgbWVudSBhbmQgaGlkZVxuICAgICAgaWYgKGlzLmFycmF5KHRoaXMuY29uZmlnLmNvbnRyb2xzKSAmJiB0aGlzLmNvbmZpZy5jb250cm9scy5pbmNsdWRlcygnc2V0dGluZ3MnKSAmJiB0aGlzLmNvbmZpZy5zZXR0aW5ncy5pbmNsdWRlcygnY2FwdGlvbnMnKSkge1xuICAgICAgICBjb250cm9scy5zZXRDYXB0aW9uc01lbnUuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJbmplY3QgdGhlIGNvbnRhaW5lclxuICAgIGlmICghaXMuZWxlbWVudCh0aGlzLmVsZW1lbnRzLmNhcHRpb25zKSkge1xuICAgICAgdGhpcy5lbGVtZW50cy5jYXB0aW9ucyA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicsIGdldEF0dHJpYnV0ZXNGcm9tU2VsZWN0b3IodGhpcy5jb25maWcuc2VsZWN0b3JzLmNhcHRpb25zKSk7XG4gICAgICB0aGlzLmVsZW1lbnRzLmNhcHRpb25zLnNldEF0dHJpYnV0ZSgnZGlyJywgJ2F1dG8nKTtcbiAgICAgIGluc2VydEFmdGVyKHRoaXMuZWxlbWVudHMuY2FwdGlvbnMsIHRoaXMuZWxlbWVudHMud3JhcHBlcik7XG4gICAgfVxuXG4gICAgLy8gRml4IElFIGNhcHRpb25zIGlmIENPUlMgaXMgdXNlZFxuICAgIC8vIEZldGNoIGNhcHRpb25zIGFuZCBpbmplY3QgYXMgYmxvYnMgaW5zdGVhZCAoZGF0YSBVUklzIG5vdCBzdXBwb3J0ZWQhKVxuICAgIGlmIChicm93c2VyLmlzSUUgJiYgd2luZG93LlVSTCkge1xuICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLm1lZGlhLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RyYWNrJyk7XG4gICAgICBBcnJheS5mcm9tKGVsZW1lbnRzKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgICAgY29uc3Qgc3JjID0gdHJhY2suZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgICAgICAgY29uc3QgdXJsID0gcGFyc2VVcmwoc3JjKTtcbiAgICAgICAgaWYgKHVybCAhPT0gbnVsbCAmJiB1cmwuaG9zdG5hbWUgIT09IHdpbmRvdy5sb2NhdGlvbi5ocmVmLmhvc3RuYW1lICYmIFsnaHR0cDonLCAnaHR0cHM6J10uaW5jbHVkZXModXJsLnByb3RvY29sKSkge1xuICAgICAgICAgIGZldGNoKHNyYywgJ2Jsb2InKS50aGVuKGJsb2IgPT4ge1xuICAgICAgICAgICAgdHJhY2suc2V0QXR0cmlidXRlKCdzcmMnLCB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKSk7XG4gICAgICAgICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgcmVtb3ZlRWxlbWVudCh0cmFjayk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEdldCBhbmQgc2V0IGluaXRpYWwgZGF0YVxuICAgIC8vIFRoZSBcInByZWZlcnJlZFwiIG9wdGlvbnMgYXJlIG5vdCByZWFsaXplZCB1bmxlc3MgLyB1bnRpbCB0aGUgd2FudGVkIGxhbmd1YWdlIGhhcyBhIG1hdGNoXG4gICAgLy8gKiBsYW5ndWFnZXM6IEFycmF5IG9mIHVzZXIncyBicm93c2VyIGxhbmd1YWdlcy5cbiAgICAvLyAqIGxhbmd1YWdlOiAgVGhlIGxhbmd1YWdlIHByZWZlcnJlZCBieSB1c2VyIHNldHRpbmdzIG9yIGNvbmZpZ1xuICAgIC8vICogYWN0aXZlOiAgICBUaGUgc3RhdGUgcHJlZmVycmVkIGJ5IHVzZXIgc2V0dGluZ3Mgb3IgY29uZmlnXG4gICAgLy8gKiB0b2dnbGVkOiAgIFRoZSByZWFsIGNhcHRpb25zIHN0YXRlXG5cbiAgICBjb25zdCBicm93c2VyTGFuZ3VhZ2VzID0gbmF2aWdhdG9yLmxhbmd1YWdlcyB8fCBbbmF2aWdhdG9yLmxhbmd1YWdlIHx8IG5hdmlnYXRvci51c2VyTGFuZ3VhZ2UgfHwgJ2VuJ107XG4gICAgY29uc3QgbGFuZ3VhZ2VzID0gZGVkdXBlKGJyb3dzZXJMYW5ndWFnZXMubWFwKGxhbmd1YWdlID0+IGxhbmd1YWdlLnNwbGl0KCctJylbMF0pKTtcbiAgICBsZXQgbGFuZ3VhZ2UgPSAodGhpcy5zdG9yYWdlLmdldCgnbGFuZ3VhZ2UnKSB8fCB0aGlzLmNhcHRpb25zLmxhbmd1YWdlIHx8IHRoaXMuY29uZmlnLmNhcHRpb25zLmxhbmd1YWdlIHx8ICdhdXRvJykudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIFVzZSBmaXJzdCBicm93c2VyIGxhbmd1YWdlIHdoZW4gbGFuZ3VhZ2UgaXMgJ2F1dG8nXG4gICAgaWYgKGxhbmd1YWdlID09PSAnYXV0bycpIHtcbiAgICAgIFtsYW5ndWFnZV0gPSBsYW5ndWFnZXM7XG4gICAgfVxuICAgIGxldCBhY3RpdmUgPSB0aGlzLnN0b3JhZ2UuZ2V0KCdjYXB0aW9ucycpIHx8IHRoaXMuY2FwdGlvbnMuYWN0aXZlO1xuICAgIGlmICghaXMuYm9vbGVhbihhY3RpdmUpKSB7XG4gICAgICAoe1xuICAgICAgICBhY3RpdmVcbiAgICAgIH0gPSB0aGlzLmNvbmZpZy5jYXB0aW9ucyk7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odGhpcy5jYXB0aW9ucywge1xuICAgICAgdG9nZ2xlZDogZmFsc2UsXG4gICAgICBhY3RpdmUsXG4gICAgICBsYW5ndWFnZSxcbiAgICAgIGxhbmd1YWdlc1xuICAgIH0pO1xuXG4gICAgLy8gV2F0Y2ggY2hhbmdlcyB0byB0ZXh0VHJhY2tzIGFuZCB1cGRhdGUgY2FwdGlvbnMgbWVudVxuICAgIGlmICh0aGlzLmlzSFRNTDUpIHtcbiAgICAgIGNvbnN0IHRyYWNrRXZlbnRzID0gdGhpcy5jb25maWcuY2FwdGlvbnMudXBkYXRlID8gJ2FkZHRyYWNrIHJlbW92ZXRyYWNrJyA6ICdyZW1vdmV0cmFjayc7XG4gICAgICBvbi5jYWxsKHRoaXMsIHRoaXMubWVkaWEudGV4dFRyYWNrcywgdHJhY2tFdmVudHMsIGNhcHRpb25zLnVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgYXZhaWxhYmxlIGxhbmd1YWdlcyBpbiBsaXN0IG5leHQgdGljayAodGhlIGV2ZW50IG11c3Qgbm90IGJlIHRyaWdnZXJlZCBiZWZvcmUgdGhlIGxpc3RlbmVycylcbiAgICBzZXRUaW1lb3V0KGNhcHRpb25zLnVwZGF0ZS5iaW5kKHRoaXMpLCAwKTtcbiAgfSxcbiAgLy8gVXBkYXRlIGF2YWlsYWJsZSBsYW5ndWFnZSBvcHRpb25zIGluIHNldHRpbmdzIGJhc2VkIG9uIHRyYWNrc1xuICB1cGRhdGUoKSB7XG4gICAgY29uc3QgdHJhY2tzID0gY2FwdGlvbnMuZ2V0VHJhY2tzLmNhbGwodGhpcywgdHJ1ZSk7XG4gICAgLy8gR2V0IHRoZSB3YW50ZWQgbGFuZ3VhZ2VcbiAgICBjb25zdCB7XG4gICAgICBhY3RpdmUsXG4gICAgICBsYW5ndWFnZSxcbiAgICAgIG1ldGEsXG4gICAgICBjdXJyZW50VHJhY2tOb2RlXG4gICAgfSA9IHRoaXMuY2FwdGlvbnM7XG4gICAgY29uc3QgbGFuZ3VhZ2VFeGlzdHMgPSBCb29sZWFuKHRyYWNrcy5maW5kKHRyYWNrID0+IHRyYWNrLmxhbmd1YWdlID09PSBsYW5ndWFnZSkpO1xuXG4gICAgLy8gSGFuZGxlIHRyYWNrcyAoYWRkIGV2ZW50IGxpc3RlbmVyIGFuZCBcInBzZXVkb1wiLWRlZmF1bHQpXG4gICAgaWYgKHRoaXMuaXNIVE1MNSAmJiB0aGlzLmlzVmlkZW8pIHtcbiAgICAgIHRyYWNrcy5maWx0ZXIodHJhY2sgPT4gIW1ldGEuZ2V0KHRyYWNrKSkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgIHRoaXMuZGVidWcubG9nKCdUcmFjayBhZGRlZCcsIHRyYWNrKTtcblxuICAgICAgICAvLyBBdHRlbXB0IHRvIHN0b3JlIGlmIHRoZSBvcmlnaW5hbCBkb20gZWxlbWVudCB3YXMgXCJkZWZhdWx0XCJcbiAgICAgICAgbWV0YS5zZXQodHJhY2ssIHtcbiAgICAgICAgICBkZWZhdWx0OiB0cmFjay5tb2RlID09PSAnc2hvd2luZydcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVHVybiBvZmYgbmF0aXZlIGNhcHRpb24gcmVuZGVyaW5nIHRvIGF2b2lkIGRvdWJsZSBjYXB0aW9uc1xuICAgICAgICAvLyBOb3RlOiBtb2RlPSdoaWRkZW4nIGZvcmNlcyBhIHRyYWNrIHRvIGRvd25sb2FkLiBUbyBlbnN1cmUgZXZlcnkgdHJhY2tcbiAgICAgICAgLy8gaXNuJ3QgZG93bmxvYWRlZCBhdCBvbmNlLCBvbmx5ICdzaG93aW5nJyB0cmFja3Mgc2hvdWxkIGJlIHJlYXNzaWduZWRcblxuICAgICAgICBpZiAodHJhY2subW9kZSA9PT0gJ3Nob3dpbmcnKSB7XG4gICAgICAgICAgdHJhY2subW9kZSA9ICdoaWRkZW4nO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVyIGZvciBjdWUgY2hhbmdlc1xuICAgICAgICBvbi5jYWxsKHRoaXMsIHRyYWNrLCAnY3VlY2hhbmdlJywgKCkgPT4gY2FwdGlvbnMudXBkYXRlQ3Vlcy5jYWxsKHRoaXMpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBsYW5ndWFnZSBmaXJzdCB0aW1lIGl0IG1hdGNoZXMsIG9yIGlmIHRoZSBwcmV2aW91cyBtYXRjaGluZyB0cmFjayB3YXMgcmVtb3ZlZFxuICAgIGlmIChsYW5ndWFnZUV4aXN0cyAmJiB0aGlzLmxhbmd1YWdlICE9PSBsYW5ndWFnZSB8fCAhdHJhY2tzLmluY2x1ZGVzKGN1cnJlbnRUcmFja05vZGUpKSB7XG4gICAgICBjYXB0aW9ucy5zZXRMYW5ndWFnZS5jYWxsKHRoaXMsIGxhbmd1YWdlKTtcbiAgICAgIGNhcHRpb25zLnRvZ2dsZS5jYWxsKHRoaXMsIGFjdGl2ZSAmJiBsYW5ndWFnZUV4aXN0cyk7XG4gICAgfVxuXG4gICAgLy8gRW5hYmxlIG9yIGRpc2FibGUgY2FwdGlvbnMgYmFzZWQgb24gdHJhY2sgbGVuZ3RoXG4gICAgaWYgKHRoaXMuZWxlbWVudHMpIHtcbiAgICAgIHRvZ2dsZUNsYXNzKHRoaXMuZWxlbWVudHMuY29udGFpbmVyLCB0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmNhcHRpb25zLmVuYWJsZWQsICFpcy5lbXB0eSh0cmFja3MpKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgYXZhaWxhYmxlIGxhbmd1YWdlcyBpbiBsaXN0XG4gICAgaWYgKGlzLmFycmF5KHRoaXMuY29uZmlnLmNvbnRyb2xzKSAmJiB0aGlzLmNvbmZpZy5jb250cm9scy5pbmNsdWRlcygnc2V0dGluZ3MnKSAmJiB0aGlzLmNvbmZpZy5zZXR0aW5ncy5pbmNsdWRlcygnY2FwdGlvbnMnKSkge1xuICAgICAgY29udHJvbHMuc2V0Q2FwdGlvbnNNZW51LmNhbGwodGhpcyk7XG4gICAgfVxuICB9LFxuICAvLyBUb2dnbGUgY2FwdGlvbnMgZGlzcGxheVxuICAvLyBVc2VkIGludGVybmFsbHkgZm9yIHRoZSB0b2dnbGVDYXB0aW9ucyBtZXRob2QsIHdpdGggdGhlIHBhc3NpdmUgb3B0aW9uIGZvcmNlZCB0byBmYWxzZVxuICB0b2dnbGUoaW5wdXQsIHBhc3NpdmUgPSB0cnVlKSB7XG4gICAgLy8gSWYgdGhlcmUncyBubyBmdWxsIHN1cHBvcnRcbiAgICBpZiAoIXRoaXMuc3VwcG9ydGVkLnVpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHRvZ2dsZWRcbiAgICB9ID0gdGhpcy5jYXB0aW9uczsgLy8gQ3VycmVudCBzdGF0ZVxuICAgIGNvbnN0IGFjdGl2ZUNsYXNzID0gdGhpcy5jb25maWcuY2xhc3NOYW1lcy5jYXB0aW9ucy5hY3RpdmU7XG4gICAgLy8gR2V0IHRoZSBuZXh0IHN0YXRlXG4gICAgLy8gSWYgdGhlIG1ldGhvZCBpcyBjYWxsZWQgd2l0aG91dCBwYXJhbWV0ZXIsIHRvZ2dsZSBiYXNlZCBvbiBjdXJyZW50IHZhbHVlXG4gICAgY29uc3QgYWN0aXZlID0gaXMubnVsbE9yVW5kZWZpbmVkKGlucHV0KSA/ICF0b2dnbGVkIDogaW5wdXQ7XG5cbiAgICAvLyBVcGRhdGUgc3RhdGUgYW5kIHRyaWdnZXIgZXZlbnRcbiAgICBpZiAoYWN0aXZlICE9PSB0b2dnbGVkKSB7XG4gICAgICAvLyBXaGVuIHBhc3NpdmUsIGRvbid0IG92ZXJyaWRlIHVzZXIgcHJlZmVyZW5jZXNcbiAgICAgIGlmICghcGFzc2l2ZSkge1xuICAgICAgICB0aGlzLmNhcHRpb25zLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgdGhpcy5zdG9yYWdlLnNldCh7XG4gICAgICAgICAgY2FwdGlvbnM6IGFjdGl2ZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gRm9yY2UgbGFuZ3VhZ2UgaWYgdGhlIGNhbGwgaXNuJ3QgcGFzc2l2ZSBhbmQgdGhlcmUgaXMgbm8gbWF0Y2hpbmcgbGFuZ3VhZ2UgdG8gdG9nZ2xlIHRvXG4gICAgICBpZiAoIXRoaXMubGFuZ3VhZ2UgJiYgYWN0aXZlICYmICFwYXNzaXZlKSB7XG4gICAgICAgIGNvbnN0IHRyYWNrcyA9IGNhcHRpb25zLmdldFRyYWNrcy5jYWxsKHRoaXMpO1xuICAgICAgICBjb25zdCB0cmFjayA9IGNhcHRpb25zLmZpbmRUcmFjay5jYWxsKHRoaXMsIFt0aGlzLmNhcHRpb25zLmxhbmd1YWdlLCAuLi50aGlzLmNhcHRpb25zLmxhbmd1YWdlc10sIHRydWUpO1xuXG4gICAgICAgIC8vIE92ZXJyaWRlIHVzZXIgcHJlZmVyZW5jZXMgdG8gYXZvaWQgc3dpdGNoaW5nIGxhbmd1YWdlcyBpZiBhIG1hdGNoaW5nIHRyYWNrIGlzIGFkZGVkXG4gICAgICAgIHRoaXMuY2FwdGlvbnMubGFuZ3VhZ2UgPSB0cmFjay5sYW5ndWFnZTtcblxuICAgICAgICAvLyBTZXQgY2FwdGlvbiwgYnV0IGRvbid0IHN0b3JlIGluIGxvY2FsU3RvcmFnZSBhcyB1c2VyIHByZWZlcmVuY2VcbiAgICAgICAgY2FwdGlvbnMuc2V0LmNhbGwodGhpcywgdHJhY2tzLmluZGV4T2YodHJhY2spKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUb2dnbGUgYnV0dG9uIGlmIGl0J3MgZW5hYmxlZFxuICAgICAgaWYgKHRoaXMuZWxlbWVudHMuYnV0dG9ucy5jYXB0aW9ucykge1xuICAgICAgICB0aGlzLmVsZW1lbnRzLmJ1dHRvbnMuY2FwdGlvbnMucHJlc3NlZCA9IGFjdGl2ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGNsYXNzIGhvb2tcbiAgICAgIHRvZ2dsZUNsYXNzKHRoaXMuZWxlbWVudHMuY29udGFpbmVyLCBhY3RpdmVDbGFzcywgYWN0aXZlKTtcbiAgICAgIHRoaXMuY2FwdGlvbnMudG9nZ2xlZCA9IGFjdGl2ZTtcblxuICAgICAgLy8gVXBkYXRlIHNldHRpbmdzIG1lbnVcbiAgICAgIGNvbnRyb2xzLnVwZGF0ZVNldHRpbmcuY2FsbCh0aGlzLCAnY2FwdGlvbnMnKTtcblxuICAgICAgLy8gVHJpZ2dlciBldmVudCAobm90IHVzZWQgaW50ZXJuYWxseSlcbiAgICAgIHRyaWdnZXJFdmVudC5jYWxsKHRoaXMsIHRoaXMubWVkaWEsIGFjdGl2ZSA/ICdjYXB0aW9uc2VuYWJsZWQnIDogJ2NhcHRpb25zZGlzYWJsZWQnKTtcbiAgICB9XG5cbiAgICAvLyBXYWl0IGZvciB0aGUgY2FsbCBzdGFjayB0byBjbGVhciBiZWZvcmUgc2V0dGluZyBtb2RlPSdoaWRkZW4nXG4gICAgLy8gb24gdGhlIGFjdGl2ZSB0cmFjayAtIGZvcmNpbmcgdGhlIGJyb3dzZXIgdG8gZG93bmxvYWQgaXRcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChhY3RpdmUgJiYgdGhpcy5jYXB0aW9ucy50b2dnbGVkKSB7XG4gICAgICAgIHRoaXMuY2FwdGlvbnMuY3VycmVudFRyYWNrTm9kZS5tb2RlID0gJ2hpZGRlbic7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIC8vIFNldCBjYXB0aW9ucyBieSB0cmFjayBpbmRleFxuICAvLyBVc2VkIGludGVybmFsbHkgZm9yIHRoZSBjdXJyZW50VHJhY2sgc2V0dGVyIHdpdGggdGhlIHBhc3NpdmUgb3B0aW9uIGZvcmNlZCB0byBmYWxzZVxuICBzZXQoaW5kZXgsIHBhc3NpdmUgPSB0cnVlKSB7XG4gICAgY29uc3QgdHJhY2tzID0gY2FwdGlvbnMuZ2V0VHJhY2tzLmNhbGwodGhpcyk7XG5cbiAgICAvLyBEaXNhYmxlIGNhcHRpb25zIGlmIHNldHRpbmcgdG8gLTFcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICBjYXB0aW9ucy50b2dnbGUuY2FsbCh0aGlzLCBmYWxzZSwgcGFzc2l2ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaXMubnVtYmVyKGluZGV4KSkge1xuICAgICAgdGhpcy5kZWJ1Zy53YXJuKCdJbnZhbGlkIGNhcHRpb24gYXJndW1lbnQnLCBpbmRleCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghKGluZGV4IGluIHRyYWNrcykpIHtcbiAgICAgIHRoaXMuZGVidWcud2FybignVHJhY2sgbm90IGZvdW5kJywgaW5kZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5jYXB0aW9ucy5jdXJyZW50VHJhY2sgIT09IGluZGV4KSB7XG4gICAgICB0aGlzLmNhcHRpb25zLmN1cnJlbnRUcmFjayA9IGluZGV4O1xuICAgICAgY29uc3QgdHJhY2sgPSB0cmFja3NbaW5kZXhdO1xuICAgICAgY29uc3Qge1xuICAgICAgICBsYW5ndWFnZVxuICAgICAgfSA9IHRyYWNrIHx8IHt9O1xuXG4gICAgICAvLyBTdG9yZSByZWZlcmVuY2UgdG8gbm9kZSBmb3IgaW52YWxpZGF0aW9uIG9uIHJlbW92ZVxuICAgICAgdGhpcy5jYXB0aW9ucy5jdXJyZW50VHJhY2tOb2RlID0gdHJhY2s7XG5cbiAgICAgIC8vIFVwZGF0ZSBzZXR0aW5ncyBtZW51XG4gICAgICBjb250cm9scy51cGRhdGVTZXR0aW5nLmNhbGwodGhpcywgJ2NhcHRpb25zJyk7XG5cbiAgICAgIC8vIFdoZW4gcGFzc2l2ZSwgZG9uJ3Qgb3ZlcnJpZGUgdXNlciBwcmVmZXJlbmNlc1xuICAgICAgaWYgKCFwYXNzaXZlKSB7XG4gICAgICAgIHRoaXMuY2FwdGlvbnMubGFuZ3VhZ2UgPSBsYW5ndWFnZTtcbiAgICAgICAgdGhpcy5zdG9yYWdlLnNldCh7XG4gICAgICAgICAgbGFuZ3VhZ2VcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBWaW1lbyBjYXB0aW9uc1xuICAgICAgaWYgKHRoaXMuaXNWaW1lbykge1xuICAgICAgICAvLyBFbmFibGUgdGV4dCB0cmFjayBidXQgZG9uJ3QgcmVuZGVyIGNhcHRpb25zIHdpdGhpbiB0aGUgcGxheWVyXG4gICAgICAgIC8vIFNpbmNlIHdlIGhhbmRsZSB0aGF0IG91cnNlbHZlc1xuICAgICAgICB0aGlzLmVtYmVkLmVuYWJsZVRleHRUcmFjayhsYW5ndWFnZSwgbnVsbCwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBUcmlnZ2VyIGV2ZW50XG4gICAgICB0cmlnZ2VyRXZlbnQuY2FsbCh0aGlzLCB0aGlzLm1lZGlhLCAnbGFuZ3VhZ2VjaGFuZ2UnKTtcbiAgICB9XG5cbiAgICAvLyBTaG93IGNhcHRpb25zXG4gICAgY2FwdGlvbnMudG9nZ2xlLmNhbGwodGhpcywgdHJ1ZSwgcGFzc2l2ZSk7XG4gICAgaWYgKHRoaXMuaXNIVE1MNSAmJiB0aGlzLmlzVmlkZW8pIHtcbiAgICAgIC8vIElmIHdlIGNoYW5nZSB0aGUgYWN0aXZlIHRyYWNrIHdoaWxlIGEgY3VlIGlzIGFscmVhZHkgZGlzcGxheWVkIHdlIG5lZWQgdG8gdXBkYXRlIGl0XG4gICAgICBjYXB0aW9ucy51cGRhdGVDdWVzLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LFxuICAvLyBTZXQgY2FwdGlvbnMgYnkgbGFuZ3VhZ2VcbiAgLy8gVXNlZCBpbnRlcm5hbGx5IGZvciB0aGUgbGFuZ3VhZ2Ugc2V0dGVyIHdpdGggdGhlIHBhc3NpdmUgb3B0aW9uIGZvcmNlZCB0byBmYWxzZVxuICBzZXRMYW5ndWFnZShpbnB1dCwgcGFzc2l2ZSA9IHRydWUpIHtcbiAgICBpZiAoIWlzLnN0cmluZyhpbnB1dCkpIHtcbiAgICAgIHRoaXMuZGVidWcud2FybignSW52YWxpZCBsYW5ndWFnZSBhcmd1bWVudCcsIGlucHV0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplXG4gICAgY29uc3QgbGFuZ3VhZ2UgPSBpbnB1dC50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMuY2FwdGlvbnMubGFuZ3VhZ2UgPSBsYW5ndWFnZTtcblxuICAgIC8vIFNldCBjdXJyZW50VHJhY2tcbiAgICBjb25zdCB0cmFja3MgPSBjYXB0aW9ucy5nZXRUcmFja3MuY2FsbCh0aGlzKTtcbiAgICBjb25zdCB0cmFjayA9IGNhcHRpb25zLmZpbmRUcmFjay5jYWxsKHRoaXMsIFtsYW5ndWFnZV0pO1xuICAgIGNhcHRpb25zLnNldC5jYWxsKHRoaXMsIHRyYWNrcy5pbmRleE9mKHRyYWNrKSwgcGFzc2l2ZSk7XG4gIH0sXG4gIC8vIEdldCBjdXJyZW50IHZhbGlkIGNhcHRpb24gdHJhY2tzXG4gIC8vIElmIHVwZGF0ZSBpcyBmYWxzZSBpdCB3aWxsIGFsc28gaWdub3JlIHRyYWNrcyB3aXRob3V0IG1ldGFkYXRhXG4gIC8vIFRoaXMgaXMgdXNlZCB0byBcImZyZWV6ZVwiIHRoZSBsYW5ndWFnZSBvcHRpb25zIHdoZW4gY2FwdGlvbnMudXBkYXRlIGlzIGZhbHNlXG4gIGdldFRyYWNrcyh1cGRhdGUgPSBmYWxzZSkge1xuICAgIC8vIEhhbmRsZSBtZWRpYSBvciB0ZXh0VHJhY2tzIG1pc3Npbmcgb3IgbnVsbFxuICAgIGNvbnN0IHRyYWNrcyA9IEFycmF5LmZyb20oKHRoaXMubWVkaWEgfHwge30pLnRleHRUcmFja3MgfHwgW10pO1xuICAgIC8vIEZvciBIVE1MNSwgdXNlIGNhY2hlIGluc3RlYWQgb2YgY3VycmVudCB0cmFja3Mgd2hlbiBpdCBleGlzdHMgKGlmIGNhcHRpb25zLnVwZGF0ZSBpcyBmYWxzZSlcbiAgICAvLyBGaWx0ZXIgb3V0IHJlbW92ZWQgdHJhY2tzIGFuZCB0cmFja3MgdGhhdCBhcmVuJ3QgY2FwdGlvbnMvc3VidGl0bGVzIChmb3IgZXhhbXBsZSBtZXRhZGF0YSlcbiAgICByZXR1cm4gdHJhY2tzLmZpbHRlcih0cmFjayA9PiAhdGhpcy5pc0hUTUw1IHx8IHVwZGF0ZSB8fCB0aGlzLmNhcHRpb25zLm1ldGEuaGFzKHRyYWNrKSkuZmlsdGVyKHRyYWNrID0+IFsnY2FwdGlvbnMnLCAnc3VidGl0bGVzJ10uaW5jbHVkZXModHJhY2sua2luZCkpO1xuICB9LFxuICAvLyBNYXRjaCB0cmFja3MgYmFzZWQgb24gbGFuZ3VhZ2VzIGFuZCBnZXQgdGhlIGZpcnN0XG4gIGZpbmRUcmFjayhsYW5ndWFnZXMsIGZvcmNlID0gZmFsc2UpIHtcbiAgICBjb25zdCB0cmFja3MgPSBjYXB0aW9ucy5nZXRUcmFja3MuY2FsbCh0aGlzKTtcbiAgICBjb25zdCBzb3J0SXNEZWZhdWx0ID0gdHJhY2sgPT4gTnVtYmVyKCh0aGlzLmNhcHRpb25zLm1ldGEuZ2V0KHRyYWNrKSB8fCB7fSkuZGVmYXVsdCk7XG4gICAgY29uc3Qgc29ydGVkID0gQXJyYXkuZnJvbSh0cmFja3MpLnNvcnQoKGEsIGIpID0+IHNvcnRJc0RlZmF1bHQoYikgLSBzb3J0SXNEZWZhdWx0KGEpKTtcbiAgICBsZXQgdHJhY2s7XG4gICAgbGFuZ3VhZ2VzLmV2ZXJ5KGxhbmd1YWdlID0+IHtcbiAgICAgIHRyYWNrID0gc29ydGVkLmZpbmQodCA9PiB0Lmxhbmd1YWdlID09PSBsYW5ndWFnZSk7XG4gICAgICByZXR1cm4gIXRyYWNrOyAvLyBCcmVhayBpdGVyYXRpb24gaWYgdGhlcmUgaXMgYSBtYXRjaFxuICAgIH0pO1xuXG4gICAgLy8gSWYgbm8gbWF0Y2ggaXMgZm91bmQgYnV0IGlzIHJlcXVpcmVkLCBnZXQgZmlyc3RcbiAgICByZXR1cm4gdHJhY2sgfHwgKGZvcmNlID8gc29ydGVkWzBdIDogdW5kZWZpbmVkKTtcbiAgfSxcbiAgLy8gR2V0IHRoZSBjdXJyZW50IHRyYWNrXG4gIGdldEN1cnJlbnRUcmFjaygpIHtcbiAgICByZXR1cm4gY2FwdGlvbnMuZ2V0VHJhY2tzLmNhbGwodGhpcylbdGhpcy5jdXJyZW50VHJhY2tdO1xuICB9LFxuICAvLyBHZXQgVUkgbGFiZWwgZm9yIHRyYWNrXG4gIGdldExhYmVsKHRyYWNrKSB7XG4gICAgbGV0IGN1cnJlbnRUcmFjayA9IHRyYWNrO1xuICAgIGlmICghaXMudHJhY2soY3VycmVudFRyYWNrKSAmJiBzdXBwb3J0LnRleHRUcmFja3MgJiYgdGhpcy5jYXB0aW9ucy50b2dnbGVkKSB7XG4gICAgICBjdXJyZW50VHJhY2sgPSBjYXB0aW9ucy5nZXRDdXJyZW50VHJhY2suY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgaWYgKGlzLnRyYWNrKGN1cnJlbnRUcmFjaykpIHtcbiAgICAgIGlmICghaXMuZW1wdHkoY3VycmVudFRyYWNrLmxhYmVsKSkge1xuICAgICAgICByZXR1cm4gY3VycmVudFRyYWNrLmxhYmVsO1xuICAgICAgfVxuICAgICAgaWYgKCFpcy5lbXB0eShjdXJyZW50VHJhY2subGFuZ3VhZ2UpKSB7XG4gICAgICAgIHJldHVybiB0cmFjay5sYW5ndWFnZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGkxOG4uZ2V0KCdlbmFibGVkJywgdGhpcy5jb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gaTE4bi5nZXQoJ2Rpc2FibGVkJywgdGhpcy5jb25maWcpO1xuICB9LFxuICAvLyBVcGRhdGUgY2FwdGlvbnMgdXNpbmcgY3VycmVudCB0cmFjaydzIGFjdGl2ZSBjdWVzXG4gIC8vIEFsc28gb3B0aW9uYWwgYXJyYXkgYXJndW1lbnQgaW4gY2FzZSB0aGVyZSBpc24ndCBhbnkgdHJhY2sgKGV4OiB2aW1lbylcbiAgdXBkYXRlQ3VlcyhpbnB1dCkge1xuICAgIC8vIFJlcXVpcmVzIFVJXG4gICAgaWYgKCF0aGlzLnN1cHBvcnRlZC51aSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlzLmVsZW1lbnQodGhpcy5lbGVtZW50cy5jYXB0aW9ucykpIHtcbiAgICAgIHRoaXMuZGVidWcud2FybignTm8gY2FwdGlvbnMgZWxlbWVudCB0byByZW5kZXIgdG8nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBPbmx5IGFjY2VwdCBhcnJheSBvciBlbXB0eSBpbnB1dFxuICAgIGlmICghaXMubnVsbE9yVW5kZWZpbmVkKGlucHV0KSAmJiAhQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgIHRoaXMuZGVidWcud2FybigndXBkYXRlQ3VlczogSW52YWxpZCBpbnB1dCcsIGlucHV0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGN1ZXMgPSBpbnB1dDtcblxuICAgIC8vIEdldCBjdWVzIGZyb20gdHJhY2tcbiAgICBpZiAoIWN1ZXMpIHtcbiAgICAgIGNvbnN0IHRyYWNrID0gY2FwdGlvbnMuZ2V0Q3VycmVudFRyYWNrLmNhbGwodGhpcyk7XG4gICAgICBjdWVzID0gQXJyYXkuZnJvbSgodHJhY2sgfHwge30pLmFjdGl2ZUN1ZXMgfHwgW10pLm1hcChjdWUgPT4gY3VlLmdldEN1ZUFzSFRNTCgpKS5tYXAoZ2V0SFRNTCk7XG4gICAgfVxuXG4gICAgLy8gU2V0IG5ldyBjYXB0aW9uIHRleHRcbiAgICBjb25zdCBjb250ZW50ID0gY3Vlcy5tYXAoY3VlVGV4dCA9PiBjdWVUZXh0LnRyaW0oKSkuam9pbignXFxuJyk7XG4gICAgY29uc3QgY2hhbmdlZCA9IGNvbnRlbnQgIT09IHRoaXMuZWxlbWVudHMuY2FwdGlvbnMuaW5uZXJIVE1MO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAvLyBFbXB0eSB0aGUgY29udGFpbmVyIGFuZCBjcmVhdGUgYSBuZXcgY2hpbGQgZWxlbWVudFxuICAgICAgZW1wdHlFbGVtZW50KHRoaXMuZWxlbWVudHMuY2FwdGlvbnMpO1xuICAgICAgY29uc3QgY2FwdGlvbiA9IGNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCBnZXRBdHRyaWJ1dGVzRnJvbVNlbGVjdG9yKHRoaXMuY29uZmlnLnNlbGVjdG9ycy5jYXB0aW9uKSk7XG4gICAgICBjYXB0aW9uLmlubmVySFRNTCA9IGNvbnRlbnQ7XG4gICAgICB0aGlzLmVsZW1lbnRzLmNhcHRpb25zLmFwcGVuZENoaWxkKGNhcHRpb24pO1xuXG4gICAgICAvLyBUcmlnZ2VyIGV2ZW50XG4gICAgICB0cmlnZ2VyRXZlbnQuY2FsbCh0aGlzLCB0aGlzLm1lZGlhLCAnY3VlY2hhbmdlJyk7XG4gICAgfVxuICB9XG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gUGx5ciBkZWZhdWx0IGNvbmZpZ1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgZGVmYXVsdHMgPSB7XG4gIC8vIERpc2FibGVcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgLy8gQ3VzdG9tIG1lZGlhIHRpdGxlXG4gIHRpdGxlOiAnJyxcbiAgLy8gTG9nZ2luZyB0byBjb25zb2xlXG4gIGRlYnVnOiBmYWxzZSxcbiAgLy8gQXV0byBwbGF5IChpZiBzdXBwb3J0ZWQpXG4gIGF1dG9wbGF5OiBmYWxzZSxcbiAgLy8gT25seSBhbGxvdyBvbmUgbWVkaWEgcGxheWluZyBhdCBvbmNlICh2aW1lbyBvbmx5KVxuICBhdXRvcGF1c2U6IHRydWUsXG4gIC8vIEFsbG93IGlubGluZSBwbGF5YmFjayBvbiBpT1NcbiAgcGxheXNpbmxpbmU6IHRydWUsXG4gIC8vIERlZmF1bHQgdGltZSB0byBza2lwIHdoZW4gcmV3aW5kL2Zhc3QgZm9yd2FyZFxuICBzZWVrVGltZTogMTAsXG4gIC8vIERlZmF1bHQgdm9sdW1lXG4gIHZvbHVtZTogMSxcbiAgbXV0ZWQ6IGZhbHNlLFxuICAvLyBQYXNzIGEgY3VzdG9tIGR1cmF0aW9uXG4gIGR1cmF0aW9uOiBudWxsLFxuICAvLyBEaXNwbGF5IHRoZSBtZWRpYSBkdXJhdGlvbiBvbiBsb2FkIGluIHRoZSBjdXJyZW50IHRpbWUgcG9zaXRpb25cbiAgLy8gSWYgeW91IGhhdmUgb3B0ZWQgdG8gZGlzcGxheSBib3RoIGR1cmF0aW9uIGFuZCBjdXJyZW50VGltZSwgdGhpcyBpcyBpZ25vcmVkXG4gIGRpc3BsYXlEdXJhdGlvbjogdHJ1ZSxcbiAgLy8gSW52ZXJ0IHRoZSBjdXJyZW50IHRpbWUgdG8gYmUgYSBjb3VudGRvd25cbiAgaW52ZXJ0VGltZTogdHJ1ZSxcbiAgLy8gQ2xpY2tpbmcgdGhlIGN1cnJlbnRUaW1lIGludmVydHMgaXQncyB2YWx1ZSB0byBzaG93IHRpbWUgbGVmdCByYXRoZXIgdGhhbiBlbGFwc2VkXG4gIHRvZ2dsZUludmVydDogdHJ1ZSxcbiAgLy8gRm9yY2UgYW4gYXNwZWN0IHJhdGlvXG4gIC8vIFRoZSBmb3JtYXQgbXVzdCBiZSBgJ3c6aCdgIChlLmcuIGAnMTY6OSdgKVxuICByYXRpbzogbnVsbCxcbiAgLy8gQ2xpY2sgdmlkZW8gY29udGFpbmVyIHRvIHBsYXkvcGF1c2VcbiAgY2xpY2tUb1BsYXk6IHRydWUsXG4gIC8vIEF1dG8gaGlkZSB0aGUgY29udHJvbHNcbiAgaGlkZUNvbnRyb2xzOiB0cnVlLFxuICAvLyBSZXNldCB0byBzdGFydCB3aGVuIHBsYXliYWNrIGVuZGVkXG4gIHJlc2V0T25FbmQ6IGZhbHNlLFxuICAvLyBEaXNhYmxlIHRoZSBzdGFuZGFyZCBjb250ZXh0IG1lbnVcbiAgZGlzYWJsZUNvbnRleHRNZW51OiB0cnVlLFxuICAvLyBTcHJpdGUgKGZvciBpY29ucylcbiAgbG9hZFNwcml0ZTogdHJ1ZSxcbiAgaWNvblByZWZpeDogJ3BseXInLFxuICBpY29uVXJsOiAnaHR0cHM6Ly9jZG4ucGx5ci5pby8zLjguNC9wbHlyLnN2ZycsXG4gIC8vIEJsYW5rIHZpZGVvICh1c2VkIHRvIHByZXZlbnQgZXJyb3JzIG9uIHNvdXJjZSBjaGFuZ2UpXG4gIGJsYW5rVmlkZW86ICdodHRwczovL2Nkbi5wbHlyLmlvL3N0YXRpYy9ibGFuay5tcDQnLFxuICAvLyBRdWFsaXR5IGRlZmF1bHRcbiAgcXVhbGl0eToge1xuICAgIGRlZmF1bHQ6IDU3NixcbiAgICAvLyBUaGUgb3B0aW9ucyB0byBkaXNwbGF5IGluIHRoZSBVSSwgaWYgYXZhaWxhYmxlIGZvciB0aGUgc291cmNlIG1lZGlhXG4gICAgb3B0aW9uczogWzQzMjAsIDI4ODAsIDIxNjAsIDE0NDAsIDEwODAsIDcyMCwgNTc2LCA0ODAsIDM2MCwgMjQwXSxcbiAgICBmb3JjZWQ6IGZhbHNlLFxuICAgIG9uQ2hhbmdlOiBudWxsXG4gIH0sXG4gIC8vIFNldCBsb29wc1xuICBsb29wOiB7XG4gICAgYWN0aXZlOiBmYWxzZVxuICAgIC8vIHN0YXJ0OiBudWxsLFxuICAgIC8vIGVuZDogbnVsbCxcbiAgfSxcbiAgLy8gU3BlZWQgZGVmYXVsdCBhbmQgb3B0aW9ucyB0byBkaXNwbGF5XG4gIHNwZWVkOiB7XG4gICAgc2VsZWN0ZWQ6IDEsXG4gICAgLy8gVGhlIG9wdGlvbnMgdG8gZGlzcGxheSBpbiB0aGUgVUksIGlmIGF2YWlsYWJsZSBmb3IgdGhlIHNvdXJjZSBtZWRpYSAoZS5nLiBWaW1lbyBhbmQgWW91VHViZSBvbmx5IHN1cHBvcnQgMC41eC00eClcbiAgICBvcHRpb25zOiBbMC41LCAwLjc1LCAxLCAxLjI1LCAxLjUsIDEuNzUsIDIsIDRdXG4gIH0sXG4gIC8vIEtleWJvYXJkIHNob3J0Y3V0IHNldHRpbmdzXG4gIGtleWJvYXJkOiB7XG4gICAgZm9jdXNlZDogdHJ1ZSxcbiAgICBnbG9iYWw6IGZhbHNlXG4gIH0sXG4gIC8vIERpc3BsYXkgdG9vbHRpcHNcbiAgdG9vbHRpcHM6IHtcbiAgICBjb250cm9sczogZmFsc2UsXG4gICAgc2VlazogdHJ1ZVxuICB9LFxuICAvLyBDYXB0aW9ucyBzZXR0aW5nc1xuICBjYXB0aW9uczoge1xuICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgbGFuZ3VhZ2U6ICdhdXRvJyxcbiAgICAvLyBMaXN0ZW4gdG8gbmV3IHRyYWNrcyBhZGRlZCBhZnRlciBQbHlyIGlzIGluaXRpYWxpemVkLlxuICAgIC8vIFRoaXMgaXMgbmVlZGVkIGZvciBzdHJlYW1pbmcgY2FwdGlvbnMsIGJ1dCBtYXkgcmVzdWx0IGluIHVuc2VsZWN0YWJsZSBvcHRpb25zXG4gICAgdXBkYXRlOiBmYWxzZVxuICB9LFxuICAvLyBGdWxsc2NyZWVuIHNldHRpbmdzXG4gIGZ1bGxzY3JlZW46IHtcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8vIEFsbG93IGZ1bGxzY3JlZW4/XG4gICAgZmFsbGJhY2s6IHRydWUsXG4gICAgLy8gRmFsbGJhY2sgdXNpbmcgZnVsbCB2aWV3cG9ydC93aW5kb3dcbiAgICBpb3NOYXRpdmU6IGZhbHNlIC8vIFVzZSB0aGUgbmF0aXZlIGZ1bGxzY3JlZW4gaW4gaU9TIChkaXNhYmxlcyBjdXN0b20gY29udHJvbHMpXG4gICAgLy8gU2VsZWN0b3IgZm9yIHRoZSBmdWxsc2NyZWVuIGNvbnRhaW5lciBzbyBjb250ZXh0dWFsIC8gbm9uLXBsYXllciBjb250ZW50IGNhbiByZW1haW4gdmlzaWJsZSBpbiBmdWxsc2NyZWVuIG1vZGVcbiAgICAvLyBOb24tYW5jZXN0b3JzIG9mIHRoZSBwbGF5ZXIgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWRcbiAgICAvLyBjb250YWluZXI6IG51bGwsIC8vIGRlZmF1bHRzIHRvIHRoZSBwbGF5ZXIgZWxlbWVudFxuICB9LFxuICAvLyBMb2NhbCBzdG9yYWdlXG4gIHN0b3JhZ2U6IHtcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGtleTogJ3BseXInXG4gIH0sXG4gIC8vIERlZmF1bHQgY29udHJvbHNcbiAgY29udHJvbHM6IFsncGxheS1sYXJnZScsXG4gIC8vICdyZXN0YXJ0JyxcbiAgLy8gJ3Jld2luZCcsXG4gICdwbGF5JyxcbiAgLy8gJ2Zhc3QtZm9yd2FyZCcsXG4gICdwcm9ncmVzcycsICdjdXJyZW50LXRpbWUnLFxuICAvLyAnZHVyYXRpb24nLFxuICAnbXV0ZScsICd2b2x1bWUnLCAnY2FwdGlvbnMnLCAnc2V0dGluZ3MnLCAncGlwJywgJ2FpcnBsYXknLFxuICAvLyAnZG93bmxvYWQnLFxuICAnZnVsbHNjcmVlbiddLFxuICBzZXR0aW5nczogWydjYXB0aW9ucycsICdxdWFsaXR5JywgJ3NwZWVkJ10sXG4gIC8vIExvY2FsaXNhdGlvblxuICBpMThuOiB7XG4gICAgcmVzdGFydDogJ1Jlc3RhcnQnLFxuICAgIHJld2luZDogJ1Jld2luZCB7c2Vla3RpbWV9cycsXG4gICAgcGxheTogJ1BsYXknLFxuICAgIHBhdXNlOiAnUGF1c2UnLFxuICAgIGZhc3RGb3J3YXJkOiAnRm9yd2FyZCB7c2Vla3RpbWV9cycsXG4gICAgc2VlazogJ1NlZWsnLFxuICAgIHNlZWtMYWJlbDogJ3tjdXJyZW50VGltZX0gb2Yge2R1cmF0aW9ufScsXG4gICAgcGxheWVkOiAnUGxheWVkJyxcbiAgICBidWZmZXJlZDogJ0J1ZmZlcmVkJyxcbiAgICBjdXJyZW50VGltZTogJ0N1cnJlbnQgdGltZScsXG4gICAgZHVyYXRpb246ICdEdXJhdGlvbicsXG4gICAgdm9sdW1lOiAnVm9sdW1lJyxcbiAgICBtdXRlOiAnTXV0ZScsXG4gICAgdW5tdXRlOiAnVW5tdXRlJyxcbiAgICBlbmFibGVDYXB0aW9uczogJ0VuYWJsZSBjYXB0aW9ucycsXG4gICAgZGlzYWJsZUNhcHRpb25zOiAnRGlzYWJsZSBjYXB0aW9ucycsXG4gICAgZG93bmxvYWQ6ICdEb3dubG9hZCcsXG4gICAgZW50ZXJGdWxsc2NyZWVuOiAnRW50ZXIgZnVsbHNjcmVlbicsXG4gICAgZXhpdEZ1bGxzY3JlZW46ICdFeGl0IGZ1bGxzY3JlZW4nLFxuICAgIGZyYW1lVGl0bGU6ICdQbGF5ZXIgZm9yIHt0aXRsZX0nLFxuICAgIGNhcHRpb25zOiAnQ2FwdGlvbnMnLFxuICAgIHNldHRpbmdzOiAnU2V0dGluZ3MnLFxuICAgIHBpcDogJ1BJUCcsXG4gICAgbWVudUJhY2s6ICdHbyBiYWNrIHRvIHByZXZpb3VzIG1lbnUnLFxuICAgIHNwZWVkOiAnU3BlZWQnLFxuICAgIG5vcm1hbDogJ05vcm1hbCcsXG4gICAgcXVhbGl0eTogJ1F1YWxpdHknLFxuICAgIGxvb3A6ICdMb29wJyxcbiAgICBzdGFydDogJ1N0YXJ0JyxcbiAgICBlbmQ6ICdFbmQnLFxuICAgIGFsbDogJ0FsbCcsXG4gICAgcmVzZXQ6ICdSZXNldCcsXG4gICAgZGlzYWJsZWQ6ICdEaXNhYmxlZCcsXG4gICAgZW5hYmxlZDogJ0VuYWJsZWQnLFxuICAgIGFkdmVydGlzZW1lbnQ6ICdBZCcsXG4gICAgcXVhbGl0eUJhZGdlOiB7XG4gICAgICAyMTYwOiAnNEsnLFxuICAgICAgMTQ0MDogJ0hEJyxcbiAgICAgIDEwODA6ICdIRCcsXG4gICAgICA3MjA6ICdIRCcsXG4gICAgICA1NzY6ICdTRCcsXG4gICAgICA0ODA6ICdTRCdcbiAgICB9XG4gIH0sXG4gIC8vIFVSTHNcbiAgdXJsczoge1xuICAgIGRvd25sb2FkOiBudWxsLFxuICAgIHZpbWVvOiB7XG4gICAgICBzZGs6ICdodHRwczovL3BsYXllci52aW1lby5jb20vYXBpL3BsYXllci5qcycsXG4gICAgICBpZnJhbWU6ICdodHRwczovL3BsYXllci52aW1lby5jb20vdmlkZW8vezB9P3sxfScsXG4gICAgICBhcGk6ICdodHRwczovL3ZpbWVvLmNvbS9hcGkvb2VtYmVkLmpzb24/dXJsPXswfSdcbiAgICB9LFxuICAgIHlvdXR1YmU6IHtcbiAgICAgIHNkazogJ2h0dHBzOi8vd3d3LnlvdXR1YmUuY29tL2lmcmFtZV9hcGknLFxuICAgICAgYXBpOiAnaHR0cHM6Ly9ub2VtYmVkLmNvbS9lbWJlZD91cmw9aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj17MH0nXG4gICAgfSxcbiAgICBnb29nbGVJTUE6IHtcbiAgICAgIHNkazogJ2h0dHBzOi8vaW1hc2RrLmdvb2dsZWFwaXMuY29tL2pzL3Nka2xvYWRlci9pbWEzLmpzJ1xuICAgIH1cbiAgfSxcbiAgLy8gQ3VzdG9tIGNvbnRyb2wgbGlzdGVuZXJzXG4gIGxpc3RlbmVyczoge1xuICAgIHNlZWs6IG51bGwsXG4gICAgcGxheTogbnVsbCxcbiAgICBwYXVzZTogbnVsbCxcbiAgICByZXN0YXJ0OiBudWxsLFxuICAgIHJld2luZDogbnVsbCxcbiAgICBmYXN0Rm9yd2FyZDogbnVsbCxcbiAgICBtdXRlOiBudWxsLFxuICAgIHZvbHVtZTogbnVsbCxcbiAgICBjYXB0aW9uczogbnVsbCxcbiAgICBkb3dubG9hZDogbnVsbCxcbiAgICBmdWxsc2NyZWVuOiBudWxsLFxuICAgIHBpcDogbnVsbCxcbiAgICBhaXJwbGF5OiBudWxsLFxuICAgIHNwZWVkOiBudWxsLFxuICAgIHF1YWxpdHk6IG51bGwsXG4gICAgbG9vcDogbnVsbCxcbiAgICBsYW5ndWFnZTogbnVsbFxuICB9LFxuICAvLyBFdmVudHMgdG8gd2F0Y2ggYW5kIGJ1YmJsZVxuICBldmVudHM6IFtcbiAgLy8gRXZlbnRzIHRvIHdhdGNoIG9uIEhUTUw1IG1lZGlhIGVsZW1lbnRzIGFuZCBidWJibGVcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvR3VpZGUvRXZlbnRzL01lZGlhX2V2ZW50c1xuICAnZW5kZWQnLCAncHJvZ3Jlc3MnLCAnc3RhbGxlZCcsICdwbGF5aW5nJywgJ3dhaXRpbmcnLCAnY2FucGxheScsICdjYW5wbGF5dGhyb3VnaCcsICdsb2Fkc3RhcnQnLCAnbG9hZGVkZGF0YScsICdsb2FkZWRtZXRhZGF0YScsICd0aW1ldXBkYXRlJywgJ3ZvbHVtZWNoYW5nZScsICdwbGF5JywgJ3BhdXNlJywgJ2Vycm9yJywgJ3NlZWtpbmcnLCAnc2Vla2VkJywgJ2VtcHRpZWQnLCAncmF0ZWNoYW5nZScsICdjdWVjaGFuZ2UnLFxuICAvLyBDdXN0b20gZXZlbnRzXG4gICdkb3dubG9hZCcsICdlbnRlcmZ1bGxzY3JlZW4nLCAnZXhpdGZ1bGxzY3JlZW4nLCAnY2FwdGlvbnNlbmFibGVkJywgJ2NhcHRpb25zZGlzYWJsZWQnLCAnbGFuZ3VhZ2VjaGFuZ2UnLCAnY29udHJvbHNoaWRkZW4nLCAnY29udHJvbHNzaG93bicsICdyZWFkeScsXG4gIC8vIFlvdVR1YmVcbiAgJ3N0YXRlY2hhbmdlJyxcbiAgLy8gUXVhbGl0eVxuICAncXVhbGl0eWNoYW5nZScsXG4gIC8vIEFkc1xuICAnYWRzbG9hZGVkJywgJ2Fkc2NvbnRlbnRwYXVzZScsICdhZHNjb250ZW50cmVzdW1lJywgJ2Fkc3RhcnRlZCcsICdhZHNtaWRwb2ludCcsICdhZHNjb21wbGV0ZScsICdhZHNhbGxjb21wbGV0ZScsICdhZHNpbXByZXNzaW9uJywgJ2Fkc2NsaWNrJ10sXG4gIC8vIFNlbGVjdG9yc1xuICAvLyBDaGFuZ2UgdGhlc2UgdG8gbWF0Y2ggeW91ciB0ZW1wbGF0ZSBpZiB1c2luZyBjdXN0b20gSFRNTFxuICBzZWxlY3RvcnM6IHtcbiAgICBlZGl0YWJsZTogJ2lucHV0LCB0ZXh0YXJlYSwgc2VsZWN0LCBbY29udGVudGVkaXRhYmxlXScsXG4gICAgY29udGFpbmVyOiAnLnBseXInLFxuICAgIGNvbnRyb2xzOiB7XG4gICAgICBjb250YWluZXI6IG51bGwsXG4gICAgICB3cmFwcGVyOiAnLnBseXJfX2NvbnRyb2xzJ1xuICAgIH0sXG4gICAgbGFiZWxzOiAnW2RhdGEtcGx5cl0nLFxuICAgIGJ1dHRvbnM6IHtcbiAgICAgIHBsYXk6ICdbZGF0YS1wbHlyPVwicGxheVwiXScsXG4gICAgICBwYXVzZTogJ1tkYXRhLXBseXI9XCJwYXVzZVwiXScsXG4gICAgICByZXN0YXJ0OiAnW2RhdGEtcGx5cj1cInJlc3RhcnRcIl0nLFxuICAgICAgcmV3aW5kOiAnW2RhdGEtcGx5cj1cInJld2luZFwiXScsXG4gICAgICBmYXN0Rm9yd2FyZDogJ1tkYXRhLXBseXI9XCJmYXN0LWZvcndhcmRcIl0nLFxuICAgICAgbXV0ZTogJ1tkYXRhLXBseXI9XCJtdXRlXCJdJyxcbiAgICAgIGNhcHRpb25zOiAnW2RhdGEtcGx5cj1cImNhcHRpb25zXCJdJyxcbiAgICAgIGRvd25sb2FkOiAnW2RhdGEtcGx5cj1cImRvd25sb2FkXCJdJyxcbiAgICAgIGZ1bGxzY3JlZW46ICdbZGF0YS1wbHlyPVwiZnVsbHNjcmVlblwiXScsXG4gICAgICBwaXA6ICdbZGF0YS1wbHlyPVwicGlwXCJdJyxcbiAgICAgIGFpcnBsYXk6ICdbZGF0YS1wbHlyPVwiYWlycGxheVwiXScsXG4gICAgICBzZXR0aW5nczogJ1tkYXRhLXBseXI9XCJzZXR0aW5nc1wiXScsXG4gICAgICBsb29wOiAnW2RhdGEtcGx5cj1cImxvb3BcIl0nXG4gICAgfSxcbiAgICBpbnB1dHM6IHtcbiAgICAgIHNlZWs6ICdbZGF0YS1wbHlyPVwic2Vla1wiXScsXG4gICAgICB2b2x1bWU6ICdbZGF0YS1wbHlyPVwidm9sdW1lXCJdJyxcbiAgICAgIHNwZWVkOiAnW2RhdGEtcGx5cj1cInNwZWVkXCJdJyxcbiAgICAgIGxhbmd1YWdlOiAnW2RhdGEtcGx5cj1cImxhbmd1YWdlXCJdJyxcbiAgICAgIHF1YWxpdHk6ICdbZGF0YS1wbHlyPVwicXVhbGl0eVwiXSdcbiAgICB9LFxuICAgIGRpc3BsYXk6IHtcbiAgICAgIGN1cnJlbnRUaW1lOiAnLnBseXJfX3RpbWUtLWN1cnJlbnQnLFxuICAgICAgZHVyYXRpb246ICcucGx5cl9fdGltZS0tZHVyYXRpb24nLFxuICAgICAgYnVmZmVyOiAnLnBseXJfX3Byb2dyZXNzX19idWZmZXInLFxuICAgICAgbG9vcDogJy5wbHlyX19wcm9ncmVzc19fbG9vcCcsXG4gICAgICAvLyBVc2VkIGxhdGVyXG4gICAgICB2b2x1bWU6ICcucGx5cl9fdm9sdW1lLS1kaXNwbGF5J1xuICAgIH0sXG4gICAgcHJvZ3Jlc3M6ICcucGx5cl9fcHJvZ3Jlc3MnLFxuICAgIGNhcHRpb25zOiAnLnBseXJfX2NhcHRpb25zJyxcbiAgICBjYXB0aW9uOiAnLnBseXJfX2NhcHRpb24nXG4gIH0sXG4gIC8vIENsYXNzIGhvb2tzIGFkZGVkIHRvIHRoZSBwbGF5ZXIgaW4gZGlmZmVyZW50IHN0YXRlc1xuICBjbGFzc05hbWVzOiB7XG4gICAgdHlwZTogJ3BseXItLXswfScsXG4gICAgcHJvdmlkZXI6ICdwbHlyLS17MH0nLFxuICAgIHZpZGVvOiAncGx5cl9fdmlkZW8td3JhcHBlcicsXG4gICAgZW1iZWQ6ICdwbHlyX192aWRlby1lbWJlZCcsXG4gICAgdmlkZW9GaXhlZFJhdGlvOiAncGx5cl9fdmlkZW8td3JhcHBlci0tZml4ZWQtcmF0aW8nLFxuICAgIGVtYmVkQ29udGFpbmVyOiAncGx5cl9fdmlkZW8tZW1iZWRfX2NvbnRhaW5lcicsXG4gICAgcG9zdGVyOiAncGx5cl9fcG9zdGVyJyxcbiAgICBwb3N0ZXJFbmFibGVkOiAncGx5cl9fcG9zdGVyLWVuYWJsZWQnLFxuICAgIGFkczogJ3BseXJfX2FkcycsXG4gICAgY29udHJvbDogJ3BseXJfX2NvbnRyb2wnLFxuICAgIGNvbnRyb2xQcmVzc2VkOiAncGx5cl9fY29udHJvbC0tcHJlc3NlZCcsXG4gICAgcGxheWluZzogJ3BseXItLXBsYXlpbmcnLFxuICAgIHBhdXNlZDogJ3BseXItLXBhdXNlZCcsXG4gICAgc3RvcHBlZDogJ3BseXItLXN0b3BwZWQnLFxuICAgIGxvYWRpbmc6ICdwbHlyLS1sb2FkaW5nJyxcbiAgICBob3ZlcjogJ3BseXItLWhvdmVyJyxcbiAgICB0b29sdGlwOiAncGx5cl9fdG9vbHRpcCcsXG4gICAgY3VlczogJ3BseXJfX2N1ZXMnLFxuICAgIG1hcmtlcjogJ3BseXJfX3Byb2dyZXNzX19tYXJrZXInLFxuICAgIGhpZGRlbjogJ3BseXJfX3NyLW9ubHknLFxuICAgIGhpZGVDb250cm9sczogJ3BseXItLWhpZGUtY29udHJvbHMnLFxuICAgIGlzVG91Y2g6ICdwbHlyLS1pcy10b3VjaCcsXG4gICAgdWlTdXBwb3J0ZWQ6ICdwbHlyLS1mdWxsLXVpJyxcbiAgICBub1RyYW5zaXRpb246ICdwbHlyLS1uby10cmFuc2l0aW9uJyxcbiAgICBkaXNwbGF5OiB7XG4gICAgICB0aW1lOiAncGx5cl9fdGltZSdcbiAgICB9LFxuICAgIG1lbnU6IHtcbiAgICAgIHZhbHVlOiAncGx5cl9fbWVudV9fdmFsdWUnLFxuICAgICAgYmFkZ2U6ICdwbHlyX19iYWRnZScsXG4gICAgICBvcGVuOiAncGx5ci0tbWVudS1vcGVuJ1xuICAgIH0sXG4gICAgY2FwdGlvbnM6IHtcbiAgICAgIGVuYWJsZWQ6ICdwbHlyLS1jYXB0aW9ucy1lbmFibGVkJyxcbiAgICAgIGFjdGl2ZTogJ3BseXItLWNhcHRpb25zLWFjdGl2ZSdcbiAgICB9LFxuICAgIGZ1bGxzY3JlZW46IHtcbiAgICAgIGVuYWJsZWQ6ICdwbHlyLS1mdWxsc2NyZWVuLWVuYWJsZWQnLFxuICAgICAgZmFsbGJhY2s6ICdwbHlyLS1mdWxsc2NyZWVuLWZhbGxiYWNrJ1xuICAgIH0sXG4gICAgcGlwOiB7XG4gICAgICBzdXBwb3J0ZWQ6ICdwbHlyLS1waXAtc3VwcG9ydGVkJyxcbiAgICAgIGFjdGl2ZTogJ3BseXItLXBpcC1hY3RpdmUnXG4gICAgfSxcbiAgICBhaXJwbGF5OiB7XG4gICAgICBzdXBwb3J0ZWQ6ICdwbHlyLS1haXJwbGF5LXN1cHBvcnRlZCcsXG4gICAgICBhY3RpdmU6ICdwbHlyLS1haXJwbGF5LWFjdGl2ZSdcbiAgICB9LFxuICAgIHByZXZpZXdUaHVtYm5haWxzOiB7XG4gICAgICAvLyBUb29sdGlwIHRodW1ic1xuICAgICAgdGh1bWJDb250YWluZXI6ICdwbHlyX19wcmV2aWV3LXRodW1iJyxcbiAgICAgIHRodW1iQ29udGFpbmVyU2hvd246ICdwbHlyX19wcmV2aWV3LXRodW1iLS1pcy1zaG93bicsXG4gICAgICBpbWFnZUNvbnRhaW5lcjogJ3BseXJfX3ByZXZpZXctdGh1bWJfX2ltYWdlLWNvbnRhaW5lcicsXG4gICAgICB0aW1lQ29udGFpbmVyOiAncGx5cl9fcHJldmlldy10aHVtYl9fdGltZS1jb250YWluZXInLFxuICAgICAgLy8gU2NydWJiaW5nXG4gICAgICBzY3J1YmJpbmdDb250YWluZXI6ICdwbHlyX19wcmV2aWV3LXNjcnViYmluZycsXG4gICAgICBzY3J1YmJpbmdDb250YWluZXJTaG93bjogJ3BseXJfX3ByZXZpZXctc2NydWJiaW5nLS1pcy1zaG93bidcbiAgICB9XG4gIH0sXG4gIC8vIEVtYmVkIGF0dHJpYnV0ZXNcbiAgYXR0cmlidXRlczoge1xuICAgIGVtYmVkOiB7XG4gICAgICBwcm92aWRlcjogJ2RhdGEtcGx5ci1wcm92aWRlcicsXG4gICAgICBpZDogJ2RhdGEtcGx5ci1lbWJlZC1pZCcsXG4gICAgICBoYXNoOiAnZGF0YS1wbHlyLWVtYmVkLWhhc2gnXG4gICAgfVxuICB9LFxuICAvLyBBZHZlcnRpc2VtZW50cyBwbHVnaW5cbiAgLy8gUmVnaXN0ZXIgZm9yIGFuIGFjY291bnQgaGVyZTogaHR0cDovL3ZpLmFpL3B1Ymxpc2hlci12aWRlby1tb25ldGl6YXRpb24vP2FpZD1wbHlyaW9cbiAgYWRzOiB7XG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgcHVibGlzaGVySWQ6ICcnLFxuICAgIHRhZ1VybDogJydcbiAgfSxcbiAgLy8gUHJldmlldyBUaHVtYm5haWxzIHBsdWdpblxuICBwcmV2aWV3VGh1bWJuYWlsczoge1xuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIHNyYzogJycsXG4gICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZVxuICB9LFxuICAvLyBWaW1lbyBwbHVnaW5cbiAgdmltZW86IHtcbiAgICBieWxpbmU6IGZhbHNlLFxuICAgIHBvcnRyYWl0OiBmYWxzZSxcbiAgICB0aXRsZTogZmFsc2UsXG4gICAgc3BlZWQ6IHRydWUsXG4gICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxuICAgIC8vIEN1c3RvbSBzZXR0aW5ncyBmcm9tIFBseXJcbiAgICBjdXN0b21Db250cm9sczogdHJ1ZSxcbiAgICByZWZlcnJlclBvbGljeTogbnVsbCxcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTElGcmFtZUVsZW1lbnQvcmVmZXJyZXJQb2xpY3lcbiAgICAvLyBXaGV0aGVyIHRoZSBvd25lciBvZiB0aGUgdmlkZW8gaGFzIGEgUHJvIG9yIEJ1c2luZXNzIGFjY291bnRcbiAgICAvLyAod2hpY2ggYWxsb3dzIHVzIHRvIHByb3Blcmx5IGhpZGUgY29udHJvbHMgd2l0aG91dCBDU1MgaGFja3MsIGV0YylcbiAgICBwcmVtaXVtOiBmYWxzZVxuICB9LFxuICAvLyBZb3VUdWJlIHBsdWdpblxuICB5b3V0dWJlOiB7XG4gICAgcmVsOiAwLFxuICAgIC8vIE5vIHJlbGF0ZWQgdmlkc1xuICAgIHNob3dpbmZvOiAwLFxuICAgIC8vIEhpZGUgaW5mb1xuICAgIGl2X2xvYWRfcG9saWN5OiAzLFxuICAgIC8vIEhpZGUgYW5ub3RhdGlvbnNcbiAgICBtb2Rlc3RicmFuZGluZzogMSxcbiAgICAvLyBIaWRlIGxvZ29zIGFzIG11Y2ggYXMgcG9zc2libGUgKHRoZXkgc3RpbGwgc2hvdyBvbmUgaW4gdGhlIGNvcm5lciB3aGVuIHBhdXNlZClcbiAgICAvLyBDdXN0b20gc2V0dGluZ3MgZnJvbSBQbHlyXG4gICAgY3VzdG9tQ29udHJvbHM6IHRydWUsXG4gICAgbm9Db29raWU6IGZhbHNlIC8vIFdoZXRoZXIgdG8gdXNlIGFuIGFsdGVybmF0aXZlIHZlcnNpb24gb2YgWW91VHViZSB3aXRob3V0IGNvb2tpZXNcbiAgfSxcbiAgLy8gTWVkaWEgTWV0YWRhdGFcbiAgbWVkaWFNZXRhZGF0YToge1xuICAgIHRpdGxlOiAnJyxcbiAgICBhcnRpc3Q6ICcnLFxuICAgIGFsYnVtOiAnJyxcbiAgICBhcnR3b3JrOiBbXVxuICB9LFxuICAvLyBNYXJrZXJzXG4gIG1hcmtlcnM6IHtcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICBwb2ludHM6IFtdXG4gIH1cbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBQbHlyIHN0YXRlc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgcGlwID0ge1xuICBhY3RpdmU6ICdwaWN0dXJlLWluLXBpY3R1cmUnLFxuICBpbmFjdGl2ZTogJ2lubGluZSdcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBQbHlyIHN1cHBvcnRlZCB0eXBlcyBhbmQgcHJvdmlkZXJzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBwcm92aWRlcnMgPSB7XG4gIGh0bWw1OiAnaHRtbDUnLFxuICB5b3V0dWJlOiAneW91dHViZScsXG4gIHZpbWVvOiAndmltZW8nXG59O1xuY29uc3QgdHlwZXMgPSB7XG4gIGF1ZGlvOiAnYXVkaW8nLFxuICB2aWRlbzogJ3ZpZGVvJ1xufTtcblxuLyoqXG4gKiBHZXQgcHJvdmlkZXIgYnkgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKi9cbmZ1bmN0aW9uIGdldFByb3ZpZGVyQnlVcmwodXJsKSB7XG4gIC8vIFlvdVR1YmVcbiAgaWYgKC9eKD86aHR0cHM/OlxcL1xcLyk/KD86d3d3XFwuKT8oPzp5b3V0dWJlXFwuY29tfHlvdXR1YmUtbm9jb29raWVcXC5jb218eW91dHVcXC4/YmUpXFwvLiskLy50ZXN0KHVybCkpIHtcbiAgICByZXR1cm4gcHJvdmlkZXJzLnlvdXR1YmU7XG4gIH1cblxuICAvLyBWaW1lb1xuICBpZiAoL15odHRwcz86XFwvXFwvcGxheWVyLnZpbWVvLmNvbVxcL3ZpZGVvXFwvXFxkezAsOX0oPz1cXGJ8XFwvKS8udGVzdCh1cmwpKSB7XG4gICAgcmV0dXJuIHByb3ZpZGVycy52aW1lbztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIENvbnNvbGUgd3JhcHBlclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5jbGFzcyBDb25zb2xlIHtcbiAgY29uc3RydWN0b3IoZW5hYmxlZCA9IGZhbHNlKSB7XG4gICAgdGhpcy5lbmFibGVkID0gd2luZG93LmNvbnNvbGUgJiYgZW5hYmxlZDtcbiAgICBpZiAodGhpcy5lbmFibGVkKSB7XG4gICAgICB0aGlzLmxvZygnRGVidWdnaW5nIGVuYWJsZWQnKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGxvZygpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIHJldHVybiB0aGlzLmVuYWJsZWQgPyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlKSA6IG5vb3A7XG4gIH1cbiAgZ2V0IHdhcm4oKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5hYmxlZCA/IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwoY29uc29sZS53YXJuLCBjb25zb2xlKSA6IG5vb3A7XG4gIH1cbiAgZ2V0IGVycm9yKCkge1xuICAgIHJldHVybiB0aGlzLmVuYWJsZWQgPyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKGNvbnNvbGUuZXJyb3IsIGNvbnNvbGUpIDogbm9vcDtcbiAgfVxufVxuXG5jbGFzcyBGdWxsc2NyZWVuIHtcbiAgY29uc3RydWN0b3IocGxheWVyKSB7XG4gICAgX2RlZmluZVByb3BlcnR5JDEodGhpcywgXCJvbkNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuc3VwcG9ydGVkKSByZXR1cm47XG5cbiAgICAgIC8vIFVwZGF0ZSB0b2dnbGUgYnV0dG9uXG4gICAgICBjb25zdCBidXR0b24gPSB0aGlzLnBsYXllci5lbGVtZW50cy5idXR0b25zLmZ1bGxzY3JlZW47XG4gICAgICBpZiAoaXMuZWxlbWVudChidXR0b24pKSB7XG4gICAgICAgIGJ1dHRvbi5wcmVzc2VkID0gdGhpcy5hY3RpdmU7XG4gICAgICB9XG5cbiAgICAgIC8vIEFsd2F5cyB0cmlnZ2VyIGV2ZW50cyBvbiB0aGUgcGx5ciAvIG1lZGlhIGVsZW1lbnQgKG5vdCBhIGZ1bGxzY3JlZW4gY29udGFpbmVyKSBhbmQgbGV0IHRoZW0gYnViYmxlIHVwXG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldCA9PT0gdGhpcy5wbGF5ZXIubWVkaWEgPyB0aGlzLnRhcmdldCA6IHRoaXMucGxheWVyLmVsZW1lbnRzLmNvbnRhaW5lcjtcbiAgICAgIC8vIFRyaWdnZXIgYW4gZXZlbnRcbiAgICAgIHRyaWdnZXJFdmVudC5jYWxsKHRoaXMucGxheWVyLCB0YXJnZXQsIHRoaXMuYWN0aXZlID8gJ2VudGVyZnVsbHNjcmVlbicgOiAnZXhpdGZ1bGxzY3JlZW4nLCB0cnVlKTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkkMSh0aGlzLCBcInRvZ2dsZUZhbGxiYWNrXCIsICh0b2dnbGUgPSBmYWxzZSkgPT4ge1xuICAgICAgLy8gU3RvcmUgb3IgcmVzdG9yZSBzY3JvbGwgcG9zaXRpb25cbiAgICAgIGlmICh0b2dnbGUpIHtcbiAgICAgICAgdmFyIF93aW5kb3ckc2Nyb2xsWCwgX3dpbmRvdyRzY3JvbGxZO1xuICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IChfd2luZG93JHNjcm9sbFggPSB3aW5kb3cuc2Nyb2xsWCkgIT09IG51bGwgJiYgX3dpbmRvdyRzY3JvbGxYICE9PSB2b2lkIDAgPyBfd2luZG93JHNjcm9sbFggOiAwLFxuICAgICAgICAgIHk6IChfd2luZG93JHNjcm9sbFkgPSB3aW5kb3cuc2Nyb2xsWSkgIT09IG51bGwgJiYgX3dpbmRvdyRzY3JvbGxZICE9PSB2b2lkIDAgPyBfd2luZG93JHNjcm9sbFkgOiAwXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8odGhpcy5zY3JvbGxQb3NpdGlvbi54LCB0aGlzLnNjcm9sbFBvc2l0aW9uLnkpO1xuICAgICAgfVxuXG4gICAgICAvLyBUb2dnbGUgc2Nyb2xsXG4gICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gdG9nZ2xlID8gJ2hpZGRlbicgOiAnJztcblxuICAgICAgLy8gVG9nZ2xlIGNsYXNzIGhvb2tcbiAgICAgIHRvZ2dsZUNsYXNzKHRoaXMudGFyZ2V0LCB0aGlzLnBsYXllci5jb25maWcuY2xhc3NOYW1lcy5mdWxsc2NyZWVuLmZhbGxiYWNrLCB0b2dnbGUpO1xuXG4gICAgICAvLyBGb3JjZSBmdWxsIHZpZXdwb3J0IG9uIGlQaG9uZSBYK1xuICAgICAgaWYgKGJyb3dzZXIuaXNJb3MpIHtcbiAgICAgICAgbGV0IHZpZXdwb3J0ID0gZG9jdW1lbnQuaGVhZC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9XCJ2aWV3cG9ydFwiXScpO1xuICAgICAgICBjb25zdCBwcm9wZXJ0eSA9ICd2aWV3cG9ydC1maXQ9Y292ZXInO1xuXG4gICAgICAgIC8vIEluamVjdCB0aGUgdmlld3BvcnQgbWV0YSBpZiByZXF1aXJlZFxuICAgICAgICBpZiAoIXZpZXdwb3J0KSB7XG4gICAgICAgICAgdmlld3BvcnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdtZXRhJyk7XG4gICAgICAgICAgdmlld3BvcnQuc2V0QXR0cmlidXRlKCduYW1lJywgJ3ZpZXdwb3J0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgcHJvcGVydHkgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgY29uc3QgaGFzUHJvcGVydHkgPSBpcy5zdHJpbmcodmlld3BvcnQuY29udGVudCkgJiYgdmlld3BvcnQuY29udGVudC5pbmNsdWRlcyhwcm9wZXJ0eSk7XG4gICAgICAgIGlmICh0b2dnbGUpIHtcbiAgICAgICAgICB0aGlzLmNsZWFudXBWaWV3cG9ydCA9ICFoYXNQcm9wZXJ0eTtcbiAgICAgICAgICBpZiAoIWhhc1Byb3BlcnR5KSB2aWV3cG9ydC5jb250ZW50ICs9IGAsJHtwcm9wZXJ0eX1gO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2xlYW51cFZpZXdwb3J0KSB7XG4gICAgICAgICAgdmlld3BvcnQuY29udGVudCA9IHZpZXdwb3J0LmNvbnRlbnQuc3BsaXQoJywnKS5maWx0ZXIocGFydCA9PiBwYXJ0LnRyaW0oKSAhPT0gcHJvcGVydHkpLmpvaW4oJywnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUb2dnbGUgYnV0dG9uIGFuZCBmaXJlIGV2ZW50c1xuICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgIH0pO1xuICAgIC8vIFRyYXAgZm9jdXMgaW5zaWRlIGNvbnRhaW5lclxuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwidHJhcEZvY3VzXCIsIGV2ZW50ID0+IHtcbiAgICAgIC8vIEJhaWwgaWYgaU9TL2lQYWRPUywgbm90IGFjdGl2ZSwgbm90IHRoZSB0YWIga2V5XG4gICAgICBpZiAoYnJvd3Nlci5pc0lvcyB8fCBicm93c2VyLmlzSVBhZE9TIHx8ICF0aGlzLmFjdGl2ZSB8fCBldmVudC5rZXkgIT09ICdUYWInKSByZXR1cm47XG5cbiAgICAgIC8vIEdldCB0aGUgY3VycmVudCBmb2N1c2VkIGVsZW1lbnRcbiAgICAgIGNvbnN0IGZvY3VzZWQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgY29uc3QgZm9jdXNhYmxlID0gZ2V0RWxlbWVudHMuY2FsbCh0aGlzLnBsYXllciwgJ2FbaHJlZl0sIGJ1dHRvbjpub3QoOmRpc2FibGVkKSwgaW5wdXQ6bm90KDpkaXNhYmxlZCksIFt0YWJpbmRleF0nKTtcbiAgICAgIGNvbnN0IFtmaXJzdF0gPSBmb2N1c2FibGU7XG4gICAgICBjb25zdCBsYXN0ID0gZm9jdXNhYmxlW2ZvY3VzYWJsZS5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChmb2N1c2VkID09PSBsYXN0ICYmICFldmVudC5zaGlmdEtleSkge1xuICAgICAgICAvLyBNb3ZlIGZvY3VzIHRvIGZpcnN0IGVsZW1lbnQgdGhhdCBjYW4gYmUgdGFiYmVkIGlmIFNoaWZ0IGlzbid0IHVzZWRcbiAgICAgICAgZmlyc3QuZm9jdXMoKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0gZWxzZSBpZiAoZm9jdXNlZCA9PT0gZmlyc3QgJiYgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgLy8gTW92ZSBmb2N1cyB0byBsYXN0IGVsZW1lbnQgdGhhdCBjYW4gYmUgdGFiYmVkIGlmIFNoaWZ0IGlzIHVzZWRcbiAgICAgICAgbGFzdC5mb2N1cygpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIFVwZGF0ZSBVSVxuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwidXBkYXRlXCIsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN1cHBvcnRlZCkge1xuICAgICAgICBsZXQgbW9kZTtcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VGYWxsYmFjaykgbW9kZSA9ICdGYWxsYmFjayAoZm9yY2VkKSc7ZWxzZSBpZiAoRnVsbHNjcmVlbi5uYXRpdmVTdXBwb3J0ZWQpIG1vZGUgPSAnTmF0aXZlJztlbHNlIG1vZGUgPSAnRmFsbGJhY2snO1xuICAgICAgICB0aGlzLnBsYXllci5kZWJ1Zy5sb2coYCR7bW9kZX0gZnVsbHNjcmVlbiBlbmFibGVkYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBsYXllci5kZWJ1Zy5sb2coJ0Z1bGxzY3JlZW4gbm90IHN1cHBvcnRlZCBhbmQgZmFsbGJhY2sgZGlzYWJsZWQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIHN0eWxpbmcgaG9vayB0byBzaG93IGJ1dHRvblxuICAgICAgdG9nZ2xlQ2xhc3ModGhpcy5wbGF5ZXIuZWxlbWVudHMuY29udGFpbmVyLCB0aGlzLnBsYXllci5jb25maWcuY2xhc3NOYW1lcy5mdWxsc2NyZWVuLmVuYWJsZWQsIHRoaXMuc3VwcG9ydGVkKTtcbiAgICB9KTtcbiAgICAvLyBNYWtlIGFuIGVsZW1lbnQgZnVsbHNjcmVlblxuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwiZW50ZXJcIiwgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnN1cHBvcnRlZCkgcmV0dXJuO1xuXG4gICAgICAvLyBpT1MgbmF0aXZlIGZ1bGxzY3JlZW4gZG9lc24ndCBuZWVkIHRoZSByZXF1ZXN0IHN0ZXBcbiAgICAgIGlmIChicm93c2VyLmlzSW9zICYmIHRoaXMucGxheWVyLmNvbmZpZy5mdWxsc2NyZWVuLmlvc05hdGl2ZSkge1xuICAgICAgICBpZiAodGhpcy5wbGF5ZXIuaXNWaW1lbykge1xuICAgICAgICAgIHRoaXMucGxheWVyLmVtYmVkLnJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50YXJnZXQud2Via2l0RW50ZXJGdWxsc2NyZWVuKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIUZ1bGxzY3JlZW4ubmF0aXZlU3VwcG9ydGVkIHx8IHRoaXMuZm9yY2VGYWxsYmFjaykge1xuICAgICAgICB0aGlzLnRvZ2dsZUZhbGxiYWNrKHRydWUpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5wcmVmaXgpIHtcbiAgICAgICAgdGhpcy50YXJnZXQucmVxdWVzdEZ1bGxzY3JlZW4oe1xuICAgICAgICAgIG5hdmlnYXRpb25VSTogJ2hpZGUnXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICghaXMuZW1wdHkodGhpcy5wcmVmaXgpKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0W2Ake3RoaXMucHJlZml4fVJlcXVlc3Qke3RoaXMucHJvcGVydHl9YF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBCYWlsIGZyb20gZnVsbHNjcmVlblxuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwiZXhpdFwiLCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuc3VwcG9ydGVkKSByZXR1cm47XG5cbiAgICAgIC8vIGlPUyBuYXRpdmUgZnVsbHNjcmVlblxuICAgICAgaWYgKGJyb3dzZXIuaXNJb3MgJiYgdGhpcy5wbGF5ZXIuY29uZmlnLmZ1bGxzY3JlZW4uaW9zTmF0aXZlKSB7XG4gICAgICAgIGlmICh0aGlzLnBsYXllci5pc1ZpbWVvKSB7XG4gICAgICAgICAgdGhpcy5wbGF5ZXIuZW1iZWQuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRhcmdldC53ZWJraXRFbnRlckZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBzaWxlbmNlUHJvbWlzZSh0aGlzLnBsYXllci5wbGF5KCkpO1xuICAgICAgfSBlbHNlIGlmICghRnVsbHNjcmVlbi5uYXRpdmVTdXBwb3J0ZWQgfHwgdGhpcy5mb3JjZUZhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlRmFsbGJhY2soZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5wcmVmaXgpIHtcbiAgICAgICAgKGRvY3VtZW50LmNhbmNlbEZ1bGxTY3JlZW4gfHwgZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4pLmNhbGwoZG9jdW1lbnQpO1xuICAgICAgfSBlbHNlIGlmICghaXMuZW1wdHkodGhpcy5wcmVmaXgpKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMucHJlZml4ID09PSAnbW96JyA/ICdDYW5jZWwnIDogJ0V4aXQnO1xuICAgICAgICBkb2N1bWVudFtgJHt0aGlzLnByZWZpeH0ke2FjdGlvbn0ke3RoaXMucHJvcGVydHl9YF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBUb2dnbGUgc3RhdGVcbiAgICBfZGVmaW5lUHJvcGVydHkkMSh0aGlzLCBcInRvZ2dsZVwiLCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuYWN0aXZlKSB0aGlzLmVudGVyKCk7ZWxzZSB0aGlzLmV4aXQoKTtcbiAgICB9KTtcbiAgICAvLyBLZWVwIHJlZmVyZW5jZSB0byBwYXJlbnRcbiAgICB0aGlzLnBsYXllciA9IHBsYXllcjtcblxuICAgIC8vIEdldCBwcmVmaXhcbiAgICB0aGlzLnByZWZpeCA9IEZ1bGxzY3JlZW4ucHJlZml4O1xuICAgIHRoaXMucHJvcGVydHkgPSBGdWxsc2NyZWVuLnByb3BlcnR5O1xuXG4gICAgLy8gU2Nyb2xsIHBvc2l0aW9uXG4gICAgdGhpcy5zY3JvbGxQb3NpdGlvbiA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcblxuICAgIC8vIEZvcmNlIHRoZSB1c2Ugb2YgJ2Z1bGwgd2luZG93L2Jyb3dzZXInIHJhdGhlciB0aGFuIGZ1bGxzY3JlZW5cbiAgICB0aGlzLmZvcmNlRmFsbGJhY2sgPSBwbGF5ZXIuY29uZmlnLmZ1bGxzY3JlZW4uZmFsbGJhY2sgPT09ICdmb3JjZSc7XG5cbiAgICAvLyBHZXQgdGhlIGZ1bGxzY3JlZW4gZWxlbWVudFxuICAgIC8vIENoZWNrcyBjb250YWluZXIgaXMgYW4gYW5jZXN0b3IsIGRlZmF1bHRzIHRvIG51bGxcbiAgICB0aGlzLnBsYXllci5lbGVtZW50cy5mdWxsc2NyZWVuID0gcGxheWVyLmNvbmZpZy5mdWxsc2NyZWVuLmNvbnRhaW5lciAmJiBjbG9zZXN0JDEodGhpcy5wbGF5ZXIuZWxlbWVudHMuY29udGFpbmVyLCBwbGF5ZXIuY29uZmlnLmZ1bGxzY3JlZW4uY29udGFpbmVyKTtcblxuICAgIC8vIFJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVyc1xuICAgIC8vIEhhbmRsZSBldmVudCAoaW5jYXNlIHVzZXIgcHJlc3NlcyBlc2NhcGUgZXRjKVxuICAgIG9uLmNhbGwodGhpcy5wbGF5ZXIsIGRvY3VtZW50LCB0aGlzLnByZWZpeCA9PT0gJ21zJyA/ICdNU0Z1bGxzY3JlZW5DaGFuZ2UnIDogYCR7dGhpcy5wcmVmaXh9ZnVsbHNjcmVlbmNoYW5nZWAsICgpID0+IHtcbiAgICAgIC8vIFRPRE86IEZpbHRlciBmb3IgdGFyZ2V0Pz9cbiAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICB9KTtcblxuICAgIC8vIEZ1bGxzY3JlZW4gdG9nZ2xlIG9uIGRvdWJsZSBjbGlja1xuICAgIG9uLmNhbGwodGhpcy5wbGF5ZXIsIHRoaXMucGxheWVyLmVsZW1lbnRzLmNvbnRhaW5lciwgJ2RibGNsaWNrJywgZXZlbnQgPT4ge1xuICAgICAgLy8gSWdub3JlIGRvdWJsZSBjbGljayBpbiBjb250cm9sc1xuICAgICAgaWYgKGlzLmVsZW1lbnQodGhpcy5wbGF5ZXIuZWxlbWVudHMuY29udHJvbHMpICYmIHRoaXMucGxheWVyLmVsZW1lbnRzLmNvbnRyb2xzLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5wbGF5ZXIubGlzdGVuZXJzLnByb3h5KGV2ZW50LCB0aGlzLnRvZ2dsZSwgJ2Z1bGxzY3JlZW4nKTtcbiAgICB9KTtcblxuICAgIC8vIFRhcCBmb2N1cyB3aGVuIGluIGZ1bGxzY3JlZW5cbiAgICBvbi5jYWxsKHRoaXMsIHRoaXMucGxheWVyLmVsZW1lbnRzLmNvbnRhaW5lciwgJ2tleWRvd24nLCBldmVudCA9PiB0aGlzLnRyYXBGb2N1cyhldmVudCkpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBVSVxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICAvLyBEZXRlcm1pbmUgaWYgbmF0aXZlIHN1cHBvcnRlZFxuICBzdGF0aWMgZ2V0IG5hdGl2ZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gISEoZG9jdW1lbnQuZnVsbHNjcmVlbkVuYWJsZWQgfHwgZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVuYWJsZWQgfHwgZG9jdW1lbnQubW96RnVsbFNjcmVlbkVuYWJsZWQgfHwgZG9jdW1lbnQubXNGdWxsc2NyZWVuRW5hYmxlZCk7XG4gIH1cblxuICAvLyBJZiB3ZSdyZSBhY3R1YWxseSB1c2luZyBuYXRpdmVcbiAgZ2V0IHVzZU5hdGl2ZSgpIHtcbiAgICByZXR1cm4gRnVsbHNjcmVlbi5uYXRpdmVTdXBwb3J0ZWQgJiYgIXRoaXMuZm9yY2VGYWxsYmFjaztcbiAgfVxuXG4gIC8vIEdldCB0aGUgcHJlZml4IGZvciBoYW5kbGVyc1xuICBzdGF0aWMgZ2V0IHByZWZpeCgpIHtcbiAgICAvLyBObyBwcmVmaXhcbiAgICBpZiAoaXMuZnVuY3Rpb24oZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4pKSByZXR1cm4gJyc7XG5cbiAgICAvLyBDaGVjayBmb3IgZnVsbHNjcmVlbiBzdXBwb3J0IGJ5IHZlbmRvciBwcmVmaXhcbiAgICBsZXQgdmFsdWUgPSAnJztcbiAgICBjb25zdCBwcmVmaXhlcyA9IFsnd2Via2l0JywgJ21veicsICdtcyddO1xuICAgIHByZWZpeGVzLnNvbWUocHJlID0+IHtcbiAgICAgIGlmIChpcy5mdW5jdGlvbihkb2N1bWVudFtgJHtwcmV9RXhpdEZ1bGxzY3JlZW5gXSkgfHwgaXMuZnVuY3Rpb24oZG9jdW1lbnRbYCR7cHJlfUNhbmNlbEZ1bGxTY3JlZW5gXSkpIHtcbiAgICAgICAgdmFsdWUgPSBwcmU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBzdGF0aWMgZ2V0IHByb3BlcnR5KCkge1xuICAgIHJldHVybiB0aGlzLnByZWZpeCA9PT0gJ21veicgPyAnRnVsbFNjcmVlbicgOiAnRnVsbHNjcmVlbic7XG4gIH1cblxuICAvLyBEZXRlcm1pbmUgaWYgZnVsbHNjcmVlbiBpcyBzdXBwb3J0ZWRcbiAgZ2V0IHN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gW1xuICAgIC8vIEZ1bGxzY3JlZW4gaXMgZW5hYmxlZCBpbiBjb25maWdcbiAgICB0aGlzLnBsYXllci5jb25maWcuZnVsbHNjcmVlbi5lbmFibGVkLFxuICAgIC8vIE11c3QgYmUgYSB2aWRlb1xuICAgIHRoaXMucGxheWVyLmlzVmlkZW8sXG4gICAgLy8gRWl0aGVyIG5hdGl2ZSBpcyBzdXBwb3J0ZWQgb3IgZmFsbGJhY2sgZW5hYmxlZFxuICAgIEZ1bGxzY3JlZW4ubmF0aXZlU3VwcG9ydGVkIHx8IHRoaXMucGxheWVyLmNvbmZpZy5mdWxsc2NyZWVuLmZhbGxiYWNrLFxuICAgIC8vIFlvdVR1YmUgaGFzIG5vIHdheSB0byB0cmlnZ2VyIGZ1bGxzY3JlZW4sIHNvIG9uIGRldmljZXMgd2l0aCBubyBuYXRpdmUgc3VwcG9ydCwgcGxheXNpbmxpbmVcbiAgICAvLyBtdXN0IGJlIGVuYWJsZWQgYW5kIGlvc05hdGl2ZSBmdWxsc2NyZWVuIG11c3QgYmUgZGlzYWJsZWQgdG8gb2ZmZXIgdGhlIGZ1bGxzY3JlZW4gZmFsbGJhY2tcbiAgICAhdGhpcy5wbGF5ZXIuaXNZb3VUdWJlIHx8IEZ1bGxzY3JlZW4ubmF0aXZlU3VwcG9ydGVkIHx8ICFicm93c2VyLmlzSW9zIHx8IHRoaXMucGxheWVyLmNvbmZpZy5wbGF5c2lubGluZSAmJiAhdGhpcy5wbGF5ZXIuY29uZmlnLmZ1bGxzY3JlZW4uaW9zTmF0aXZlXS5ldmVyeShCb29sZWFuKTtcbiAgfVxuXG4gIC8vIEdldCBhY3RpdmUgc3RhdGVcbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICBpZiAoIXRoaXMuc3VwcG9ydGVkKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBGYWxsYmFjayB1c2luZyBjbGFzc25hbWVcbiAgICBpZiAoIUZ1bGxzY3JlZW4ubmF0aXZlU3VwcG9ydGVkIHx8IHRoaXMuZm9yY2VGYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGhhc0NsYXNzKHRoaXMudGFyZ2V0LCB0aGlzLnBsYXllci5jb25maWcuY2xhc3NOYW1lcy5mdWxsc2NyZWVuLmZhbGxiYWNrKTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudCA9ICF0aGlzLnByZWZpeCA/IHRoaXMudGFyZ2V0LmdldFJvb3ROb2RlKCkuZnVsbHNjcmVlbkVsZW1lbnQgOiB0aGlzLnRhcmdldC5nZXRSb290Tm9kZSgpW2Ake3RoaXMucHJlZml4fSR7dGhpcy5wcm9wZXJ0eX1FbGVtZW50YF07XG4gICAgcmV0dXJuIGVsZW1lbnQgJiYgZWxlbWVudC5zaGFkb3dSb290ID8gZWxlbWVudCA9PT0gdGhpcy50YXJnZXQuZ2V0Um9vdE5vZGUoKS5ob3N0IDogZWxlbWVudCA9PT0gdGhpcy50YXJnZXQ7XG4gIH1cblxuICAvLyBHZXQgdGFyZ2V0IGVsZW1lbnRcbiAgZ2V0IHRhcmdldCgpIHtcbiAgICB2YXIgX3RoaXMkcGxheWVyJGVsZW1lbnRzO1xuICAgIHJldHVybiBicm93c2VyLmlzSW9zICYmIHRoaXMucGxheWVyLmNvbmZpZy5mdWxsc2NyZWVuLmlvc05hdGl2ZSA/IHRoaXMucGxheWVyLm1lZGlhIDogKF90aGlzJHBsYXllciRlbGVtZW50cyA9IHRoaXMucGxheWVyLmVsZW1lbnRzLmZ1bGxzY3JlZW4pICE9PSBudWxsICYmIF90aGlzJHBsYXllciRlbGVtZW50cyAhPT0gdm9pZCAwID8gX3RoaXMkcGxheWVyJGVsZW1lbnRzIDogdGhpcy5wbGF5ZXIuZWxlbWVudHMuY29udGFpbmVyO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBMb2FkIGltYWdlIGF2b2lkaW5nIHhoci9mZXRjaCBDT1JTIGlzc3Vlc1xuLy8gU2VydmVyIHN0YXR1cyBjYW4ndCBiZSBvYnRhaW5lZCB0aGlzIHdheSB1bmZvcnR1bmF0ZWx5LCBzbyB0aGlzIHVzZXMgXCJuYXR1cmFsV2lkdGhcIiB0byBkZXRlcm1pbmUgaWYgdGhlIGltYWdlIGhhcyBsb2FkZWRcbi8vIEJ5IGRlZmF1bHQgaXQgY2hlY2tzIGlmIGl0IGlzIGF0IGxlYXN0IDFweCwgYnV0IHlvdSBjYW4gYWRkIGEgc2Vjb25kIGFyZ3VtZW50IHRvIGNoYW5nZSB0aGlzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBsb2FkSW1hZ2Uoc3JjLCBtaW5XaWR0aCA9IDEpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIGNvbnN0IGhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBkZWxldGUgaW1hZ2Uub25sb2FkO1xuICAgICAgZGVsZXRlIGltYWdlLm9uZXJyb3I7XG4gICAgICAoaW1hZ2UubmF0dXJhbFdpZHRoID49IG1pbldpZHRoID8gcmVzb2x2ZSA6IHJlamVjdCkoaW1hZ2UpO1xuICAgIH07XG4gICAgT2JqZWN0LmFzc2lnbihpbWFnZSwge1xuICAgICAgb25sb2FkOiBoYW5kbGVyLFxuICAgICAgb25lcnJvcjogaGFuZGxlcixcbiAgICAgIHNyY1xuICAgIH0pO1xuICB9KTtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFBseXIgVUlcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmNvbnN0IHVpID0ge1xuICBhZGRTdHlsZUhvb2soKSB7XG4gICAgdG9nZ2xlQ2xhc3ModGhpcy5lbGVtZW50cy5jb250YWluZXIsIHRoaXMuY29uZmlnLnNlbGVjdG9ycy5jb250YWluZXIucmVwbGFjZSgnLicsICcnKSwgdHJ1ZSk7XG4gICAgdG9nZ2xlQ2xhc3ModGhpcy5lbGVtZW50cy5jb250YWluZXIsIHRoaXMuY29uZmlnLmNsYXNzTmFtZXMudWlTdXBwb3J0ZWQsIHRoaXMuc3VwcG9ydGVkLnVpKTtcbiAgfSxcbiAgLy8gVG9nZ2xlIG5hdGl2ZSBIVE1MNSBtZWRpYSBjb250cm9sc1xuICB0b2dnbGVOYXRpdmVDb250cm9scyh0b2dnbGUgPSBmYWxzZSkge1xuICAgIGlmICh0b2dnbGUgJiYgdGhpcy5pc0hUTUw1KSB7XG4gICAgICB0aGlzLm1lZGlhLnNldEF0dHJpYnV0ZSgnY29udHJvbHMnLCAnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWVkaWEucmVtb3ZlQXR0cmlidXRlKCdjb250cm9scycpO1xuICAgIH1cbiAgfSxcbiAgLy8gU2V0dXAgdGhlIFVJXG4gIGJ1aWxkKCkge1xuICAgIC8vIFJlLWF0dGFjaCBtZWRpYSBlbGVtZW50IGxpc3RlbmVyc1xuICAgIC8vIFRPRE86IFVzZSBldmVudCBidWJibGluZz9cbiAgICB0aGlzLmxpc3RlbmVycy5tZWRpYSgpO1xuXG4gICAgLy8gRG9uJ3Qgc2V0dXAgaW50ZXJmYWNlIGlmIG5vIHN1cHBvcnRcbiAgICBpZiAoIXRoaXMuc3VwcG9ydGVkLnVpKSB7XG4gICAgICB0aGlzLmRlYnVnLndhcm4oYEJhc2ljIHN1cHBvcnQgb25seSBmb3IgJHt0aGlzLnByb3ZpZGVyfSAke3RoaXMudHlwZX1gKTtcblxuICAgICAgLy8gUmVzdG9yZSBuYXRpdmUgY29udHJvbHNcbiAgICAgIHVpLnRvZ2dsZU5hdGl2ZUNvbnRyb2xzLmNhbGwodGhpcywgdHJ1ZSk7XG5cbiAgICAgIC8vIEJhaWxcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJbmplY3QgY3VzdG9tIGNvbnRyb2xzIGlmIG5vdCBwcmVzZW50XG4gICAgaWYgKCFpcy5lbGVtZW50KHRoaXMuZWxlbWVudHMuY29udHJvbHMpKSB7XG4gICAgICAvLyBJbmplY3QgY3VzdG9tIGNvbnRyb2xzXG4gICAgICBjb250cm9scy5pbmplY3QuY2FsbCh0aGlzKTtcblxuICAgICAgLy8gUmUtYXR0YWNoIGNvbnRyb2wgbGlzdGVuZXJzXG4gICAgICB0aGlzLmxpc3RlbmVycy5jb250cm9scygpO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBuYXRpdmUgY29udHJvbHNcbiAgICB1aS50b2dnbGVOYXRpdmVDb250cm9scy5jYWxsKHRoaXMpO1xuXG4gICAgLy8gU2V0dXAgY2FwdGlvbnMgZm9yIEhUTUw1XG4gICAgaWYgKHRoaXMuaXNIVE1MNSkge1xuICAgICAgY2FwdGlvbnMuc2V0dXAuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCB2b2x1bWVcbiAgICB0aGlzLnZvbHVtZSA9IG51bGw7XG5cbiAgICAvLyBSZXNldCBtdXRlIHN0YXRlXG4gICAgdGhpcy5tdXRlZCA9IG51bGw7XG5cbiAgICAvLyBSZXNldCBsb29wIHN0YXRlXG4gICAgdGhpcy5sb29wID0gbnVsbDtcblxuICAgIC8vIFJlc2V0IHF1YWxpdHkgc2V0dGluZ1xuICAgIHRoaXMucXVhbGl0eSA9IG51bGw7XG5cbiAgICAvLyBSZXNldCBzcGVlZFxuICAgIHRoaXMuc3BlZWQgPSBudWxsO1xuXG4gICAgLy8gUmVzZXQgdm9sdW1lIGRpc3BsYXlcbiAgICBjb250cm9scy51cGRhdGVWb2x1bWUuY2FsbCh0aGlzKTtcblxuICAgIC8vIFJlc2V0IHRpbWUgZGlzcGxheVxuICAgIGNvbnRyb2xzLnRpbWVVcGRhdGUuY2FsbCh0aGlzKTtcblxuICAgIC8vIFJlc2V0IGR1cmF0aW9uIGRpc3BsYXlcbiAgICBjb250cm9scy5kdXJhdGlvblVwZGF0ZS5jYWxsKHRoaXMpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBVSVxuICAgIHVpLmNoZWNrUGxheWluZy5jYWxsKHRoaXMpO1xuXG4gICAgLy8gQ2hlY2sgZm9yIHBpY3R1cmUtaW4tcGljdHVyZSBzdXBwb3J0XG4gICAgdG9nZ2xlQ2xhc3ModGhpcy5lbGVtZW50cy5jb250YWluZXIsIHRoaXMuY29uZmlnLmNsYXNzTmFtZXMucGlwLnN1cHBvcnRlZCwgc3VwcG9ydC5waXAgJiYgdGhpcy5pc0hUTUw1ICYmIHRoaXMuaXNWaWRlbyk7XG5cbiAgICAvLyBDaGVjayBmb3IgYWlycGxheSBzdXBwb3J0XG4gICAgdG9nZ2xlQ2xhc3ModGhpcy5lbGVtZW50cy5jb250YWluZXIsIHRoaXMuY29uZmlnLmNsYXNzTmFtZXMuYWlycGxheS5zdXBwb3J0ZWQsIHN1cHBvcnQuYWlycGxheSAmJiB0aGlzLmlzSFRNTDUpO1xuXG4gICAgLy8gQWRkIHRvdWNoIGNsYXNzXG4gICAgdG9nZ2xlQ2xhc3ModGhpcy5lbGVtZW50cy5jb250YWluZXIsIHRoaXMuY29uZmlnLmNsYXNzTmFtZXMuaXNUb3VjaCwgdGhpcy50b3VjaCk7XG5cbiAgICAvLyBSZWFkeSBmb3IgQVBJIGNhbGxzXG4gICAgdGhpcy5yZWFkeSA9IHRydWU7XG5cbiAgICAvLyBSZWFkeSBldmVudCBhdCBlbmQgb2YgZXhlY3V0aW9uIHN0YWNrXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0cmlnZ2VyRXZlbnQuY2FsbCh0aGlzLCB0aGlzLm1lZGlhLCAncmVhZHknKTtcbiAgICB9LCAwKTtcblxuICAgIC8vIFNldCB0aGUgdGl0bGVcbiAgICB1aS5zZXRUaXRsZS5jYWxsKHRoaXMpO1xuXG4gICAgLy8gQXNzdXJlIHRoZSBwb3N0ZXIgaW1hZ2UgaXMgc2V0LCBpZiB0aGUgcHJvcGVydHkgd2FzIGFkZGVkIGJlZm9yZSB0aGUgZWxlbWVudCB3YXMgY3JlYXRlZFxuICAgIGlmICh0aGlzLnBvc3Rlcikge1xuICAgICAgdWkuc2V0UG9zdGVyLmNhbGwodGhpcywgdGhpcy5wb3N0ZXIsIGZhbHNlKS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgfVxuXG4gICAgLy8gTWFudWFsbHkgc2V0IHRoZSBkdXJhdGlvbiBpZiB1c2VyIGhhcyBvdmVycmlkZGVuIGl0LlxuICAgIC8vIFRoZSBldmVudCBsaXN0ZW5lcnMgZm9yIGl0IGRvZXNuJ3QgZ2V0IGNhbGxlZCBpZiBwcmVsb2FkIGlzIGRpc2FibGVkICgjNzAxKVxuICAgIGlmICh0aGlzLmNvbmZpZy5kdXJhdGlvbikge1xuICAgICAgY29udHJvbHMuZHVyYXRpb25VcGRhdGUuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBNZWRpYSBtZXRhZGF0YVxuICAgIGlmICh0aGlzLmNvbmZpZy5tZWRpYU1ldGFkYXRhKSB7XG4gICAgICBjb250cm9scy5zZXRNZWRpYU1ldGFkYXRhLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LFxuICAvLyBTZXR1cCBhcmlhIGF0dHJpYnV0ZSBmb3IgcGxheSBhbmQgaWZyYW1lIHRpdGxlXG4gIHNldFRpdGxlKCkge1xuICAgIC8vIEZpbmQgdGhlIGN1cnJlbnQgdGV4dFxuICAgIGxldCBsYWJlbCA9IGkxOG4uZ2V0KCdwbGF5JywgdGhpcy5jb25maWcpO1xuXG4gICAgLy8gSWYgdGhlcmUncyBhIG1lZGlhIHRpdGxlIHNldCwgdXNlIHRoYXQgZm9yIHRoZSBsYWJlbFxuICAgIGlmIChpcy5zdHJpbmcodGhpcy5jb25maWcudGl0bGUpICYmICFpcy5lbXB0eSh0aGlzLmNvbmZpZy50aXRsZSkpIHtcbiAgICAgIGxhYmVsICs9IGAsICR7dGhpcy5jb25maWcudGl0bGV9YDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSdzIGEgcGxheSBidXR0b24sIHNldCBsYWJlbFxuICAgIEFycmF5LmZyb20odGhpcy5lbGVtZW50cy5idXR0b25zLnBsYXkgfHwgW10pLmZvckVhY2goYnV0dG9uID0+IHtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBsYWJlbCk7XG4gICAgfSk7XG5cbiAgICAvLyBTZXQgaWZyYW1lIHRpdGxlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NhbXBvdHRzL3BseXIvaXNzdWVzLzEyNFxuICAgIGlmICh0aGlzLmlzRW1iZWQpIHtcbiAgICAgIGNvbnN0IGlmcmFtZSA9IGdldEVsZW1lbnQuY2FsbCh0aGlzLCAnaWZyYW1lJyk7XG4gICAgICBpZiAoIWlzLmVsZW1lbnQoaWZyYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIERlZmF1bHQgdG8gbWVkaWEgdHlwZVxuICAgICAgY29uc3QgdGl0bGUgPSAhaXMuZW1wdHkodGhpcy5jb25maWcudGl0bGUpID8gdGhpcy5jb25maWcudGl0bGUgOiAndmlkZW8nO1xuICAgICAgY29uc3QgZm9ybWF0ID0gaTE4bi5nZXQoJ2ZyYW1lVGl0bGUnLCB0aGlzLmNvbmZpZyk7XG4gICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCd0aXRsZScsIGZvcm1hdC5yZXBsYWNlKCd7dGl0bGV9JywgdGl0bGUpKTtcbiAgICB9XG4gIH0sXG4gIC8vIFRvZ2dsZSBwb3N0ZXJcbiAgdG9nZ2xlUG9zdGVyKGVuYWJsZSkge1xuICAgIHRvZ2dsZUNsYXNzKHRoaXMuZWxlbWVudHMuY29udGFpbmVyLCB0aGlzLmNvbmZpZy5jbGFzc05hbWVzLnBvc3RlckVuYWJsZWQsIGVuYWJsZSk7XG4gIH0sXG4gIC8vIFNldCB0aGUgcG9zdGVyIGltYWdlIChhc3luYylcbiAgLy8gVXNlZCBpbnRlcm5hbGx5IGZvciB0aGUgcG9zdGVyIHNldHRlciwgd2l0aCB0aGUgcGFzc2l2ZSBvcHRpb24gZm9yY2VkIHRvIGZhbHNlXG4gIHNldFBvc3Rlcihwb3N0ZXIsIHBhc3NpdmUgPSB0cnVlKSB7XG4gICAgLy8gRG9uJ3Qgb3ZlcnJpZGUgaWYgY2FsbCBpcyBwYXNzaXZlXG4gICAgaWYgKHBhc3NpdmUgJiYgdGhpcy5wb3N0ZXIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1Bvc3RlciBhbHJlYWR5IHNldCcpKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgcHJvcGVydHkgc3luY2hyb25vdXNseSB0byByZXNwZWN0IHRoZSBjYWxsIG9yZGVyXG4gICAgdGhpcy5tZWRpYS5zZXRBdHRyaWJ1dGUoJ2RhdGEtcG9zdGVyJywgcG9zdGVyKTtcblxuICAgIC8vIFNob3cgdGhlIHBvc3RlclxuICAgIHRoaXMuZWxlbWVudHMucG9zdGVyLnJlbW92ZUF0dHJpYnV0ZSgnaGlkZGVuJyk7XG5cbiAgICAvLyBXYWl0IHVudGlsIHVpIGlzIHJlYWR5XG4gICAgcmV0dXJuIHJlYWR5LmNhbGwodGhpcylcbiAgICAvLyBMb2FkIGltYWdlXG4gICAgLnRoZW4oKCkgPT4gbG9hZEltYWdlKHBvc3RlcikpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIC8vIEhpZGUgcG9zdGVyIG9uIGVycm9yIHVubGVzcyBpdCdzIGJlZW4gc2V0IGJ5IGFub3RoZXIgY2FsbFxuICAgICAgaWYgKHBvc3RlciA9PT0gdGhpcy5wb3N0ZXIpIHtcbiAgICAgICAgdWkudG9nZ2xlUG9zdGVyLmNhbGwodGhpcywgZmFsc2UpO1xuICAgICAgfVxuICAgICAgLy8gUmV0aHJvd1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAvLyBQcmV2ZW50IHJhY2UgY29uZGl0aW9uc1xuICAgICAgaWYgKHBvc3RlciAhPT0gdGhpcy5wb3N0ZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRQb3N0ZXIgY2FuY2VsbGVkIGJ5IGxhdGVyIGNhbGwgdG8gc2V0UG9zdGVyJyk7XG4gICAgICB9XG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMuZWxlbWVudHMucG9zdGVyLnN0eWxlLCB7XG4gICAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybCgnJHtwb3N0ZXJ9JylgLFxuICAgICAgICAvLyBSZXNldCBiYWNrZ3JvdW5kU2l6ZSBhcyB3ZWxsIChzaW5jZSBpdCBjYW4gYmUgc2V0IHRvIFwiY292ZXJcIiBmb3IgcGFkZGVkIHRodW1ibmFpbHMgZm9yIHlvdXR1YmUpXG4gICAgICAgIGJhY2tncm91bmRTaXplOiAnJ1xuICAgICAgfSk7XG4gICAgICB1aS50b2dnbGVQb3N0ZXIuY2FsbCh0aGlzLCB0cnVlKTtcbiAgICAgIHJldHVybiBwb3N0ZXI7XG4gICAgfSk7XG4gIH0sXG4gIC8vIENoZWNrIHBsYXlpbmcgc3RhdGVcbiAgY2hlY2tQbGF5aW5nKGV2ZW50KSB7XG4gICAgLy8gQ2xhc3MgaG9va3NcbiAgICB0b2dnbGVDbGFzcyh0aGlzLmVsZW1lbnRzLmNvbnRhaW5lciwgdGhpcy5jb25maWcuY2xhc3NOYW1lcy5wbGF5aW5nLCB0aGlzLnBsYXlpbmcpO1xuICAgIHRvZ2dsZUNsYXNzKHRoaXMuZWxlbWVudHMuY29udGFpbmVyLCB0aGlzLmNvbmZpZy5jbGFzc05hbWVzLnBhdXNlZCwgdGhpcy5wYXVzZWQpO1xuICAgIHRvZ2dsZUNsYXNzKHRoaXMuZWxlbWVudHMuY29udGFpbmVyLCB0aGlzLmNvbmZpZy5jbGFzc05hbWVzLnN0b3BwZWQsIHRoaXMuc3RvcHBlZCk7XG5cbiAgICAvLyBTZXQgc3RhdGVcbiAgICBBcnJheS5mcm9tKHRoaXMuZWxlbWVudHMuYnV0dG9ucy5wbGF5IHx8IFtdKS5mb3JFYWNoKHRhcmdldCA9PiB7XG4gICAgICBPYmplY3QuYXNzaWduKHRhcmdldCwge1xuICAgICAgICBwcmVzc2VkOiB0aGlzLnBsYXlpbmdcbiAgICAgIH0pO1xuICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGkxOG4uZ2V0KHRoaXMucGxheWluZyA/ICdwYXVzZScgOiAncGxheScsIHRoaXMuY29uZmlnKSk7XG4gICAgfSk7XG5cbiAgICAvLyBPbmx5IHVwZGF0ZSBjb250cm9scyBvbiBub24gdGltZXVwZGF0ZSBldmVudHNcbiAgICBpZiAoaXMuZXZlbnQoZXZlbnQpICYmIGV2ZW50LnR5cGUgPT09ICd0aW1ldXBkYXRlJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRvZ2dsZSBjb250cm9sc1xuICAgIHVpLnRvZ2dsZUNvbnRyb2xzLmNhbGwodGhpcyk7XG4gIH0sXG4gIC8vIENoZWNrIGlmIG1lZGlhIGlzIGxvYWRpbmdcbiAgY2hlY2tMb2FkaW5nKGV2ZW50KSB7XG4gICAgdGhpcy5sb2FkaW5nID0gWydzdGFsbGVkJywgJ3dhaXRpbmcnXS5pbmNsdWRlcyhldmVudC50eXBlKTtcblxuICAgIC8vIENsZWFyIHRpbWVyXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLmxvYWRpbmcpO1xuXG4gICAgLy8gVGltZXIgdG8gcHJldmVudCBmbGlja2VyIHdoZW4gc2Vla2luZ1xuICAgIHRoaXMudGltZXJzLmxvYWRpbmcgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIC8vIFVwZGF0ZSBwcm9ncmVzcyBiYXIgbG9hZGluZyBjbGFzcyBzdGF0ZVxuICAgICAgdG9nZ2xlQ2xhc3ModGhpcy5lbGVtZW50cy5jb250YWluZXIsIHRoaXMuY29uZmlnLmNsYXNzTmFtZXMubG9hZGluZywgdGhpcy5sb2FkaW5nKTtcblxuICAgICAgLy8gVXBkYXRlIGNvbnRyb2xzIHZpc2liaWxpdHlcbiAgICAgIHVpLnRvZ2dsZUNvbnRyb2xzLmNhbGwodGhpcyk7XG4gICAgfSwgdGhpcy5sb2FkaW5nID8gMjUwIDogMCk7XG4gIH0sXG4gIC8vIFRvZ2dsZSBjb250cm9scyBiYXNlZCBvbiBzdGF0ZSBhbmQgYGZvcmNlYCBhcmd1bWVudFxuICB0b2dnbGVDb250cm9scyhmb3JjZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRyb2xzOiBjb250cm9sc0VsZW1lbnRcbiAgICB9ID0gdGhpcy5lbGVtZW50cztcbiAgICBpZiAoY29udHJvbHNFbGVtZW50ICYmIHRoaXMuY29uZmlnLmhpZGVDb250cm9scykge1xuICAgICAgLy8gRG9uJ3QgaGlkZSBjb250cm9scyBpZiBhIHRvdWNoLWRldmljZSB1c2VyIHJlY2VudGx5IHNlZWtlZC4gKE11c3QgYmUgbGltaXRlZCB0byB0b3VjaCBkZXZpY2VzLCBvciBpdCBvY2Nhc2lvbmFsbHkgcHJldmVudHMgZGVza3RvcCBjb250cm9scyBmcm9tIGhpZGluZy4pXG4gICAgICBjb25zdCByZWNlbnRUb3VjaFNlZWsgPSB0aGlzLnRvdWNoICYmIHRoaXMubGFzdFNlZWtUaW1lICsgMjAwMCA+IERhdGUubm93KCk7XG5cbiAgICAgIC8vIFNob3cgY29udHJvbHMgaWYgZm9yY2UsIGxvYWRpbmcsIHBhdXNlZCwgYnV0dG9uIGludGVyYWN0aW9uLCBvciByZWNlbnQgc2Vlaywgb3RoZXJ3aXNlIGhpZGVcbiAgICAgIHRoaXMudG9nZ2xlQ29udHJvbHMoQm9vbGVhbihmb3JjZSB8fCB0aGlzLmxvYWRpbmcgfHwgdGhpcy5wYXVzZWQgfHwgY29udHJvbHNFbGVtZW50LnByZXNzZWQgfHwgY29udHJvbHNFbGVtZW50LmhvdmVyIHx8IHJlY2VudFRvdWNoU2VlaykpO1xuICAgIH1cbiAgfSxcbiAgLy8gTWlncmF0ZSBhbnkgY3VzdG9tIHByb3BlcnRpZXMgZnJvbSB0aGUgbWVkaWEgdG8gdGhlIHBhcmVudFxuICBtaWdyYXRlU3R5bGVzKCkge1xuICAgIC8vIExvb3AgdGhyb3VnaCB2YWx1ZXMgKGFzIHRoZXkgYXJlIHRoZSBrZXlzIHdoZW4gdGhlIG9iamVjdCBpcyBzcHJlYWQg8J+klClcbiAgICBPYmplY3QudmFsdWVzKHtcbiAgICAgIC4uLnRoaXMubWVkaWEuc3R5bGVcbiAgICB9KVxuICAgIC8vIFdlJ3JlIG9ubHkgZnVzc2VkIGFib3V0IFBseXIgc3BlY2lmaWMgcHJvcGVydGllc1xuICAgIC5maWx0ZXIoa2V5ID0+ICFpcy5lbXB0eShrZXkpICYmIGlzLnN0cmluZyhrZXkpICYmIGtleS5zdGFydHNXaXRoKCctLXBseXInKSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgLy8gU2V0IG9uIHRoZSBjb250YWluZXJcbiAgICAgIHRoaXMuZWxlbWVudHMuY29udGFpbmVyLnN0eWxlLnNldFByb3BlcnR5KGtleSwgdGhpcy5tZWRpYS5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKGtleSkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCBmcm9tIG1lZGlhIGVsZW1lbnRcbiAgICAgIHRoaXMubWVkaWEuc3R5bGUucmVtb3ZlUHJvcGVydHkoa2V5KTtcbiAgICB9KTtcblxuICAgIC8vIFJlbW92ZSBhdHRyaWJ1dGUgaWYgZW1wdHlcbiAgICBpZiAoaXMuZW1wdHkodGhpcy5tZWRpYS5zdHlsZSkpIHtcbiAgICAgIHRoaXMubWVkaWEucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgIH1cbiAgfVxufTtcblxuY2xhc3MgTGlzdGVuZXJzIHtcbiAgY29uc3RydWN0b3IoX3BsYXllcikge1xuICAgIC8vIERldmljZSBpcyB0b3VjaCBlbmFibGVkXG4gICAgX2RlZmluZVByb3BlcnR5JDEodGhpcywgXCJmaXJzdFRvdWNoXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGxheWVyXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH0gPSBwbGF5ZXI7XG4gICAgICBwbGF5ZXIudG91Y2ggPSB0cnVlO1xuXG4gICAgICAvLyBBZGQgdG91Y2ggY2xhc3NcbiAgICAgIHRvZ2dsZUNsYXNzKGVsZW1lbnRzLmNvbnRhaW5lciwgcGxheWVyLmNvbmZpZy5jbGFzc05hbWVzLmlzVG91Y2gsIHRydWUpO1xuICAgIH0pO1xuICAgIC8vIEdsb2JhbCB3aW5kb3cgJiBkb2N1bWVudCBsaXN0ZW5lcnNcbiAgICBfZGVmaW5lUHJvcGVydHkkMSh0aGlzLCBcImdsb2JhbFwiLCAodG9nZ2xlID0gdHJ1ZSkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGF5ZXJcbiAgICAgIH0gPSB0aGlzO1xuXG4gICAgICAvLyBLZXlib2FyZCBzaG9ydGN1dHNcbiAgICAgIGlmIChwbGF5ZXIuY29uZmlnLmtleWJvYXJkLmdsb2JhbCkge1xuICAgICAgICB0b2dnbGVMaXN0ZW5lci5jYWxsKHBsYXllciwgd2luZG93LCAna2V5ZG93biBrZXl1cCcsIHRoaXMuaGFuZGxlS2V5LCB0b2dnbGUsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xpY2sgYW55d2hlcmUgY2xvc2VzIG1lbnVcbiAgICAgIHRvZ2dsZUxpc3RlbmVyLmNhbGwocGxheWVyLCBkb2N1bWVudC5ib2R5LCAnY2xpY2snLCB0aGlzLnRvZ2dsZU1lbnUsIHRvZ2dsZSk7XG5cbiAgICAgIC8vIERldGVjdCB0b3VjaCBieSBldmVudHNcbiAgICAgIG9uY2UuY2FsbChwbGF5ZXIsIGRvY3VtZW50LmJvZHksICd0b3VjaHN0YXJ0JywgdGhpcy5maXJzdFRvdWNoKTtcbiAgICB9KTtcbiAgICAvLyBDb250YWluZXIgbGlzdGVuZXJzXG4gICAgX2RlZmluZVByb3BlcnR5JDEodGhpcywgXCJjb250YWluZXJcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGF5ZXJcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb25maWcsXG4gICAgICAgIGVsZW1lbnRzLFxuICAgICAgICB0aW1lcnNcbiAgICAgIH0gPSBwbGF5ZXI7XG5cbiAgICAgIC8vIEtleWJvYXJkIHNob3J0Y3V0c1xuICAgICAgaWYgKCFjb25maWcua2V5Ym9hcmQuZ2xvYmFsICYmIGNvbmZpZy5rZXlib2FyZC5mb2N1c2VkKSB7XG4gICAgICAgIG9uLmNhbGwocGxheWVyLCBlbGVtZW50cy5jb250YWluZXIsICdrZXlkb3duIGtleXVwJywgdGhpcy5oYW5kbGVLZXksIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgLy8gVG9nZ2xlIGNvbnRyb2xzIG9uIG1vdXNlIGV2ZW50cyBhbmQgZW50ZXJpbmcgZnVsbHNjcmVlblxuICAgICAgb24uY2FsbChwbGF5ZXIsIGVsZW1lbnRzLmNvbnRhaW5lciwgJ21vdXNlbW92ZSBtb3VzZWxlYXZlIHRvdWNoc3RhcnQgdG91Y2htb3ZlIGVudGVyZnVsbHNjcmVlbiBleGl0ZnVsbHNjcmVlbicsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNvbnRyb2xzOiBjb250cm9sc0VsZW1lbnRcbiAgICAgICAgfSA9IGVsZW1lbnRzO1xuXG4gICAgICAgIC8vIFJlbW92ZSBidXR0b24gc3RhdGVzIGZvciBmdWxsc2NyZWVuXG4gICAgICAgIGlmIChjb250cm9sc0VsZW1lbnQgJiYgZXZlbnQudHlwZSA9PT0gJ2VudGVyZnVsbHNjcmVlbicpIHtcbiAgICAgICAgICBjb250cm9sc0VsZW1lbnQucHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICAgIGNvbnRyb2xzRWxlbWVudC5ob3ZlciA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hvdywgdGhlbiBoaWRlIGFmdGVyIGEgdGltZW91dCB1bmxlc3MgYW5vdGhlciBjb250cm9sIGV2ZW50IG9jY3Vyc1xuICAgICAgICBjb25zdCBzaG93ID0gWyd0b3VjaHN0YXJ0JywgJ3RvdWNobW92ZScsICdtb3VzZW1vdmUnXS5pbmNsdWRlcyhldmVudC50eXBlKTtcbiAgICAgICAgbGV0IGRlbGF5ID0gMDtcbiAgICAgICAgaWYgKHNob3cpIHtcbiAgICAgICAgICB1aS50b2dnbGVDb250cm9scy5jYWxsKHBsYXllciwgdHJ1ZSk7XG4gICAgICAgICAgLy8gVXNlIGxvbmdlciB0aW1lb3V0IGZvciB0b3VjaCBkZXZpY2VzXG4gICAgICAgICAgZGVsYXkgPSBwbGF5ZXIudG91Y2ggPyAzMDAwIDogMjAwMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENsZWFyIHRpbWVyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcnMuY29udHJvbHMpO1xuXG4gICAgICAgIC8vIFNldCBuZXcgdGltZXIgdG8gcHJldmVudCBmbGlja2VyIHdoZW4gc2Vla2luZ1xuICAgICAgICB0aW1lcnMuY29udHJvbHMgPSBzZXRUaW1lb3V0KCgpID0+IHVpLnRvZ2dsZUNvbnRyb2xzLmNhbGwocGxheWVyLCBmYWxzZSksIGRlbGF5KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTZXQgYSBndXR0ZXIgZm9yIFZpbWVvXG4gICAgICBjb25zdCBzZXRHdXR0ZXIgPSAoKSA9PiB7XG4gICAgICAgIGlmICghcGxheWVyLmlzVmltZW8gfHwgcGxheWVyLmNvbmZpZy52aW1lby5wcmVtaXVtKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGVsZW1lbnRzLndyYXBwZXI7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBhY3RpdmVcbiAgICAgICAgfSA9IHBsYXllci5mdWxsc2NyZWVuO1xuICAgICAgICBjb25zdCBbdmlkZW9XaWR0aCwgdmlkZW9IZWlnaHRdID0gZ2V0QXNwZWN0UmF0aW8uY2FsbChwbGF5ZXIpO1xuICAgICAgICBjb25zdCB1c2VOYXRpdmVBc3BlY3RSYXRpbyA9IHN1cHBvcnRzQ1NTKGBhc3BlY3QtcmF0aW86ICR7dmlkZW9XaWR0aH0gLyAke3ZpZGVvSGVpZ2h0fWApO1xuXG4gICAgICAgIC8vIElmIG5vdCBhY3RpdmUsIHJlbW92ZSBzdHlsZXNcbiAgICAgICAgaWYgKCFhY3RpdmUpIHtcbiAgICAgICAgICBpZiAodXNlTmF0aXZlQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZS53aWR0aCA9IG51bGw7XG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUuaGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLm1heFdpZHRoID0gbnVsbDtcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZS5tYXJnaW4gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggZGltZW5zaW9uIHdpbGwgb3ZlcmZsb3cgYW5kIGNvbnN0cmFpbiB2aWV3XG4gICAgICAgIGNvbnN0IFt2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodF0gPSBnZXRWaWV3cG9ydFNpemUoKTtcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSB2aWV3cG9ydFdpZHRoIC8gdmlld3BvcnRIZWlnaHQgPiB2aWRlb1dpZHRoIC8gdmlkZW9IZWlnaHQ7XG4gICAgICAgIGlmICh1c2VOYXRpdmVBc3BlY3RSYXRpbykge1xuICAgICAgICAgIHRhcmdldC5zdHlsZS53aWR0aCA9IG92ZXJmbG93ID8gJ2F1dG8nIDogJzEwMCUnO1xuICAgICAgICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSBvdmVyZmxvdyA/ICcxMDAlJyA6ICdhdXRvJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXQuc3R5bGUubWF4V2lkdGggPSBvdmVyZmxvdyA/IGAke3ZpZXdwb3J0SGVpZ2h0IC8gdmlkZW9IZWlnaHQgKiB2aWRlb1dpZHRofXB4YCA6IG51bGw7XG4gICAgICAgICAgdGFyZ2V0LnN0eWxlLm1hcmdpbiA9IG92ZXJmbG93ID8gJzAgYXV0bycgOiBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBIYW5kbGUgcmVzaXppbmdcbiAgICAgIGNvbnN0IHJlc2l6ZWQgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcnMucmVzaXplZCk7XG4gICAgICAgIHRpbWVycy5yZXNpemVkID0gc2V0VGltZW91dChzZXRHdXR0ZXIsIDUwKTtcbiAgICAgIH07XG4gICAgICBvbi5jYWxsKHBsYXllciwgZWxlbWVudHMuY29udGFpbmVyLCAnZW50ZXJmdWxsc2NyZWVuIGV4aXRmdWxsc2NyZWVuJywgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdGFyZ2V0XG4gICAgICAgIH0gPSBwbGF5ZXIuZnVsbHNjcmVlbjtcblxuICAgICAgICAvLyBJZ25vcmUgZXZlbnRzIG5vdCBmcm9tIHRhcmdldFxuICAgICAgICBpZiAodGFyZ2V0ICE9PSBlbGVtZW50cy5jb250YWluZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBpdCdzIG5vdCBhbiBlbWJlZCBhbmQgbm8gcmF0aW8gc3BlY2lmaWVkXG4gICAgICAgIGlmICghcGxheWVyLmlzRW1iZWQgJiYgaXMuZW1wdHkocGxheWVyLmNvbmZpZy5yYXRpbykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgVmltZW8gZ3V0dGVyXG4gICAgICAgIHNldEd1dHRlcigpO1xuXG4gICAgICAgIC8vIFdhdGNoIGZvciByZXNpemVzXG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGV2ZW50LnR5cGUgPT09ICdlbnRlcmZ1bGxzY3JlZW4nID8gb24gOiBvZmY7XG4gICAgICAgIG1ldGhvZC5jYWxsKHBsYXllciwgd2luZG93LCAncmVzaXplJywgcmVzaXplZCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBMaXN0ZW4gZm9yIG1lZGlhIGV2ZW50c1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwibWVkaWFcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGF5ZXJcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHBsYXllcjtcblxuICAgICAgLy8gVGltZSBjaGFuZ2Ugb24gbWVkaWFcbiAgICAgIG9uLmNhbGwocGxheWVyLCBwbGF5ZXIubWVkaWEsICd0aW1ldXBkYXRlIHNlZWtpbmcgc2Vla2VkJywgZXZlbnQgPT4gY29udHJvbHMudGltZVVwZGF0ZS5jYWxsKHBsYXllciwgZXZlbnQpKTtcblxuICAgICAgLy8gRGlzcGxheSBkdXJhdGlvblxuICAgICAgb24uY2FsbChwbGF5ZXIsIHBsYXllci5tZWRpYSwgJ2R1cmF0aW9uY2hhbmdlIGxvYWRlZGRhdGEgbG9hZGVkbWV0YWRhdGEnLCBldmVudCA9PiBjb250cm9scy5kdXJhdGlvblVwZGF0ZS5jYWxsKHBsYXllciwgZXZlbnQpKTtcblxuICAgICAgLy8gSGFuZGxlIHRoZSBtZWRpYSBmaW5pc2hpbmdcbiAgICAgIG9uLmNhbGwocGxheWVyLCBwbGF5ZXIubWVkaWEsICdlbmRlZCcsICgpID0+IHtcbiAgICAgICAgLy8gU2hvdyBwb3N0ZXIgb24gZW5kXG4gICAgICAgIGlmIChwbGF5ZXIuaXNIVE1MNSAmJiBwbGF5ZXIuaXNWaWRlbyAmJiBwbGF5ZXIuY29uZmlnLnJlc2V0T25FbmQpIHtcbiAgICAgICAgICAvLyBSZXN0YXJ0XG4gICAgICAgICAgcGxheWVyLnJlc3RhcnQoKTtcblxuICAgICAgICAgIC8vIENhbGwgcGF1c2Ugb3RoZXJ3aXNlIElFMTEgd2lsbCBzdGFydCBwbGF5aW5nIHRoZSB2aWRlbyBhZ2FpblxuICAgICAgICAgIHBsYXllci5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQ2hlY2sgZm9yIGJ1ZmZlciBwcm9ncmVzc1xuICAgICAgb24uY2FsbChwbGF5ZXIsIHBsYXllci5tZWRpYSwgJ3Byb2dyZXNzIHBsYXlpbmcgc2Vla2luZyBzZWVrZWQnLCBldmVudCA9PiBjb250cm9scy51cGRhdGVQcm9ncmVzcy5jYWxsKHBsYXllciwgZXZlbnQpKTtcblxuICAgICAgLy8gSGFuZGxlIHZvbHVtZSBjaGFuZ2VzXG4gICAgICBvbi5jYWxsKHBsYXllciwgcGxheWVyLm1lZGlhLCAndm9sdW1lY2hhbmdlJywgZXZlbnQgPT4gY29udHJvbHMudXBkYXRlVm9sdW1lLmNhbGwocGxheWVyLCBldmVudCkpO1xuXG4gICAgICAvLyBIYW5kbGUgcGxheS9wYXVzZVxuICAgICAgb24uY2FsbChwbGF5ZXIsIHBsYXllci5tZWRpYSwgJ3BsYXlpbmcgcGxheSBwYXVzZSBlbmRlZCBlbXB0aWVkIHRpbWV1cGRhdGUnLCBldmVudCA9PiB1aS5jaGVja1BsYXlpbmcuY2FsbChwbGF5ZXIsIGV2ZW50KSk7XG5cbiAgICAgIC8vIExvYWRpbmcgc3RhdGVcbiAgICAgIG9uLmNhbGwocGxheWVyLCBwbGF5ZXIubWVkaWEsICd3YWl0aW5nIGNhbnBsYXkgc2Vla2VkIHBsYXlpbmcnLCBldmVudCA9PiB1aS5jaGVja0xvYWRpbmcuY2FsbChwbGF5ZXIsIGV2ZW50KSk7XG5cbiAgICAgIC8vIENsaWNrIHZpZGVvXG4gICAgICBpZiAocGxheWVyLnN1cHBvcnRlZC51aSAmJiBwbGF5ZXIuY29uZmlnLmNsaWNrVG9QbGF5ICYmICFwbGF5ZXIuaXNBdWRpbykge1xuICAgICAgICAvLyBSZS1mZXRjaCB0aGUgd3JhcHBlclxuICAgICAgICBjb25zdCB3cmFwcGVyID0gZ2V0RWxlbWVudC5jYWxsKHBsYXllciwgYC4ke3BsYXllci5jb25maWcuY2xhc3NOYW1lcy52aWRlb31gKTtcblxuICAgICAgICAvLyBCYWlsIGlmIHRoZXJlJ3Mgbm8gd3JhcHBlciAodGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuKVxuICAgICAgICBpZiAoIWlzLmVsZW1lbnQod3JhcHBlcikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbiBjbGljayBwbGF5LCBwYXVzZSBvciByZXN0YXJ0XG4gICAgICAgIG9uLmNhbGwocGxheWVyLCBlbGVtZW50cy5jb250YWluZXIsICdjbGljaycsIGV2ZW50ID0+IHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRzID0gW2VsZW1lbnRzLmNvbnRhaW5lciwgd3JhcHBlcl07XG5cbiAgICAgICAgICAvLyBJZ25vcmUgaWYgY2xpY2sgaWYgbm90IGNvbnRhaW5lciBvciBpbiB2aWRlbyB3cmFwcGVyXG4gICAgICAgICAgaWYgKCF0YXJnZXRzLmluY2x1ZGVzKGV2ZW50LnRhcmdldCkgJiYgIXdyYXBwZXIuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRvdWNoIGRldmljZXMgd2lsbCBqdXN0IHNob3cgY29udHJvbHMgKGlmIGhpZGRlbilcbiAgICAgICAgICBpZiAocGxheWVyLnRvdWNoICYmIHBsYXllci5jb25maWcuaGlkZUNvbnRyb2xzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwbGF5ZXIuZW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHJveHkoZXZlbnQsIHBsYXllci5yZXN0YXJ0LCAncmVzdGFydCcpO1xuICAgICAgICAgICAgdGhpcy5wcm94eShldmVudCwgKCkgPT4ge1xuICAgICAgICAgICAgICBzaWxlbmNlUHJvbWlzZShwbGF5ZXIucGxheSgpKTtcbiAgICAgICAgICAgIH0sICdwbGF5Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJveHkoZXZlbnQsICgpID0+IHtcbiAgICAgICAgICAgICAgc2lsZW5jZVByb21pc2UocGxheWVyLnRvZ2dsZVBsYXkoKSk7XG4gICAgICAgICAgICB9LCAncGxheScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIERpc2FibGUgcmlnaHQgY2xpY2tcbiAgICAgIGlmIChwbGF5ZXIuc3VwcG9ydGVkLnVpICYmIHBsYXllci5jb25maWcuZGlzYWJsZUNvbnRleHRNZW51KSB7XG4gICAgICAgIG9uLmNhbGwocGxheWVyLCBlbGVtZW50cy53cmFwcGVyLCAnY29udGV4dG1lbnUnLCBldmVudCA9PiB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBWb2x1bWUgY2hhbmdlXG4gICAgICBvbi5jYWxsKHBsYXllciwgcGxheWVyLm1lZGlhLCAndm9sdW1lY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAvLyBTYXZlIHRvIHN0b3JhZ2VcbiAgICAgICAgcGxheWVyLnN0b3JhZ2Uuc2V0KHtcbiAgICAgICAgICB2b2x1bWU6IHBsYXllci52b2x1bWUsXG4gICAgICAgICAgbXV0ZWQ6IHBsYXllci5tdXRlZFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTcGVlZCBjaGFuZ2VcbiAgICAgIG9uLmNhbGwocGxheWVyLCBwbGF5ZXIubWVkaWEsICdyYXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAvLyBVcGRhdGUgVUlcbiAgICAgICAgY29udHJvbHMudXBkYXRlU2V0dGluZy5jYWxsKHBsYXllciwgJ3NwZWVkJyk7XG5cbiAgICAgICAgLy8gU2F2ZSB0byBzdG9yYWdlXG4gICAgICAgIHBsYXllci5zdG9yYWdlLnNldCh7XG4gICAgICAgICAgc3BlZWQ6IHBsYXllci5zcGVlZFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBRdWFsaXR5IGNoYW5nZVxuICAgICAgb24uY2FsbChwbGF5ZXIsIHBsYXllci5tZWRpYSwgJ3F1YWxpdHljaGFuZ2UnLCBldmVudCA9PiB7XG4gICAgICAgIC8vIFVwZGF0ZSBVSVxuICAgICAgICBjb250cm9scy51cGRhdGVTZXR0aW5nLmNhbGwocGxheWVyLCAncXVhbGl0eScsIG51bGwsIGV2ZW50LmRldGFpbC5xdWFsaXR5KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBVcGRhdGUgZG93bmxvYWQgbGluayB3aGVuIHJlYWR5IGFuZCBpZiBxdWFsaXR5IGNoYW5nZXNcbiAgICAgIG9uLmNhbGwocGxheWVyLCBwbGF5ZXIubWVkaWEsICdyZWFkeSBxdWFsaXR5Y2hhbmdlJywgKCkgPT4ge1xuICAgICAgICBjb250cm9scy5zZXREb3dubG9hZFVybC5jYWxsKHBsYXllcik7XG4gICAgICB9KTtcblxuICAgICAgLy8gUHJveHkgZXZlbnRzIHRvIGNvbnRhaW5lclxuICAgICAgLy8gQnViYmxlIHVwIGtleSBldmVudHMgZm9yIEVkZ2VcbiAgICAgIGNvbnN0IHByb3h5RXZlbnRzID0gcGxheWVyLmNvbmZpZy5ldmVudHMuY29uY2F0KFsna2V5dXAnLCAna2V5ZG93biddKS5qb2luKCcgJyk7XG4gICAgICBvbi5jYWxsKHBsYXllciwgcGxheWVyLm1lZGlhLCBwcm94eUV2ZW50cywgZXZlbnQgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGRldGFpbCA9IHt9XG4gICAgICAgIH0gPSBldmVudDtcblxuICAgICAgICAvLyBHZXQgZXJyb3IgZGV0YWlscyBmcm9tIG1lZGlhXG4gICAgICAgIGlmIChldmVudC50eXBlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgZGV0YWlsID0gcGxheWVyLm1lZGlhLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRyaWdnZXJFdmVudC5jYWxsKHBsYXllciwgZWxlbWVudHMuY29udGFpbmVyLCBldmVudC50eXBlLCB0cnVlLCBkZXRhaWwpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gUnVuIGRlZmF1bHQgYW5kIGN1c3RvbSBoYW5kbGVyc1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwicHJveHlcIiwgKGV2ZW50LCBkZWZhdWx0SGFuZGxlciwgY3VzdG9tSGFuZGxlcktleSkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGF5ZXJcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgY29uc3QgY3VzdG9tSGFuZGxlciA9IHBsYXllci5jb25maWcubGlzdGVuZXJzW2N1c3RvbUhhbmRsZXJLZXldO1xuICAgICAgY29uc3QgaGFzQ3VzdG9tSGFuZGxlciA9IGlzLmZ1bmN0aW9uKGN1c3RvbUhhbmRsZXIpO1xuICAgICAgbGV0IHJldHVybmVkID0gdHJ1ZTtcblxuICAgICAgLy8gRXhlY3V0ZSBjdXN0b20gaGFuZGxlclxuICAgICAgaWYgKGhhc0N1c3RvbUhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuZWQgPSBjdXN0b21IYW5kbGVyLmNhbGwocGxheWVyLCBldmVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE9ubHkgY2FsbCBkZWZhdWx0IGhhbmRsZXIgaWYgbm90IHByZXZlbnRlZCBpbiBjdXN0b20gaGFuZGxlclxuICAgICAgaWYgKHJldHVybmVkICE9PSBmYWxzZSAmJiBpcy5mdW5jdGlvbihkZWZhdWx0SGFuZGxlcikpIHtcbiAgICAgICAgZGVmYXVsdEhhbmRsZXIuY2FsbChwbGF5ZXIsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBUcmlnZ2VyIGN1c3RvbSBhbmQgZGVmYXVsdCBoYW5kbGVyc1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwiYmluZFwiLCAoZWxlbWVudCwgdHlwZSwgZGVmYXVsdEhhbmRsZXIsIGN1c3RvbUhhbmRsZXJLZXksIHBhc3NpdmUgPSB0cnVlKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYXllclxuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCBjdXN0b21IYW5kbGVyID0gcGxheWVyLmNvbmZpZy5saXN0ZW5lcnNbY3VzdG9tSGFuZGxlcktleV07XG4gICAgICBjb25zdCBoYXNDdXN0b21IYW5kbGVyID0gaXMuZnVuY3Rpb24oY3VzdG9tSGFuZGxlcik7XG4gICAgICBvbi5jYWxsKHBsYXllciwgZWxlbWVudCwgdHlwZSwgZXZlbnQgPT4gdGhpcy5wcm94eShldmVudCwgZGVmYXVsdEhhbmRsZXIsIGN1c3RvbUhhbmRsZXJLZXkpLCBwYXNzaXZlICYmICFoYXNDdXN0b21IYW5kbGVyKTtcbiAgICB9KTtcbiAgICAvLyBMaXN0ZW4gZm9yIGNvbnRyb2wgZXZlbnRzXG4gICAgX2RlZmluZVByb3BlcnR5JDEodGhpcywgXCJjb250cm9sc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYXllclxuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVsZW1lbnRzXG4gICAgICB9ID0gcGxheWVyO1xuICAgICAgLy8gSUUgZG9lc24ndCBzdXBwb3J0IGlucHV0IGV2ZW50LCBzbyB3ZSBmYWxsYmFjayB0byBjaGFuZ2VcbiAgICAgIGNvbnN0IGlucHV0RXZlbnQgPSBicm93c2VyLmlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG5cbiAgICAgIC8vIFBsYXkvcGF1c2UgdG9nZ2xlXG4gICAgICBpZiAoZWxlbWVudHMuYnV0dG9ucy5wbGF5KSB7XG4gICAgICAgIEFycmF5LmZyb20oZWxlbWVudHMuYnV0dG9ucy5wbGF5KS5mb3JFYWNoKGJ1dHRvbiA9PiB7XG4gICAgICAgICAgdGhpcy5iaW5kKGJ1dHRvbiwgJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgc2lsZW5jZVByb21pc2UocGxheWVyLnRvZ2dsZVBsYXkoKSk7XG4gICAgICAgICAgfSwgJ3BsYXknKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFBhdXNlXG4gICAgICB0aGlzLmJpbmQoZWxlbWVudHMuYnV0dG9ucy5yZXN0YXJ0LCAnY2xpY2snLCBwbGF5ZXIucmVzdGFydCwgJ3Jlc3RhcnQnKTtcblxuICAgICAgLy8gUmV3aW5kXG4gICAgICB0aGlzLmJpbmQoZWxlbWVudHMuYnV0dG9ucy5yZXdpbmQsICdjbGljaycsICgpID0+IHtcbiAgICAgICAgLy8gUmVjb3JkIHNlZWsgdGltZSBzbyB3ZSBjYW4gcHJldmVudCBoaWRpbmcgY29udHJvbHMgZm9yIGEgZmV3IHNlY29uZHMgYWZ0ZXIgcmV3aW5kXG4gICAgICAgIHBsYXllci5sYXN0U2Vla1RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBwbGF5ZXIucmV3aW5kKCk7XG4gICAgICB9LCAncmV3aW5kJyk7XG5cbiAgICAgIC8vIFJld2luZFxuICAgICAgdGhpcy5iaW5kKGVsZW1lbnRzLmJ1dHRvbnMuZmFzdEZvcndhcmQsICdjbGljaycsICgpID0+IHtcbiAgICAgICAgLy8gUmVjb3JkIHNlZWsgdGltZSBzbyB3ZSBjYW4gcHJldmVudCBoaWRpbmcgY29udHJvbHMgZm9yIGEgZmV3IHNlY29uZHMgYWZ0ZXIgZmFzdCBmb3J3YXJkXG4gICAgICAgIHBsYXllci5sYXN0U2Vla1RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBwbGF5ZXIuZm9yd2FyZCgpO1xuICAgICAgfSwgJ2Zhc3RGb3J3YXJkJyk7XG5cbiAgICAgIC8vIE11dGUgdG9nZ2xlXG4gICAgICB0aGlzLmJpbmQoZWxlbWVudHMuYnV0dG9ucy5tdXRlLCAnY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIHBsYXllci5tdXRlZCA9ICFwbGF5ZXIubXV0ZWQ7XG4gICAgICB9LCAnbXV0ZScpO1xuXG4gICAgICAvLyBDYXB0aW9ucyB0b2dnbGVcbiAgICAgIHRoaXMuYmluZChlbGVtZW50cy5idXR0b25zLmNhcHRpb25zLCAnY2xpY2snLCAoKSA9PiBwbGF5ZXIudG9nZ2xlQ2FwdGlvbnMoKSk7XG5cbiAgICAgIC8vIERvd25sb2FkXG4gICAgICB0aGlzLmJpbmQoZWxlbWVudHMuYnV0dG9ucy5kb3dubG9hZCwgJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICB0cmlnZ2VyRXZlbnQuY2FsbChwbGF5ZXIsIHBsYXllci5tZWRpYSwgJ2Rvd25sb2FkJyk7XG4gICAgICB9LCAnZG93bmxvYWQnKTtcblxuICAgICAgLy8gRnVsbHNjcmVlbiB0b2dnbGVcbiAgICAgIHRoaXMuYmluZChlbGVtZW50cy5idXR0b25zLmZ1bGxzY3JlZW4sICdjbGljaycsICgpID0+IHtcbiAgICAgICAgcGxheWVyLmZ1bGxzY3JlZW4udG9nZ2xlKCk7XG4gICAgICB9LCAnZnVsbHNjcmVlbicpO1xuXG4gICAgICAvLyBQaWN0dXJlLWluLVBpY3R1cmVcbiAgICAgIHRoaXMuYmluZChlbGVtZW50cy5idXR0b25zLnBpcCwgJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICBwbGF5ZXIucGlwID0gJ3RvZ2dsZSc7XG4gICAgICB9LCAncGlwJyk7XG5cbiAgICAgIC8vIEFpcnBsYXlcbiAgICAgIHRoaXMuYmluZChlbGVtZW50cy5idXR0b25zLmFpcnBsYXksICdjbGljaycsIHBsYXllci5haXJwbGF5LCAnYWlycGxheScpO1xuXG4gICAgICAvLyBTZXR0aW5ncyBtZW51IC0gY2xpY2sgdG9nZ2xlXG4gICAgICB0aGlzLmJpbmQoZWxlbWVudHMuYnV0dG9ucy5zZXR0aW5ncywgJ2NsaWNrJywgZXZlbnQgPT4ge1xuICAgICAgICAvLyBQcmV2ZW50IHRoZSBkb2N1bWVudCBjbGljayBsaXN0ZW5lciBjbG9zaW5nIHRoZSBtZW51XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjb250cm9scy50b2dnbGVNZW51LmNhbGwocGxheWVyLCBldmVudCk7XG4gICAgICB9LCBudWxsLCBmYWxzZSk7IC8vIENhbid0IGJlIHBhc3NpdmUgYXMgd2UncmUgcHJldmVudGluZyBkZWZhdWx0XG5cbiAgICAgIC8vIFNldHRpbmdzIG1lbnUgLSBrZXlib2FyZCB0b2dnbGVcbiAgICAgIC8vIFdlIGhhdmUgdG8gYmluZCB0byBrZXl1cCBvdGhlcndpc2UgRmlyZWZveCB0cmlnZ2VycyBhIGNsaWNrIHdoZW4gYSBrZXlkb3duIGV2ZW50IGhhbmRsZXIgc2hpZnRzIGZvY3VzXG4gICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjIwMTQzXG4gICAgICB0aGlzLmJpbmQoZWxlbWVudHMuYnV0dG9ucy5zZXR0aW5ncywgJ2tleXVwJywgZXZlbnQgPT4ge1xuICAgICAgICBpZiAoIVsnICcsICdFbnRlciddLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZWNhdXNlIHJldHVybiB0cmlnZ2VycyBhIGNsaWNrIGFueXdheSwgYWxsIHdlIG5lZWQgdG8gZG8gaXMgc2V0IGZvY3VzXG4gICAgICAgIGlmIChldmVudC5rZXkgPT09ICdFbnRlcicpIHtcbiAgICAgICAgICBjb250cm9scy5mb2N1c0ZpcnN0TWVudUl0ZW0uY2FsbChwbGF5ZXIsIG51bGwsIHRydWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZXZlbnQgc2Nyb2xsXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gUHJldmVudCBwbGF5aW5nIHZpZGVvIChGaXJlZm94KVxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAvLyBUb2dnbGUgbWVudVxuICAgICAgICBjb250cm9scy50b2dnbGVNZW51LmNhbGwocGxheWVyLCBldmVudCk7XG4gICAgICB9LCBudWxsLCBmYWxzZSAvLyBDYW4ndCBiZSBwYXNzaXZlIGFzIHdlJ3JlIHByZXZlbnRpbmcgZGVmYXVsdFxuICAgICAgKTtcblxuICAgICAgLy8gRXNjYXBlIGNsb3NlcyBtZW51XG4gICAgICB0aGlzLmJpbmQoZWxlbWVudHMuc2V0dGluZ3MubWVudSwgJ2tleWRvd24nLCBldmVudCA9PiB7XG4gICAgICAgIGlmIChldmVudC5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgICAgY29udHJvbHMudG9nZ2xlTWVudS5jYWxsKHBsYXllciwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gU2V0IHJhbmdlIGlucHV0IGFsdGVybmF0aXZlIFwidmFsdWVcIiwgd2hpY2ggbWF0Y2hlcyB0aGUgdG9vbHRpcCB0aW1lICgjOTU0KVxuICAgICAgdGhpcy5iaW5kKGVsZW1lbnRzLmlucHV0cy5zZWVrLCAnbW91c2Vkb3duIG1vdXNlbW92ZScsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgcmVjdCA9IGVsZW1lbnRzLnByb2dyZXNzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCBzY3JvbGxMZWZ0ID0gZXZlbnQucGFnZVggLSBldmVudC5jbGllbnRYO1xuICAgICAgICBjb25zdCBwZXJjZW50ID0gMTAwIC8gcmVjdC53aWR0aCAqIChldmVudC5wYWdlWCAtIHJlY3QubGVmdCAtIHNjcm9sbExlZnQpO1xuICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0LnNldEF0dHJpYnV0ZSgnc2Vlay12YWx1ZScsIHBlcmNlbnQpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFBhdXNlIHdoaWxlIHNlZWtpbmdcbiAgICAgIHRoaXMuYmluZChlbGVtZW50cy5pbnB1dHMuc2VlaywgJ21vdXNlZG93biBtb3VzZXVwIGtleWRvd24ga2V5dXAgdG91Y2hzdGFydCB0b3VjaGVuZCcsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3Qgc2VlayA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9ICdwbGF5LW9uLXNlZWtlZCc7XG4gICAgICAgIGlmIChpcy5rZXlib2FyZEV2ZW50KGV2ZW50KSAmJiAhWydBcnJvd0xlZnQnLCAnQXJyb3dSaWdodCddLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWNvcmQgc2VlayB0aW1lIHNvIHdlIGNhbiBwcmV2ZW50IGhpZGluZyBjb250cm9scyBmb3IgYSBmZXcgc2Vjb25kcyBhZnRlciBzZWVrXG4gICAgICAgIHBsYXllci5sYXN0U2Vla1RpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIC8vIFdhcyBwbGF5aW5nIGJlZm9yZT9cbiAgICAgICAgY29uc3QgcGxheSA9IHNlZWsuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICAgIC8vIERvbmUgc2Vla2luZ1xuICAgICAgICBjb25zdCBkb25lID0gWydtb3VzZXVwJywgJ3RvdWNoZW5kJywgJ2tleXVwJ10uaW5jbHVkZXMoZXZlbnQudHlwZSk7XG5cbiAgICAgICAgLy8gSWYgd2UncmUgZG9uZSBzZWVraW5nIGFuZCBpdCB3YXMgcGxheWluZywgcmVzdW1lIHBsYXliYWNrXG4gICAgICAgIGlmIChwbGF5ICYmIGRvbmUpIHtcbiAgICAgICAgICBzZWVrLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgICAgIHNpbGVuY2VQcm9taXNlKHBsYXllci5wbGF5KCkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFkb25lICYmIHBsYXllci5wbGF5aW5nKSB7XG4gICAgICAgICAgc2Vlay5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCAnJyk7XG4gICAgICAgICAgcGxheWVyLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBGaXggcmFuZ2UgaW5wdXRzIG9uIGlPU1xuICAgICAgLy8gU3VwZXIgd2VpcmQgaU9TIGJ1ZyB3aGVyZSBhZnRlciB5b3UgaW50ZXJhY3Qgd2l0aCBhbiA8aW5wdXQgdHlwZT1cInJhbmdlXCI+LFxuICAgICAgLy8gaXQgdGFrZXMgb3ZlciBmdXJ0aGVyIGludGVyYWN0aW9ucyBvbiB0aGUgcGFnZS4gVGhpcyBpcyBhIGhhY2tcbiAgICAgIGlmIChicm93c2VyLmlzSW9zKSB7XG4gICAgICAgIGNvbnN0IGlucHV0cyA9IGdldEVsZW1lbnRzLmNhbGwocGxheWVyLCAnaW5wdXRbdHlwZT1cInJhbmdlXCJdJyk7XG4gICAgICAgIEFycmF5LmZyb20oaW5wdXRzKS5mb3JFYWNoKGlucHV0ID0+IHRoaXMuYmluZChpbnB1dCwgaW5wdXRFdmVudCwgZXZlbnQgPT4gcmVwYWludChldmVudC50YXJnZXQpKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNlZWtcbiAgICAgIHRoaXMuYmluZChlbGVtZW50cy5pbnB1dHMuc2VlaywgaW5wdXRFdmVudCwgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBzZWVrID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgLy8gSWYgaXQgZXhpc3RzLCB1c2Ugc2Vlay12YWx1ZSBpbnN0ZWFkIG9mIFwidmFsdWVcIiBmb3IgY29uc2lzdGVuY3kgd2l0aCB0b29sdGlwIHRpbWUgKCM5NTQpXG4gICAgICAgIGxldCBzZWVrVG8gPSBzZWVrLmdldEF0dHJpYnV0ZSgnc2Vlay12YWx1ZScpO1xuICAgICAgICBpZiAoaXMuZW1wdHkoc2Vla1RvKSkge1xuICAgICAgICAgIHNlZWtUbyA9IHNlZWsudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc2Vlay5yZW1vdmVBdHRyaWJ1dGUoJ3NlZWstdmFsdWUnKTtcbiAgICAgICAgcGxheWVyLmN1cnJlbnRUaW1lID0gc2Vla1RvIC8gc2Vlay5tYXggKiBwbGF5ZXIuZHVyYXRpb247XG4gICAgICB9LCAnc2VlaycpO1xuXG4gICAgICAvLyBTZWVrIHRvb2x0aXBcbiAgICAgIHRoaXMuYmluZChlbGVtZW50cy5wcm9ncmVzcywgJ21vdXNlZW50ZXIgbW91c2VsZWF2ZSBtb3VzZW1vdmUnLCBldmVudCA9PiBjb250cm9scy51cGRhdGVTZWVrVG9vbHRpcC5jYWxsKHBsYXllciwgZXZlbnQpKTtcblxuICAgICAgLy8gUHJldmlldyB0aHVtYm5haWxzIHBsdWdpblxuICAgICAgLy8gVE9ETzogUmVhbGx5IG5lZWQgdG8gd29yayBvbiBzb21lIHNvcnQgb2YgcGx1Zy1pbiB3aWRlIGV2ZW50IGJ1cyBvciBwdWItc3ViIGZvciB0aGlzXG4gICAgICB0aGlzLmJpbmQoZWxlbWVudHMucHJvZ3Jlc3MsICdtb3VzZW1vdmUgdG91Y2htb3ZlJywgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcHJldmlld1RodW1ibmFpbHNcbiAgICAgICAgfSA9IHBsYXllcjtcbiAgICAgICAgaWYgKHByZXZpZXdUaHVtYm5haWxzICYmIHByZXZpZXdUaHVtYm5haWxzLmxvYWRlZCkge1xuICAgICAgICAgIHByZXZpZXdUaHVtYm5haWxzLnN0YXJ0TW92ZShldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBIaWRlIHRodW1ibmFpbCBwcmV2aWV3IC0gb24gbW91c2UgY2xpY2ssIG1vdXNlIGxlYXZlLCBhbmQgdmlkZW8gcGxheS9zZWVrLiBBbGwgZm91ciBhcmUgcmVxdWlyZWQsIGUuZy4sIGZvciBidWZmZXJpbmdcbiAgICAgIHRoaXMuYmluZChlbGVtZW50cy5wcm9ncmVzcywgJ21vdXNlbGVhdmUgdG91Y2hlbmQgY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBwcmV2aWV3VGh1bWJuYWlsc1xuICAgICAgICB9ID0gcGxheWVyO1xuICAgICAgICBpZiAocHJldmlld1RodW1ibmFpbHMgJiYgcHJldmlld1RodW1ibmFpbHMubG9hZGVkKSB7XG4gICAgICAgICAgcHJldmlld1RodW1ibmFpbHMuZW5kTW92ZShmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBTaG93IHNjcnViYmluZyBwcmV2aWV3XG4gICAgICB0aGlzLmJpbmQoZWxlbWVudHMucHJvZ3Jlc3MsICdtb3VzZWRvd24gdG91Y2hzdGFydCcsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHByZXZpZXdUaHVtYm5haWxzXG4gICAgICAgIH0gPSBwbGF5ZXI7XG4gICAgICAgIGlmIChwcmV2aWV3VGh1bWJuYWlscyAmJiBwcmV2aWV3VGh1bWJuYWlscy5sb2FkZWQpIHtcbiAgICAgICAgICBwcmV2aWV3VGh1bWJuYWlscy5zdGFydFNjcnViYmluZyhldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5iaW5kKGVsZW1lbnRzLnByb2dyZXNzLCAnbW91c2V1cCB0b3VjaGVuZCcsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHByZXZpZXdUaHVtYm5haWxzXG4gICAgICAgIH0gPSBwbGF5ZXI7XG4gICAgICAgIGlmIChwcmV2aWV3VGh1bWJuYWlscyAmJiBwcmV2aWV3VGh1bWJuYWlscy5sb2FkZWQpIHtcbiAgICAgICAgICBwcmV2aWV3VGh1bWJuYWlscy5lbmRTY3J1YmJpbmcoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gUG9seWZpbGwgZm9yIGxvd2VyIGZpbGwgaW4gPGlucHV0IHR5cGU9XCJyYW5nZVwiPiBmb3Igd2Via2l0XG4gICAgICBpZiAoYnJvd3Nlci5pc1dlYktpdCkge1xuICAgICAgICBBcnJheS5mcm9tKGdldEVsZW1lbnRzLmNhbGwocGxheWVyLCAnaW5wdXRbdHlwZT1cInJhbmdlXCJdJykpLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgdGhpcy5iaW5kKGVsZW1lbnQsICdpbnB1dCcsIGV2ZW50ID0+IGNvbnRyb2xzLnVwZGF0ZVJhbmdlRmlsbC5jYWxsKHBsYXllciwgZXZlbnQudGFyZ2V0KSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBDdXJyZW50IHRpbWUgaW52ZXJ0XG4gICAgICAvLyBPbmx5IGlmIG9uZSB0aW1lIGVsZW1lbnQgaXMgdXNlZCBmb3IgYm90aCBjdXJyZW50VGltZSBhbmQgZHVyYXRpb25cbiAgICAgIGlmIChwbGF5ZXIuY29uZmlnLnRvZ2dsZUludmVydCAmJiAhaXMuZWxlbWVudChlbGVtZW50cy5kaXNwbGF5LmR1cmF0aW9uKSkge1xuICAgICAgICB0aGlzLmJpbmQoZWxlbWVudHMuZGlzcGxheS5jdXJyZW50VGltZSwgJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgd2UncmUgYXQgdGhlIHN0YXJ0XG4gICAgICAgICAgaWYgKHBsYXllci5jdXJyZW50VGltZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwbGF5ZXIuY29uZmlnLmludmVydFRpbWUgPSAhcGxheWVyLmNvbmZpZy5pbnZlcnRUaW1lO1xuICAgICAgICAgIGNvbnRyb2xzLnRpbWVVcGRhdGUuY2FsbChwbGF5ZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gVm9sdW1lXG4gICAgICB0aGlzLmJpbmQoZWxlbWVudHMuaW5wdXRzLnZvbHVtZSwgaW5wdXRFdmVudCwgZXZlbnQgPT4ge1xuICAgICAgICBwbGF5ZXIudm9sdW1lID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgfSwgJ3ZvbHVtZScpO1xuXG4gICAgICAvLyBVcGRhdGUgY29udHJvbHMuaG92ZXIgc3RhdGUgKHVzZWQgZm9yIHVpLnRvZ2dsZUNvbnRyb2xzIHRvIGF2b2lkIGhpZGluZyB3aGVuIGludGVyYWN0aW5nKVxuICAgICAgdGhpcy5iaW5kKGVsZW1lbnRzLmNvbnRyb2xzLCAnbW91c2VlbnRlciBtb3VzZWxlYXZlJywgZXZlbnQgPT4ge1xuICAgICAgICBlbGVtZW50cy5jb250cm9scy5ob3ZlciA9ICFwbGF5ZXIudG91Y2ggJiYgZXZlbnQudHlwZSA9PT0gJ21vdXNlZW50ZXInO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEFsc28gdXBkYXRlIGNvbnRyb2xzLmhvdmVyIHN0YXRlIGZvciBhbnkgbm9uLXBsYXllciBjaGlsZHJlbiBvZiBmdWxsc2NyZWVuIGVsZW1lbnQgKGFzIGFib3ZlKVxuICAgICAgaWYgKGVsZW1lbnRzLmZ1bGxzY3JlZW4pIHtcbiAgICAgICAgQXJyYXkuZnJvbShlbGVtZW50cy5mdWxsc2NyZWVuLmNoaWxkcmVuKS5maWx0ZXIoYyA9PiAhYy5jb250YWlucyhlbGVtZW50cy5jb250YWluZXIpKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICB0aGlzLmJpbmQoY2hpbGQsICdtb3VzZWVudGVyIG1vdXNlbGVhdmUnLCBldmVudCA9PiB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudHMuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgZWxlbWVudHMuY29udHJvbHMuaG92ZXIgPSAhcGxheWVyLnRvdWNoICYmIGV2ZW50LnR5cGUgPT09ICdtb3VzZWVudGVyJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBjb250cm9scy5wcmVzc2VkIHN0YXRlICh1c2VkIGZvciB1aS50b2dnbGVDb250cm9scyB0byBhdm9pZCBoaWRpbmcgd2hlbiBpbnRlcmFjdGluZylcbiAgICAgIHRoaXMuYmluZChlbGVtZW50cy5jb250cm9scywgJ21vdXNlZG93biBtb3VzZXVwIHRvdWNoc3RhcnQgdG91Y2hlbmQgdG91Y2hjYW5jZWwnLCBldmVudCA9PiB7XG4gICAgICAgIGVsZW1lbnRzLmNvbnRyb2xzLnByZXNzZWQgPSBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10uaW5jbHVkZXMoZXZlbnQudHlwZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2hvdyBjb250cm9scyB3aGVuIHRoZXkgcmVjZWl2ZSBmb2N1cyAoZS5nLiwgd2hlbiB1c2luZyBrZXlib2FyZCB0YWIga2V5KVxuICAgICAgdGhpcy5iaW5kKGVsZW1lbnRzLmNvbnRyb2xzLCAnZm9jdXNpbicsICgpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICB0aW1lcnNcbiAgICAgICAgfSA9IHBsYXllcjtcblxuICAgICAgICAvLyBTa2lwIHRyYW5zaXRpb24gdG8gcHJldmVudCBmb2N1cyBmcm9tIHNjcm9sbGluZyB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICAgICAgdG9nZ2xlQ2xhc3MoZWxlbWVudHMuY29udHJvbHMsIGNvbmZpZy5jbGFzc05hbWVzLm5vVHJhbnNpdGlvbiwgdHJ1ZSk7XG5cbiAgICAgICAgLy8gVG9nZ2xlXG4gICAgICAgIHVpLnRvZ2dsZUNvbnRyb2xzLmNhbGwocGxheWVyLCB0cnVlKTtcblxuICAgICAgICAvLyBSZXN0b3JlIHRyYW5zaXRpb25cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZWxlbWVudHMuY29udHJvbHMsIGNvbmZpZy5jbGFzc05hbWVzLm5vVHJhbnNpdGlvbiwgZmFsc2UpO1xuICAgICAgICB9LCAwKTtcblxuICAgICAgICAvLyBEZWxheSBhIGxpdHRsZSBtb3JlIGZvciBtb3VzZSB1c2Vyc1xuICAgICAgICBjb25zdCBkZWxheSA9IHRoaXMudG91Y2ggPyAzMDAwIDogNDAwMDtcblxuICAgICAgICAvLyBDbGVhciB0aW1lclxuICAgICAgICBjbGVhclRpbWVvdXQodGltZXJzLmNvbnRyb2xzKTtcblxuICAgICAgICAvLyBIaWRlIGFnYWluIGFmdGVyIGRlbGF5XG4gICAgICAgIHRpbWVycy5jb250cm9scyA9IHNldFRpbWVvdXQoKCkgPT4gdWkudG9nZ2xlQ29udHJvbHMuY2FsbChwbGF5ZXIsIGZhbHNlKSwgZGVsYXkpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIE1vdXNlIHdoZWVsIGZvciB2b2x1bWVcbiAgICAgIHRoaXMuYmluZChlbGVtZW50cy5pbnB1dHMudm9sdW1lLCAnd2hlZWwnLCBldmVudCA9PiB7XG4gICAgICAgIC8vIERldGVjdCBcIm5hdHVyYWxcIiBzY3JvbGwgLSBzdXBwb3J0ZWQgb24gT1MgWCBTYWZhcmkgb25seVxuICAgICAgICAvLyBPdGhlciBicm93c2VycyBvbiBPUyBYIHdpbGwgYmUgaW52ZXJ0ZWQgdW50aWwgc3VwcG9ydCBpbXByb3Zlc1xuICAgICAgICBjb25zdCBpbnZlcnRlZCA9IGV2ZW50LndlYmtpdERpcmVjdGlvbkludmVydGVkRnJvbURldmljZTtcbiAgICAgICAgLy8gR2V0IGRlbHRhIGZyb20gZXZlbnQuIEludmVydCBpZiBgaW52ZXJ0ZWRgIGlzIHRydWVcbiAgICAgICAgY29uc3QgW3gsIHldID0gW2V2ZW50LmRlbHRhWCwgLWV2ZW50LmRlbHRhWV0ubWFwKHZhbHVlID0+IGludmVydGVkID8gLXZhbHVlIDogdmFsdWUpO1xuICAgICAgICAvLyBVc2luZyB0aGUgYmlnZ2VzdCBkZWx0YSwgbm9ybWFsaXplIHRvIDEgb3IgLTEgKG9yIDAgaWYgbm8gZGVsdGEpXG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IE1hdGguc2lnbihNYXRoLmFicyh4KSA+IE1hdGguYWJzKHkpID8geCA6IHkpO1xuXG4gICAgICAgIC8vIENoYW5nZSB0aGUgdm9sdW1lIGJ5IDIlXG4gICAgICAgIHBsYXllci5pbmNyZWFzZVZvbHVtZShkaXJlY3Rpb24gLyA1MCk7XG5cbiAgICAgICAgLy8gRG9uJ3QgYnJlYWsgcGFnZSBzY3JvbGxpbmcgYXQgbWF4IGFuZCBtaW5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHZvbHVtZVxuICAgICAgICB9ID0gcGxheWVyLm1lZGlhO1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAxICYmIHZvbHVtZSA8IDEgfHwgZGlyZWN0aW9uID09PSAtMSAmJiB2b2x1bWUgPiAwKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSwgJ3ZvbHVtZScsIGZhbHNlKTtcbiAgICB9KTtcbiAgICB0aGlzLnBsYXllciA9IF9wbGF5ZXI7XG4gICAgdGhpcy5sYXN0S2V5ID0gbnVsbDtcbiAgICB0aGlzLmZvY3VzVGltZXIgPSBudWxsO1xuICAgIHRoaXMubGFzdEtleURvd24gPSBudWxsO1xuICAgIHRoaXMuaGFuZGxlS2V5ID0gdGhpcy5oYW5kbGVLZXkuYmluZCh0aGlzKTtcbiAgICB0aGlzLnRvZ2dsZU1lbnUgPSB0aGlzLnRvZ2dsZU1lbnUuYmluZCh0aGlzKTtcbiAgICB0aGlzLmZpcnN0VG91Y2ggPSB0aGlzLmZpcnN0VG91Y2guYmluZCh0aGlzKTtcbiAgfVxuXG4gIC8vIEhhbmRsZSBrZXkgcHJlc3Nlc1xuICBoYW5kbGVLZXkoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBwbGF5ZXJcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBlbGVtZW50c1xuICAgIH0gPSBwbGF5ZXI7XG4gICAgY29uc3Qge1xuICAgICAga2V5LFxuICAgICAgdHlwZSxcbiAgICAgIGFsdEtleSxcbiAgICAgIGN0cmxLZXksXG4gICAgICBtZXRhS2V5LFxuICAgICAgc2hpZnRLZXlcbiAgICB9ID0gZXZlbnQ7XG4gICAgY29uc3QgcHJlc3NlZCA9IHR5cGUgPT09ICdrZXlkb3duJztcbiAgICBjb25zdCByZXBlYXQgPSBwcmVzc2VkICYmIGtleSA9PT0gdGhpcy5sYXN0S2V5O1xuXG4gICAgLy8gQmFpbCBpZiBhIG1vZGlmaWVyIGtleSBpcyBzZXRcbiAgICBpZiAoYWx0S2V5IHx8IGN0cmxLZXkgfHwgbWV0YUtleSB8fCBzaGlmdEtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBldmVudCBpcyBidWJibGVkIGZyb20gdGhlIG1lZGlhIGVsZW1lbnRcbiAgICAvLyBGaXJlZm94IGRvZXNuJ3QgZ2V0IHRoZSBrZXkgZm9yIHdoYXRldmVyIHJlYXNvblxuICAgIGlmICgha2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2VlayBieSBpbmNyZW1lbnRcbiAgICBjb25zdCBzZWVrQnlJbmNyZW1lbnQgPSBpbmNyZW1lbnQgPT4ge1xuICAgICAgLy8gRGl2aWRlIHRoZSBtYXggZHVyYXRpb24gaW50byAxMHRoJ3MgYW5kIHRpbWVzIGJ5IHRoZSBudW1iZXIgdmFsdWVcbiAgICAgIHBsYXllci5jdXJyZW50VGltZSA9IHBsYXllci5kdXJhdGlvbiAvIDEwICogaW5jcmVtZW50O1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGhlIGtleSBvbiBrZXlkb3duXG4gICAgLy8gUmVzZXQgb24ga2V5dXBcbiAgICBpZiAocHJlc3NlZCkge1xuICAgICAgLy8gQ2hlY2sgZm9jdXNlZCBlbGVtZW50XG4gICAgICAvLyBhbmQgaWYgdGhlIGZvY3VzZWQgZWxlbWVudCBpcyBub3QgZWRpdGFibGUgKGUuZy4gdGV4dCBpbnB1dClcbiAgICAgIC8vIGFuZCBhbnkgdGhhdCBhY2NlcHQga2V5IGlucHV0IGh0dHA6Ly93ZWJhaW0ub3JnL3RlY2huaXF1ZXMva2V5Ym9hcmQvXG4gICAgICBjb25zdCBmb2N1c2VkID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIGlmIChpcy5lbGVtZW50KGZvY3VzZWQpKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBlZGl0YWJsZVxuICAgICAgICB9ID0gcGxheWVyLmNvbmZpZy5zZWxlY3RvcnM7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzZWVrXG4gICAgICAgIH0gPSBlbGVtZW50cy5pbnB1dHM7XG4gICAgICAgIGlmIChmb2N1c2VkICE9PSBzZWVrICYmIG1hdGNoZXMoZm9jdXNlZCwgZWRpdGFibGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC5rZXkgPT09ICcgJyAmJiBtYXRjaGVzKGZvY3VzZWQsICdidXR0b24sIFtyb2xlXj1cIm1lbnVpdGVtXCJdJykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gV2hpY2gga2V5cyBzaG91bGQgd2UgcHJldmVudCBkZWZhdWx0XG4gICAgICBjb25zdCBwcmV2ZW50RGVmYXVsdCA9IFsnICcsICdBcnJvd0xlZnQnLCAnQXJyb3dVcCcsICdBcnJvd1JpZ2h0JywgJ0Fycm93RG93bicsICcwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JywgJ2MnLCAnZicsICdrJywgJ2wnLCAnbSddO1xuXG4gICAgICAvLyBJZiB0aGUga2V5IGlzIGZvdW5kIHByZXZlbnQgZGVmYXVsdCAoZS5nLiBwcmV2ZW50IHNjcm9sbGluZyBmb3IgYXJyb3dzKVxuICAgICAgaWYgKHByZXZlbnREZWZhdWx0LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgY2FzZSAnMSc6XG4gICAgICAgIGNhc2UgJzInOlxuICAgICAgICBjYXNlICczJzpcbiAgICAgICAgY2FzZSAnNCc6XG4gICAgICAgIGNhc2UgJzUnOlxuICAgICAgICBjYXNlICc2JzpcbiAgICAgICAgY2FzZSAnNyc6XG4gICAgICAgIGNhc2UgJzgnOlxuICAgICAgICBjYXNlICc5JzpcbiAgICAgICAgICBpZiAoIXJlcGVhdCkge1xuICAgICAgICAgICAgc2Vla0J5SW5jcmVtZW50KE51bWJlci5wYXJzZUludChrZXksIDEwKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgY2FzZSAnayc6XG4gICAgICAgICAgaWYgKCFyZXBlYXQpIHtcbiAgICAgICAgICAgIHNpbGVuY2VQcm9taXNlKHBsYXllci50b2dnbGVQbGF5KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICAgICAgcGxheWVyLmluY3JlYXNlVm9sdW1lKDAuMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAgICAgcGxheWVyLmRlY3JlYXNlVm9sdW1lKDAuMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgIGlmICghcmVwZWF0KSB7XG4gICAgICAgICAgICBwbGF5ZXIubXV0ZWQgPSAhcGxheWVyLm11dGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQXJyb3dSaWdodCc6XG4gICAgICAgICAgcGxheWVyLmZvcndhcmQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQXJyb3dMZWZ0JzpcbiAgICAgICAgICBwbGF5ZXIucmV3aW5kKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgIHBsYXllci5mdWxsc2NyZWVuLnRvZ2dsZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICBpZiAoIXJlcGVhdCkge1xuICAgICAgICAgICAgcGxheWVyLnRvZ2dsZUNhcHRpb25zKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICBwbGF5ZXIubG9vcCA9ICFwbGF5ZXIubG9vcDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gRXNjYXBlIGlzIGhhbmRsZSBuYXRpdmVseSB3aGVuIGluIGZ1bGwgc2NyZWVuXG4gICAgICAvLyBTbyB3ZSBvbmx5IG5lZWQgdG8gd29ycnkgYWJvdXQgbm9uIG5hdGl2ZVxuICAgICAgaWYgKGtleSA9PT0gJ0VzY2FwZScgJiYgIXBsYXllci5mdWxsc2NyZWVuLnVzaW5nTmF0aXZlICYmIHBsYXllci5mdWxsc2NyZWVuLmFjdGl2ZSkge1xuICAgICAgICBwbGF5ZXIuZnVsbHNjcmVlbi50b2dnbGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RvcmUgbGFzdCBrZXkgZm9yIG5leHQgY3ljbGVcbiAgICAgIHRoaXMubGFzdEtleSA9IGtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYXN0S2V5ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBUb2dnbGUgbWVudVxuICB0b2dnbGVNZW51KGV2ZW50KSB7XG4gICAgY29udHJvbHMudG9nZ2xlTWVudS5jYWxsKHRoaXMucGxheWVyLCBldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxudmFyIGxvYWRqc191bWQkMSA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBsb2FkanNfdW1kID0gbG9hZGpzX3VtZCQxLmV4cG9ydHM7XG52YXIgaGFzUmVxdWlyZWRMb2FkanNfdW1kO1xuZnVuY3Rpb24gcmVxdWlyZUxvYWRqc191bWQoKSB7XG4gIGlmIChoYXNSZXF1aXJlZExvYWRqc191bWQpIHJldHVybiBsb2FkanNfdW1kJDEuZXhwb3J0cztcbiAgaGFzUmVxdWlyZWRMb2FkanNfdW1kID0gMTtcbiAgKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAgIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgICB9XG4gICAgfSkobG9hZGpzX3VtZCwgZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBHbG9iYWwgZGVwZW5kZW5jaWVzLlxuICAgICAgICogQGdsb2JhbCB7T2JqZWN0fSBkb2N1bWVudCAtIERPTVxuICAgICAgICovXG5cbiAgICAgIHZhciBkZXZudWxsID0gZnVuY3Rpb24gKCkge30sXG4gICAgICAgIGJ1bmRsZUlkQ2FjaGUgPSB7fSxcbiAgICAgICAgYnVuZGxlUmVzdWx0Q2FjaGUgPSB7fSxcbiAgICAgICAgYnVuZGxlQ2FsbGJhY2tRdWV1ZSA9IHt9O1xuXG4gICAgICAvKipcbiAgICAgICAqIFN1YnNjcmliZSB0byBidW5kbGUgbG9hZCBldmVudC5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGJ1bmRsZUlkcyAtIEJ1bmRsZSBpZHNcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrRm4gLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gc3Vic2NyaWJlKGJ1bmRsZUlkcywgY2FsbGJhY2tGbikge1xuICAgICAgICAvLyBsaXN0aWZ5XG4gICAgICAgIGJ1bmRsZUlkcyA9IGJ1bmRsZUlkcy5wdXNoID8gYnVuZGxlSWRzIDogW2J1bmRsZUlkc107XG4gICAgICAgIHZhciBkZXBzTm90Rm91bmQgPSBbXSxcbiAgICAgICAgICBpID0gYnVuZGxlSWRzLmxlbmd0aCxcbiAgICAgICAgICBudW1XYWl0aW5nID0gaSxcbiAgICAgICAgICBmbixcbiAgICAgICAgICBidW5kbGVJZCxcbiAgICAgICAgICByLFxuICAgICAgICAgIHE7XG5cbiAgICAgICAgLy8gZGVmaW5lIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIGZuID0gZnVuY3Rpb24gKGJ1bmRsZUlkLCBwYXRoc05vdEZvdW5kKSB7XG4gICAgICAgICAgaWYgKHBhdGhzTm90Rm91bmQubGVuZ3RoKSBkZXBzTm90Rm91bmQucHVzaChidW5kbGVJZCk7XG4gICAgICAgICAgbnVtV2FpdGluZy0tO1xuICAgICAgICAgIGlmICghbnVtV2FpdGluZykgY2FsbGJhY2tGbihkZXBzTm90Rm91bmQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHJlZ2lzdGVyIGNhbGxiYWNrXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICBidW5kbGVJZCA9IGJ1bmRsZUlkc1tpXTtcblxuICAgICAgICAgIC8vIGV4ZWN1dGUgY2FsbGJhY2sgaWYgaW4gcmVzdWx0IGNhY2hlXG4gICAgICAgICAgciA9IGJ1bmRsZVJlc3VsdENhY2hlW2J1bmRsZUlkXTtcbiAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgZm4oYnVuZGxlSWQsIHIpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gYWRkIHRvIGNhbGxiYWNrIHF1ZXVlXG4gICAgICAgICAgcSA9IGJ1bmRsZUNhbGxiYWNrUXVldWVbYnVuZGxlSWRdID0gYnVuZGxlQ2FsbGJhY2tRdWV1ZVtidW5kbGVJZF0gfHwgW107XG4gICAgICAgICAgcS5wdXNoKGZuKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFB1Ymxpc2ggYnVuZGxlIGxvYWQgZXZlbnQuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYnVuZGxlSWQgLSBCdW5kbGUgaWRcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzTm90Rm91bmQgLSBMaXN0IG9mIGZpbGVzIG5vdCBmb3VuZFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBwdWJsaXNoKGJ1bmRsZUlkLCBwYXRoc05vdEZvdW5kKSB7XG4gICAgICAgIC8vIGV4aXQgaWYgaWQgaXNuJ3QgZGVmaW5lZFxuICAgICAgICBpZiAoIWJ1bmRsZUlkKSByZXR1cm47XG4gICAgICAgIHZhciBxID0gYnVuZGxlQ2FsbGJhY2tRdWV1ZVtidW5kbGVJZF07XG5cbiAgICAgICAgLy8gY2FjaGUgcmVzdWx0XG4gICAgICAgIGJ1bmRsZVJlc3VsdENhY2hlW2J1bmRsZUlkXSA9IHBhdGhzTm90Rm91bmQ7XG5cbiAgICAgICAgLy8gZXhpdCBpZiBxdWV1ZSBpcyBlbXB0eVxuICAgICAgICBpZiAoIXEpIHJldHVybjtcblxuICAgICAgICAvLyBlbXB0eSBjYWxsYmFjayBxdWV1ZVxuICAgICAgICB3aGlsZSAocS5sZW5ndGgpIHtcbiAgICAgICAgICBxWzBdKGJ1bmRsZUlkLCBwYXRoc05vdEZvdW5kKTtcbiAgICAgICAgICBxLnNwbGljZSgwLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEV4ZWN1dGUgY2FsbGJhY2tzLlxuICAgICAgICogQHBhcmFtIHtPYmplY3Qgb3IgRnVuY3Rpb259IGFyZ3MgLSBUaGUgY2FsbGJhY2sgYXJnc1xuICAgICAgICogQHBhcmFtIHtzdHJpbmdbXX0gZGVwc05vdEZvdW5kIC0gTGlzdCBvZiBkZXBlbmRlbmNpZXMgbm90IGZvdW5kXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGV4ZWN1dGVDYWxsYmFja3MoYXJncywgZGVwc05vdEZvdW5kKSB7XG4gICAgICAgIC8vIGFjY2VwdCBmdW5jdGlvbiBhcyBhcmd1bWVudFxuICAgICAgICBpZiAoYXJncy5jYWxsKSBhcmdzID0ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGFyZ3NcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzdWNjZXNzIGFuZCBlcnJvciBjYWxsYmFja3NcbiAgICAgICAgaWYgKGRlcHNOb3RGb3VuZC5sZW5ndGgpIChhcmdzLmVycm9yIHx8IGRldm51bGwpKGRlcHNOb3RGb3VuZCk7ZWxzZSAoYXJncy5zdWNjZXNzIHx8IGRldm51bGwpKGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIExvYWQgaW5kaXZpZHVhbCBmaWxlLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBUaGUgZmlsZSBwYXRoXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja0ZuIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGxvYWRGaWxlKHBhdGgsIGNhbGxiYWNrRm4sIGFyZ3MsIG51bVRyaWVzKSB7XG4gICAgICAgIHZhciBkb2MgPSBkb2N1bWVudCxcbiAgICAgICAgICBhc3luYyA9IGFyZ3MuYXN5bmMsXG4gICAgICAgICAgbWF4VHJpZXMgPSAoYXJncy5udW1SZXRyaWVzIHx8IDApICsgMSxcbiAgICAgICAgICBiZWZvcmVDYWxsYmFja0ZuID0gYXJncy5iZWZvcmUgfHwgZGV2bnVsbCxcbiAgICAgICAgICBwYXRobmFtZSA9IHBhdGgucmVwbGFjZSgvW1xcP3wjXS4qJC8sICcnKSxcbiAgICAgICAgICBwYXRoU3RyaXBwZWQgPSBwYXRoLnJlcGxhY2UoL14oY3NzfGltZ3xtb2R1bGV8bm9tb2R1bGUpIS8sICcnKSxcbiAgICAgICAgICBpc0xlZ2FjeUlFQ3NzLFxuICAgICAgICAgIGhhc01vZHVsZVN1cHBvcnQsXG4gICAgICAgICAgZTtcbiAgICAgICAgbnVtVHJpZXMgPSBudW1UcmllcyB8fCAwO1xuICAgICAgICBpZiAoLyheY3NzIXxcXC5jc3MkKS8udGVzdChwYXRobmFtZSkpIHtcbiAgICAgICAgICAvLyBjc3NcbiAgICAgICAgICBlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcbiAgICAgICAgICBlLnJlbCA9ICdzdHlsZXNoZWV0JztcbiAgICAgICAgICBlLmhyZWYgPSBwYXRoU3RyaXBwZWQ7XG5cbiAgICAgICAgICAvLyB0YWcgSUU5K1xuICAgICAgICAgIGlzTGVnYWN5SUVDc3MgPSAnaGlkZUZvY3VzJyBpbiBlO1xuXG4gICAgICAgICAgLy8gdXNlIHByZWxvYWQgaW4gSUUgRWRnZSAodG8gZGV0ZWN0IGxvYWQgZXJyb3JzKVxuICAgICAgICAgIGlmIChpc0xlZ2FjeUlFQ3NzICYmIGUucmVsTGlzdCkge1xuICAgICAgICAgICAgaXNMZWdhY3lJRUNzcyA9IDA7XG4gICAgICAgICAgICBlLnJlbCA9ICdwcmVsb2FkJztcbiAgICAgICAgICAgIGUuYXMgPSAnc3R5bGUnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgvKF5pbWchfFxcLihwbmd8Z2lmfGpwZ3xzdmd8d2VicCkkKS8udGVzdChwYXRobmFtZSkpIHtcbiAgICAgICAgICAvLyBpbWFnZVxuICAgICAgICAgIGUgPSBkb2MuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgICAgZS5zcmMgPSBwYXRoU3RyaXBwZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gamF2YXNjcmlwdFxuICAgICAgICAgIGUgPSBkb2MuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgZS5zcmMgPSBwYXRoU3RyaXBwZWQ7XG4gICAgICAgICAgZS5hc3luYyA9IGFzeW5jID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXN5bmM7XG5cbiAgICAgICAgICAvLyBoYW5kbGUgZXMgbW9kdWxlc1xuICAgICAgICAgIC8vIG1vZGVybiBicm93c2VyczpcbiAgICAgICAgICAvLyAgIG1vZHVsZTogYWRkIHRvIGRvbSB3aXRoIHR5cGU9XCJtb2R1bGVcIlxuICAgICAgICAgIC8vICAgbm9tb2R1bGU6IGNhbGwgc3VjY2VzcygpIGNhbGxiYWNrIHdpdGhvdXQgYWRkaW5nIHRvIGRvbVxuICAgICAgICAgIC8vIGxlZ2FjeSBicm93c2VyczpcbiAgICAgICAgICAvLyAgIG1vZHVsZTogY2FsbCBzdWNjZXNzKCkgY2FsbGJhY2sgd2l0aG91dCBhZGRpbmcgdG8gZG9tXG4gICAgICAgICAgLy8gICBub21vZHVsZTogYWRkIHRvIGRvbSB3aXRoIGRlZmF1bHQgdHlwZSAoXCJ0ZXh0L2phdmFzY3JpcHRcIilcbiAgICAgICAgICBoYXNNb2R1bGVTdXBwb3J0ID0gJ25vTW9kdWxlJyBpbiBlO1xuICAgICAgICAgIGlmICgvXm1vZHVsZSEvLnRlc3QocGF0aG5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoIWhhc01vZHVsZVN1cHBvcnQpIHJldHVybiBjYWxsYmFja0ZuKHBhdGgsICdsJyk7XG4gICAgICAgICAgICBlLnR5cGUgPSBcIm1vZHVsZVwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoL15ub21vZHVsZSEvLnRlc3QocGF0aG5hbWUpICYmIGhhc01vZHVsZVN1cHBvcnQpIHJldHVybiBjYWxsYmFja0ZuKHBhdGgsICdsJyk7XG4gICAgICAgIH1cbiAgICAgICAgZS5vbmxvYWQgPSBlLm9uZXJyb3IgPSBlLm9uYmVmb3JlbG9hZCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBldi50eXBlWzBdO1xuXG4gICAgICAgICAgLy8gdHJlYXQgZW1wdHkgc3R5bGVzaGVldHMgYXMgZmFpbHVyZXMgdG8gZ2V0IGFyb3VuZCBsYWNrIG9mIG9uZXJyb3JcbiAgICAgICAgICAvLyBzdXBwb3J0IGluIElFOS0xMVxuICAgICAgICAgIGlmIChpc0xlZ2FjeUlFQ3NzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoIWUuc2hlZXQuY3NzVGV4dC5sZW5ndGgpIHJlc3VsdCA9ICdlJztcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgLy8gc2hlZXRzIG9iamVjdHMgY3JlYXRlZCBmcm9tIGxvYWQgZXJyb3JzIGRvbid0IGFsbG93IGFjY2VzcyB0b1xuICAgICAgICAgICAgICAvLyBgY3NzVGV4dGAgKHVubGVzcyBlcnJvciBpcyBDb2RlOjE4IFNlY3VyaXR5RXJyb3IpXG4gICAgICAgICAgICAgIGlmICh4LmNvZGUgIT0gMTgpIHJlc3VsdCA9ICdlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBoYW5kbGUgcmV0cmllcyBpbiBjYXNlIG9mIGxvYWQgZmFpbHVyZVxuICAgICAgICAgIGlmIChyZXN1bHQgPT0gJ2UnKSB7XG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgY291bnRlclxuICAgICAgICAgICAgbnVtVHJpZXMgKz0gMTtcblxuICAgICAgICAgICAgLy8gZXhpdCBmdW5jdGlvbiBhbmQgdHJ5IGFnYWluXG4gICAgICAgICAgICBpZiAobnVtVHJpZXMgPCBtYXhUcmllcykge1xuICAgICAgICAgICAgICByZXR1cm4gbG9hZEZpbGUocGF0aCwgY2FsbGJhY2tGbiwgYXJncywgbnVtVHJpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZS5yZWwgPT0gJ3ByZWxvYWQnICYmIGUuYXMgPT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgLy8gYWN0aXZhdGUgcHJlbG9hZGVkIHN0eWxlc2hlZXRzXG4gICAgICAgICAgICByZXR1cm4gZS5yZWwgPSAnc3R5bGVzaGVldCc7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGV4ZWN1dGUgY2FsbGJhY2tcbiAgICAgICAgICBjYWxsYmFja0ZuKHBhdGgsIHJlc3VsdCwgZXYuZGVmYXVsdFByZXZlbnRlZCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gYWRkIHRvIGRvY3VtZW50ICh1bmxlc3MgY2FsbGJhY2sgcmV0dXJucyBgZmFsc2VgKVxuICAgICAgICBpZiAoYmVmb3JlQ2FsbGJhY2tGbihwYXRoLCBlKSAhPT0gZmFsc2UpIGRvYy5oZWFkLmFwcGVuZENoaWxkKGUpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIExvYWQgbXVsdGlwbGUgZmlsZXMuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyAtIFRoZSBmaWxlIHBhdGhzXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja0ZuIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGxvYWRGaWxlcyhwYXRocywgY2FsbGJhY2tGbiwgYXJncykge1xuICAgICAgICAvLyBsaXN0aWZ5IHBhdGhzXG4gICAgICAgIHBhdGhzID0gcGF0aHMucHVzaCA/IHBhdGhzIDogW3BhdGhzXTtcbiAgICAgICAgdmFyIG51bVdhaXRpbmcgPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgeCA9IG51bVdhaXRpbmcsXG4gICAgICAgICAgcGF0aHNOb3RGb3VuZCA9IFtdLFxuICAgICAgICAgIGZuLFxuICAgICAgICAgIGk7XG5cbiAgICAgICAgLy8gZGVmaW5lIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIGZuID0gZnVuY3Rpb24gKHBhdGgsIHJlc3VsdCwgZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIC8vIGhhbmRsZSBlcnJvclxuICAgICAgICAgIGlmIChyZXN1bHQgPT0gJ2UnKSBwYXRoc05vdEZvdW5kLnB1c2gocGF0aCk7XG5cbiAgICAgICAgICAvLyBoYW5kbGUgYmVmb3JlbG9hZCBldmVudC4gSWYgZGVmYXVsdFByZXZlbnRlZCB0aGVuIHRoYXQgbWVhbnMgdGhlIGxvYWRcbiAgICAgICAgICAvLyB3aWxsIGJlIGJsb2NrZWQgKGV4LiBHaG9zdGVyeS9BQlAgb24gU2FmYXJpKVxuICAgICAgICAgIGlmIChyZXN1bHQgPT0gJ2InKSB7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdFByZXZlbnRlZCkgcGF0aHNOb3RGb3VuZC5wdXNoKHBhdGgpO2Vsc2UgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBudW1XYWl0aW5nLS07XG4gICAgICAgICAgaWYgKCFudW1XYWl0aW5nKSBjYWxsYmFja0ZuKHBhdGhzTm90Rm91bmQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGxvYWQgc2NyaXB0c1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgeDsgaSsrKSBsb2FkRmlsZShwYXRoc1tpXSwgZm4sIGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEluaXRpYXRlIHNjcmlwdCBsb2FkIGFuZCByZWdpc3RlciBidW5kbGUuXG4gICAgICAgKiBAcGFyYW0geyhzdHJpbmd8c3RyaW5nW10pfSBwYXRocyAtIFRoZSBmaWxlIHBhdGhzXG4gICAgICAgKiBAcGFyYW0geyhzdHJpbmd8RnVuY3Rpb258T2JqZWN0KX0gW2FyZzFdIC0gVGhlICgxKSBidW5kbGVJZCBvciAoMikgc3VjY2Vzc1xuICAgICAgICogICBjYWxsYmFjayBvciAoMykgb2JqZWN0IGxpdGVyYWwgd2l0aCBzdWNjZXNzL2Vycm9yIGFyZ3VtZW50cywgbnVtUmV0cmllcyxcbiAgICAgICAqICAgZXRjLlxuICAgICAgICogQHBhcmFtIHsoRnVuY3Rpb258T2JqZWN0KX0gW2FyZzJdIC0gVGhlICgxKSBzdWNjZXNzIGNhbGxiYWNrIG9yICgyKSBvYmplY3RcbiAgICAgICAqICAgbGl0ZXJhbCB3aXRoIHN1Y2Nlc3MvZXJyb3IgYXJndW1lbnRzLCBudW1SZXRyaWVzLCBldGMuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGxvYWRqcyhwYXRocywgYXJnMSwgYXJnMikge1xuICAgICAgICB2YXIgYnVuZGxlSWQsIGFyZ3M7XG5cbiAgICAgICAgLy8gYnVuZGxlSWQgKGlmIHN0cmluZylcbiAgICAgICAgaWYgKGFyZzEgJiYgYXJnMS50cmltKSBidW5kbGVJZCA9IGFyZzE7XG5cbiAgICAgICAgLy8gYXJncyAoZGVmYXVsdCBpcyB7fSlcbiAgICAgICAgYXJncyA9IChidW5kbGVJZCA/IGFyZzIgOiBhcmcxKSB8fCB7fTtcblxuICAgICAgICAvLyB0aHJvdyBlcnJvciBpZiBidW5kbGUgaXMgYWxyZWFkeSBkZWZpbmVkXG4gICAgICAgIGlmIChidW5kbGVJZCkge1xuICAgICAgICAgIGlmIChidW5kbGVJZCBpbiBidW5kbGVJZENhY2hlKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkxvYWRKU1wiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidW5kbGVJZENhY2hlW2J1bmRsZUlkXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxvYWRGbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBsb2FkRmlsZXMocGF0aHMsIGZ1bmN0aW9uIChwYXRoc05vdEZvdW5kKSB7XG4gICAgICAgICAgICAvLyBleGVjdXRlIGNhbGxiYWNrc1xuICAgICAgICAgICAgZXhlY3V0ZUNhbGxiYWNrcyhhcmdzLCBwYXRoc05vdEZvdW5kKTtcblxuICAgICAgICAgICAgLy8gcmVzb2x2ZSBQcm9taXNlXG4gICAgICAgICAgICBpZiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICBleGVjdXRlQ2FsbGJhY2tzKHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgIGVycm9yOiByZWplY3RcbiAgICAgICAgICAgICAgfSwgcGF0aHNOb3RGb3VuZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHB1Ymxpc2ggYnVuZGxlIGxvYWQgZXZlbnRcbiAgICAgICAgICAgIHB1Ymxpc2goYnVuZGxlSWQsIHBhdGhzTm90Rm91bmQpO1xuICAgICAgICAgIH0sIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLnJldHVyblByb21pc2UpIHJldHVybiBuZXcgUHJvbWlzZShsb2FkRm4pO2Vsc2UgbG9hZEZuKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRXhlY3V0ZSBjYWxsYmFja3Mgd2hlbiBkZXBlbmRlbmNpZXMgaGF2ZSBiZWVuIHNhdGlzZmllZC5cbiAgICAgICAqIEBwYXJhbSB7KHN0cmluZ3xzdHJpbmdbXSl9IGRlcHMgLSBMaXN0IG9mIGJ1bmRsZSBpZHNcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIC0gc3VjY2Vzcy9lcnJvciBhcmd1bWVudHNcbiAgICAgICAqL1xuICAgICAgbG9hZGpzLnJlYWR5ID0gZnVuY3Rpb24gcmVhZHkoZGVwcywgYXJncykge1xuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gYnVuZGxlIGxvYWQgZXZlbnRcbiAgICAgICAgc3Vic2NyaWJlKGRlcHMsIGZ1bmN0aW9uIChkZXBzTm90Rm91bmQpIHtcbiAgICAgICAgICAvLyBleGVjdXRlIGNhbGxiYWNrc1xuICAgICAgICAgIGV4ZWN1dGVDYWxsYmFja3MoYXJncywgZGVwc05vdEZvdW5kKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsb2FkanM7XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIE1hbnVhbGx5IHNhdGlzZnkgYnVuZGxlIGRlcGVuZGVuY2llcy5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBidW5kbGVJZCAtIFRoZSBidW5kbGUgaWRcbiAgICAgICAqL1xuICAgICAgbG9hZGpzLmRvbmUgPSBmdW5jdGlvbiBkb25lKGJ1bmRsZUlkKSB7XG4gICAgICAgIHB1Ymxpc2goYnVuZGxlSWQsIFtdKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVzZXQgbG9hZGpzIGRlcGVuZGVuY2llcyBzdGF0dXNlc1xuICAgICAgICovXG4gICAgICBsb2FkanMucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgYnVuZGxlSWRDYWNoZSA9IHt9O1xuICAgICAgICBidW5kbGVSZXN1bHRDYWNoZSA9IHt9O1xuICAgICAgICBidW5kbGVDYWxsYmFja1F1ZXVlID0ge307XG4gICAgICB9O1xuXG4gICAgICAvKipcbiAgICAgICAqIERldGVybWluZSBpZiBidW5kbGUgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkXG4gICAgICAgKiBAcGFyYW0gU3RyaW5nfSBidW5kbGVJZCAtIFRoZSBidW5kbGUgaWRcbiAgICAgICAqL1xuICAgICAgbG9hZGpzLmlzRGVmaW5lZCA9IGZ1bmN0aW9uIGlzRGVmaW5lZChidW5kbGVJZCkge1xuICAgICAgICByZXR1cm4gYnVuZGxlSWQgaW4gYnVuZGxlSWRDYWNoZTtcbiAgICAgIH07XG5cbiAgICAgIC8vIGV4cG9ydFxuICAgICAgcmV0dXJuIGxvYWRqcztcbiAgICB9KTtcbiAgfSkobG9hZGpzX3VtZCQxKTtcbiAgcmV0dXJuIGxvYWRqc191bWQkMS5leHBvcnRzO1xufVxuXG52YXIgbG9hZGpzX3VtZEV4cG9ydHMgPSByZXF1aXJlTG9hZGpzX3VtZCgpO1xudmFyIGxvYWRqcyA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhsb2FkanNfdW1kRXhwb3J0cyk7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBMb2FkIGFuIGV4dGVybmFsIHNjcmlwdFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gbG9hZFNjcmlwdCh1cmwpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBsb2FkanModXJsLCB7XG4gICAgICBzdWNjZXNzOiByZXNvbHZlLFxuICAgICAgZXJyb3I6IHJlamVjdFxuICAgIH0pO1xuICB9KTtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFZpbWVvIHBsdWdpblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4vLyBQYXJzZSBWaW1lbyBJRCBmcm9tIFVSTFxuZnVuY3Rpb24gcGFyc2VJZCQxKHVybCkge1xuICBpZiAoaXMuZW1wdHkodXJsKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChpcy5udW1iZXIoTnVtYmVyKHVybCkpKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvb3B0aW1hbC1xdWFudGlmaWVyLWNvbmNhdGVuYXRpb25cbiAgY29uc3QgcmVnZXggPSAvXi4qKHZpbWVvLmNvbVxcL3x2aWRlb1xcLykoXFxkKykuKi87XG4gIGNvbnN0IG1hdGNoID0gdXJsLm1hdGNoKHJlZ2V4KTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMl0gOiB1cmw7XG59XG5cbi8vIFRyeSB0byBleHRyYWN0IGEgaGFzaCBmb3IgcHJpdmF0ZSB2aWRlb3MgZnJvbSB0aGUgVVJMXG5mdW5jdGlvbiBwYXJzZUhhc2godXJsKSB7XG4gIC8qIFRoaXMgcmVnZXggbWF0Y2hlcyBhIGhleGFkZWNpbWFsIGhhc2ggaWYgZ2l2ZW4gaW4gYW55IG9mIHRoZXNlIGZvcm1zOlxuICAgKiAgLSBbaHR0cHM6Ly9wbGF5ZXIuXXZpbWVvLmNvbS92aWRlby97aWR9L3toYXNofVs/cGFyYW1zXVxuICAgKiAgLSBbaHR0cHM6Ly9wbGF5ZXIuXXZpbWVvLmNvbS92aWRlby97aWR9P2g9e2hhc2h9WyZwYXJhbXNdXG4gICAqICAtIFtodHRwczovL3BsYXllci5ddmltZW8uY29tL3ZpZGVvL3tpZH0/W3BhcmFtc10maD17aGFzaH1cbiAgICogIC0gdmlkZW8ve2lkfS97aGFzaH1cbiAgICogSWYgbWF0Y2hlZCwgdGhlIGhhc2ggaXMgYXZhaWxhYmxlIGluIGNhcHR1cmUgZ3JvdXAgNFxuICAgKi9cbiAgY29uc3QgcmVnZXggPSAvXi4qKHZpbWVvLmNvbVxcL3x2aWRlb1xcLykoXFxkKykoXFw/LipoPXxcXC8pKyhbXFxkLGEtZl0rKS87XG4gIGNvbnN0IGZvdW5kID0gdXJsLm1hdGNoKHJlZ2V4KTtcbiAgcmV0dXJuIGZvdW5kICYmIGZvdW5kLmxlbmd0aCA9PT0gNSA/IGZvdW5kWzRdIDogbnVsbDtcbn1cblxuLy8gU2V0IHBsYXliYWNrIHN0YXRlIGFuZCB0cmlnZ2VyIGNoYW5nZSAob25seSBvbiBhY3R1YWwgY2hhbmdlKVxuZnVuY3Rpb24gYXNzdXJlUGxheWJhY2tTdGF0ZSQxKHBsYXkpIHtcbiAgaWYgKHBsYXkgJiYgIXRoaXMuZW1iZWQuaGFzUGxheWVkKSB7XG4gICAgdGhpcy5lbWJlZC5oYXNQbGF5ZWQgPSB0cnVlO1xuICB9XG4gIGlmICh0aGlzLm1lZGlhLnBhdXNlZCA9PT0gcGxheSkge1xuICAgIHRoaXMubWVkaWEucGF1c2VkID0gIXBsYXk7XG4gICAgdHJpZ2dlckV2ZW50LmNhbGwodGhpcywgdGhpcy5tZWRpYSwgcGxheSA/ICdwbGF5JyA6ICdwYXVzZScpO1xuICB9XG59XG5jb25zdCB2aW1lbyA9IHtcbiAgc2V0dXAoKSB7XG4gICAgY29uc3QgcGxheWVyID0gdGhpcztcblxuICAgIC8vIEFkZCBlbWJlZCBjbGFzcyBmb3IgcmVzcG9uc2l2ZVxuICAgIHRvZ2dsZUNsYXNzKHBsYXllci5lbGVtZW50cy53cmFwcGVyLCBwbGF5ZXIuY29uZmlnLmNsYXNzTmFtZXMuZW1iZWQsIHRydWUpO1xuXG4gICAgLy8gU2V0IHNwZWVkIG9wdGlvbnMgZnJvbSBjb25maWdcbiAgICBwbGF5ZXIub3B0aW9ucy5zcGVlZCA9IHBsYXllci5jb25maWcuc3BlZWQub3B0aW9ucztcblxuICAgIC8vIFNldCBpbml0aWFsIHJhdGlvXG4gICAgc2V0QXNwZWN0UmF0aW8uY2FsbChwbGF5ZXIpO1xuXG4gICAgLy8gTG9hZCB0aGUgU0RLIGlmIG5vdCBhbHJlYWR5XG4gICAgaWYgKCFpcy5vYmplY3Qod2luZG93LlZpbWVvKSkge1xuICAgICAgbG9hZFNjcmlwdChwbGF5ZXIuY29uZmlnLnVybHMudmltZW8uc2RrKS50aGVuKCgpID0+IHtcbiAgICAgICAgdmltZW8ucmVhZHkuY2FsbChwbGF5ZXIpO1xuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICBwbGF5ZXIuZGVidWcud2FybignVmltZW8gU0RLIChwbGF5ZXIuanMpIGZhaWxlZCB0byBsb2FkJywgZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpbWVvLnJlYWR5LmNhbGwocGxheWVyKTtcbiAgICB9XG4gIH0sXG4gIC8vIEFQSSBSZWFkeVxuICByZWFkeSgpIHtcbiAgICBjb25zdCBwbGF5ZXIgPSB0aGlzO1xuICAgIGNvbnN0IGNvbmZpZyA9IHBsYXllci5jb25maWcudmltZW87XG4gICAgY29uc3Qge1xuICAgICAgcHJlbWl1bSxcbiAgICAgIHJlZmVycmVyUG9saWN5LFxuICAgICAgLi4uZnJhbWVQYXJhbXNcbiAgICB9ID0gY29uZmlnO1xuICAgIC8vIEdldCB0aGUgc291cmNlIFVSTCBvciBJRFxuICAgIGxldCBzb3VyY2UgPSBwbGF5ZXIubWVkaWEuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgICBsZXQgaGFzaCA9ICcnO1xuICAgIC8vIEdldCBmcm9tIDxkaXY+IGlmIG5lZWRlZFxuICAgIGlmIChpcy5lbXB0eShzb3VyY2UpKSB7XG4gICAgICBzb3VyY2UgPSBwbGF5ZXIubWVkaWEuZ2V0QXR0cmlidXRlKHBsYXllci5jb25maWcuYXR0cmlidXRlcy5lbWJlZC5pZCk7XG4gICAgICAvLyBoYXNoIGNhbiBhbHNvIGJlIHNldCBhcyBhdHRyaWJ1dGUgb24gdGhlIDxkaXY+XG4gICAgICBoYXNoID0gcGxheWVyLm1lZGlhLmdldEF0dHJpYnV0ZShwbGF5ZXIuY29uZmlnLmF0dHJpYnV0ZXMuZW1iZWQuaGFzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhc2ggPSBwYXJzZUhhc2goc291cmNlKTtcbiAgICB9XG4gICAgY29uc3QgaGFzaFBhcmFtID0gaGFzaCA/IHtcbiAgICAgIGg6IGhhc2hcbiAgICB9IDoge307XG5cbiAgICAvLyBJZiB0aGUgb3duZXIgaGFzIGEgcHJvIG9yIHByZW1pdW0gYWNjb3VudCB0aGVuIHdlIGNhbiBoaWRlIGNvbnRyb2xzIGV0Y1xuICAgIGlmIChwcmVtaXVtKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGZyYW1lUGFyYW1zLCB7XG4gICAgICAgIGNvbnRyb2xzOiBmYWxzZSxcbiAgICAgICAgc2lkZWRvY2s6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBHZXQgVmltZW8gcGFyYW1zIGZvciB0aGUgaWZyYW1lXG4gICAgY29uc3QgcGFyYW1zID0gYnVpbGRVcmxQYXJhbXMoe1xuICAgICAgbG9vcDogcGxheWVyLmNvbmZpZy5sb29wLmFjdGl2ZSxcbiAgICAgIGF1dG9wbGF5OiBwbGF5ZXIuYXV0b3BsYXksXG4gICAgICBtdXRlZDogcGxheWVyLm11dGVkLFxuICAgICAgZ2VzdHVyZTogJ21lZGlhJyxcbiAgICAgIHBsYXlzaW5saW5lOiBwbGF5ZXIuY29uZmlnLnBsYXlzaW5saW5lLFxuICAgICAgLy8gaGFzaCBoYXMgdG8gYmUgYWRkZWQgdG8gaWZyYW1lLVVSTFxuICAgICAgLi4uaGFzaFBhcmFtLFxuICAgICAgLi4uZnJhbWVQYXJhbXNcbiAgICB9KTtcbiAgICBjb25zdCBpZCA9IHBhcnNlSWQkMShzb3VyY2UpO1xuICAgIC8vIEJ1aWxkIGFuIGlmcmFtZVxuICAgIGNvbnN0IGlmcmFtZSA9IGNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGNvbnN0IHNyYyA9IGZvcm1hdChwbGF5ZXIuY29uZmlnLnVybHMudmltZW8uaWZyYW1lLCBpZCwgcGFyYW1zKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdzcmMnLCBzcmMpO1xuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2FsbG93ZnVsbHNjcmVlbicsICcnKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdhbGxvdycsIFsnYXV0b3BsYXknLCAnZnVsbHNjcmVlbicsICdwaWN0dXJlLWluLXBpY3R1cmUnLCAnZW5jcnlwdGVkLW1lZGlhJywgJ2FjY2VsZXJvbWV0ZXInLCAnZ3lyb3Njb3BlJ10uam9pbignOyAnKSk7XG5cbiAgICAvLyBTZXQgdGhlIHJlZmVycmVyIHBvbGljeSBpZiByZXF1aXJlZFxuICAgIGlmICghaXMuZW1wdHkocmVmZXJyZXJQb2xpY3kpKSB7XG4gICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdyZWZlcnJlclBvbGljeScsIHJlZmVycmVyUG9saWN5KTtcbiAgICB9XG5cbiAgICAvLyBJbmplY3QgdGhlIHBhY2thZ2VcbiAgICBpZiAocHJlbWl1bSB8fCAhY29uZmlnLmN1c3RvbUNvbnRyb2xzKSB7XG4gICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdkYXRhLXBvc3RlcicsIHBsYXllci5wb3N0ZXIpO1xuICAgICAgcGxheWVyLm1lZGlhID0gcmVwbGFjZUVsZW1lbnQoaWZyYW1lLCBwbGF5ZXIubWVkaWEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3cmFwcGVyID0gY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICAnY2xhc3MnOiBwbGF5ZXIuY29uZmlnLmNsYXNzTmFtZXMuZW1iZWRDb250YWluZXIsXG4gICAgICAgICdkYXRhLXBvc3Rlcic6IHBsYXllci5wb3N0ZXJcbiAgICAgIH0pO1xuICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgcGxheWVyLm1lZGlhID0gcmVwbGFjZUVsZW1lbnQod3JhcHBlciwgcGxheWVyLm1lZGlhKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgcG9zdGVyIGltYWdlXG4gICAgaWYgKCFjb25maWcuY3VzdG9tQ29udHJvbHMpIHtcbiAgICAgIGZldGNoKGZvcm1hdChwbGF5ZXIuY29uZmlnLnVybHMudmltZW8uYXBpLCBzcmMpKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgaWYgKGlzLmVtcHR5KHJlc3BvbnNlKSB8fCAhcmVzcG9uc2UudGh1bWJuYWlsX3VybCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCBhbmQgc2hvdyBwb3N0ZXJcbiAgICAgICAgdWkuc2V0UG9zdGVyLmNhbGwocGxheWVyLCByZXNwb25zZS50aHVtYm5haWxfdXJsKS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTZXR1cCBpbnN0YW5jZVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92aW1lby9wbGF5ZXIuanNcbiAgICBwbGF5ZXIuZW1iZWQgPSBuZXcgd2luZG93LlZpbWVvLlBsYXllcihpZnJhbWUsIHtcbiAgICAgIGF1dG9wYXVzZTogcGxheWVyLmNvbmZpZy5hdXRvcGF1c2UsXG4gICAgICBtdXRlZDogcGxheWVyLm11dGVkXG4gICAgfSk7XG4gICAgcGxheWVyLm1lZGlhLnBhdXNlZCA9IHRydWU7XG4gICAgcGxheWVyLm1lZGlhLmN1cnJlbnRUaW1lID0gMDtcblxuICAgIC8vIERpc2FibGUgbmF0aXZlIHRleHQgdHJhY2sgcmVuZGVyaW5nXG4gICAgaWYgKHBsYXllci5zdXBwb3J0ZWQudWkpIHtcbiAgICAgIHBsYXllci5lbWJlZC5kaXNhYmxlVGV4dFRyYWNrKCk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgZmF1eCBIVE1MNSBBUEkgdXNpbmcgdGhlIFZpbWVvIEFQSVxuICAgIHBsYXllci5tZWRpYS5wbGF5ID0gKCkgPT4ge1xuICAgICAgYXNzdXJlUGxheWJhY2tTdGF0ZSQxLmNhbGwocGxheWVyLCB0cnVlKTtcbiAgICAgIHJldHVybiBwbGF5ZXIuZW1iZWQucGxheSgpO1xuICAgIH07XG4gICAgcGxheWVyLm1lZGlhLnBhdXNlID0gKCkgPT4ge1xuICAgICAgYXNzdXJlUGxheWJhY2tTdGF0ZSQxLmNhbGwocGxheWVyLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcGxheWVyLmVtYmVkLnBhdXNlKCk7XG4gICAgfTtcbiAgICBwbGF5ZXIubWVkaWEuc3RvcCA9ICgpID0+IHtcbiAgICAgIHBsYXllci5wYXVzZSgpO1xuICAgICAgcGxheWVyLmN1cnJlbnRUaW1lID0gMDtcbiAgICB9O1xuXG4gICAgLy8gU2Vla2luZ1xuICAgIGxldCB7XG4gICAgICBjdXJyZW50VGltZVxuICAgIH0gPSBwbGF5ZXIubWVkaWE7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBsYXllci5tZWRpYSwgJ2N1cnJlbnRUaW1lJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gY3VycmVudFRpbWU7XG4gICAgICB9LFxuICAgICAgc2V0KHRpbWUpIHtcbiAgICAgICAgLy8gVmltZW8gd2lsbCBhdXRvbWF0aWNhbGx5IHBsYXkgb24gc2VlayBpZiB0aGUgdmlkZW8gaGFzbid0IGJlZW4gcGxheWVkIGJlZm9yZVxuXG4gICAgICAgIC8vIEdldCBjdXJyZW50IHBhdXNlZCBzdGF0ZSBhbmQgdm9sdW1lIGV0Y1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZW1iZWQsXG4gICAgICAgICAgbWVkaWEsXG4gICAgICAgICAgcGF1c2VkLFxuICAgICAgICAgIHZvbHVtZVxuICAgICAgICB9ID0gcGxheWVyO1xuICAgICAgICBjb25zdCByZXN0b3JlUGF1c2UgPSBwYXVzZWQgJiYgIWVtYmVkLmhhc1BsYXllZDtcblxuICAgICAgICAvLyBTZXQgc2Vla2luZyBzdGF0ZSBhbmQgdHJpZ2dlciBldmVudFxuICAgICAgICBtZWRpYS5zZWVraW5nID0gdHJ1ZTtcbiAgICAgICAgdHJpZ2dlckV2ZW50LmNhbGwocGxheWVyLCBtZWRpYSwgJ3NlZWtpbmcnKTtcblxuICAgICAgICAvLyBJZiBwYXVzZWQsIG11dGUgdW50aWwgc2VlayBpcyBjb21wbGV0ZVxuICAgICAgICBQcm9taXNlLnJlc29sdmUocmVzdG9yZVBhdXNlICYmIGVtYmVkLnNldFZvbHVtZSgwKSlcbiAgICAgICAgLy8gU2Vla1xuICAgICAgICAudGhlbigoKSA9PiBlbWJlZC5zZXRDdXJyZW50VGltZSh0aW1lKSlcbiAgICAgICAgLy8gUmVzdG9yZSBwYXVzZWRcbiAgICAgICAgLnRoZW4oKCkgPT4gcmVzdG9yZVBhdXNlICYmIGVtYmVkLnBhdXNlKCkpXG4gICAgICAgIC8vIFJlc3RvcmUgdm9sdW1lXG4gICAgICAgIC50aGVuKCgpID0+IHJlc3RvcmVQYXVzZSAmJiBlbWJlZC5zZXRWb2x1bWUodm9sdW1lKSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIC8vIERvIG5vdGhpbmdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBQbGF5YmFjayBzcGVlZFxuICAgIGxldCBzcGVlZCA9IHBsYXllci5jb25maWcuc3BlZWQuc2VsZWN0ZWQ7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBsYXllci5tZWRpYSwgJ3BsYXliYWNrUmF0ZScsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHNwZWVkO1xuICAgICAgfSxcbiAgICAgIHNldChpbnB1dCkge1xuICAgICAgICBwbGF5ZXIuZW1iZWQuc2V0UGxheWJhY2tSYXRlKGlucHV0KS50aGVuKCgpID0+IHtcbiAgICAgICAgICBzcGVlZCA9IGlucHV0O1xuICAgICAgICAgIHRyaWdnZXJFdmVudC5jYWxsKHBsYXllciwgcGxheWVyLm1lZGlhLCAncmF0ZWNoYW5nZScpO1xuICAgICAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgLy8gQ2Fubm90IHNldCBQbGF5YmFjayBSYXRlLCBWaWRlbyBpcyBwcm9iYWJseSBub3Qgb24gUHJvIGFjY291bnRcbiAgICAgICAgICBwbGF5ZXIub3B0aW9ucy5zcGVlZCA9IFsxXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBWb2x1bWVcbiAgICBsZXQge1xuICAgICAgdm9sdW1lXG4gICAgfSA9IHBsYXllci5jb25maWc7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBsYXllci5tZWRpYSwgJ3ZvbHVtZScsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHZvbHVtZTtcbiAgICAgIH0sXG4gICAgICBzZXQoaW5wdXQpIHtcbiAgICAgICAgcGxheWVyLmVtYmVkLnNldFZvbHVtZShpbnB1dCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgdm9sdW1lID0gaW5wdXQ7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50LmNhbGwocGxheWVyLCBwbGF5ZXIubWVkaWEsICd2b2x1bWVjaGFuZ2UnKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBNdXRlZFxuICAgIGxldCB7XG4gICAgICBtdXRlZFxuICAgIH0gPSBwbGF5ZXIuY29uZmlnO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwbGF5ZXIubWVkaWEsICdtdXRlZCcsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIG11dGVkO1xuICAgICAgfSxcbiAgICAgIHNldChpbnB1dCkge1xuICAgICAgICBjb25zdCB0b2dnbGUgPSBpcy5ib29sZWFuKGlucHV0KSA/IGlucHV0IDogZmFsc2U7XG4gICAgICAgIHBsYXllci5lbWJlZC5zZXRNdXRlZCh0b2dnbGUgPyB0cnVlIDogcGxheWVyLmNvbmZpZy5tdXRlZCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgbXV0ZWQgPSB0b2dnbGU7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50LmNhbGwocGxheWVyLCBwbGF5ZXIubWVkaWEsICd2b2x1bWVjaGFuZ2UnKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMb29wXG4gICAgbGV0IHtcbiAgICAgIGxvb3BcbiAgICB9ID0gcGxheWVyLmNvbmZpZztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGxheWVyLm1lZGlhLCAnbG9vcCcsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGxvb3A7XG4gICAgICB9LFxuICAgICAgc2V0KGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHRvZ2dsZSA9IGlzLmJvb2xlYW4oaW5wdXQpID8gaW5wdXQgOiBwbGF5ZXIuY29uZmlnLmxvb3AuYWN0aXZlO1xuICAgICAgICBwbGF5ZXIuZW1iZWQuc2V0TG9vcCh0b2dnbGUpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGxvb3AgPSB0b2dnbGU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU291cmNlXG4gICAgbGV0IGN1cnJlbnRTcmM7XG4gICAgcGxheWVyLmVtYmVkLmdldFZpZGVvVXJsKCkudGhlbih2YWx1ZSA9PiB7XG4gICAgICBjdXJyZW50U3JjID0gdmFsdWU7XG4gICAgICBjb250cm9scy5zZXREb3dubG9hZFVybC5jYWxsKHBsYXllcik7XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgdGhpcy5kZWJ1Zy53YXJuKGVycm9yKTtcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGxheWVyLm1lZGlhLCAnY3VycmVudFNyYycsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRTcmM7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBFbmRlZFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwbGF5ZXIubWVkaWEsICdlbmRlZCcsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHBsYXllci5jdXJyZW50VGltZSA9PT0gcGxheWVyLmR1cmF0aW9uO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU2V0IGFzcGVjdCByYXRpbyBiYXNlZCBvbiB2aWRlbyBzaXplXG4gICAgUHJvbWlzZS5hbGwoW3BsYXllci5lbWJlZC5nZXRWaWRlb1dpZHRoKCksIHBsYXllci5lbWJlZC5nZXRWaWRlb0hlaWdodCgpXSkudGhlbihkaW1lbnNpb25zID0+IHtcbiAgICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IGRpbWVuc2lvbnM7XG4gICAgICBwbGF5ZXIuZW1iZWQucmF0aW8gPSByb3VuZEFzcGVjdFJhdGlvKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgc2V0QXNwZWN0UmF0aW8uY2FsbCh0aGlzKTtcbiAgICB9KTtcblxuICAgIC8vIFNldCBhdXRvcGF1c2VcbiAgICBwbGF5ZXIuZW1iZWQuc2V0QXV0b3BhdXNlKHBsYXllci5jb25maWcuYXV0b3BhdXNlKS50aGVuKHN0YXRlID0+IHtcbiAgICAgIHBsYXllci5jb25maWcuYXV0b3BhdXNlID0gc3RhdGU7XG4gICAgfSk7XG5cbiAgICAvLyBHZXQgdGl0bGVcbiAgICBwbGF5ZXIuZW1iZWQuZ2V0VmlkZW9UaXRsZSgpLnRoZW4odGl0bGUgPT4ge1xuICAgICAgcGxheWVyLmNvbmZpZy50aXRsZSA9IHRpdGxlO1xuICAgICAgdWkuc2V0VGl0bGUuY2FsbCh0aGlzKTtcbiAgICB9KTtcblxuICAgIC8vIEdldCBjdXJyZW50IHRpbWVcbiAgICBwbGF5ZXIuZW1iZWQuZ2V0Q3VycmVudFRpbWUoKS50aGVuKHZhbHVlID0+IHtcbiAgICAgIGN1cnJlbnRUaW1lID0gdmFsdWU7XG4gICAgICB0cmlnZ2VyRXZlbnQuY2FsbChwbGF5ZXIsIHBsYXllci5tZWRpYSwgJ3RpbWV1cGRhdGUnKTtcbiAgICB9KTtcblxuICAgIC8vIEdldCBkdXJhdGlvblxuICAgIHBsYXllci5lbWJlZC5nZXREdXJhdGlvbigpLnRoZW4odmFsdWUgPT4ge1xuICAgICAgcGxheWVyLm1lZGlhLmR1cmF0aW9uID0gdmFsdWU7XG4gICAgICB0cmlnZ2VyRXZlbnQuY2FsbChwbGF5ZXIsIHBsYXllci5tZWRpYSwgJ2R1cmF0aW9uY2hhbmdlJyk7XG4gICAgfSk7XG5cbiAgICAvLyBHZXQgY2FwdGlvbnNcbiAgICBwbGF5ZXIuZW1iZWQuZ2V0VGV4dFRyYWNrcygpLnRoZW4odHJhY2tzID0+IHtcbiAgICAgIHBsYXllci5tZWRpYS50ZXh0VHJhY2tzID0gdHJhY2tzO1xuICAgICAgY2FwdGlvbnMuc2V0dXAuY2FsbChwbGF5ZXIpO1xuICAgIH0pO1xuICAgIHBsYXllci5lbWJlZC5vbignY3VlY2hhbmdlJywgKHtcbiAgICAgIGN1ZXMgPSBbXVxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IHN0cmlwcGVkQ3VlcyA9IGN1ZXMubWFwKGN1ZSA9PiBzdHJpcEhUTUwoY3VlLnRleHQpKTtcbiAgICAgIGNhcHRpb25zLnVwZGF0ZUN1ZXMuY2FsbChwbGF5ZXIsIHN0cmlwcGVkQ3Vlcyk7XG4gICAgfSk7XG4gICAgcGxheWVyLmVtYmVkLm9uKCdsb2FkZWQnLCAoKSA9PiB7XG4gICAgICAvLyBBc3N1cmUgc3RhdGUgYW5kIGV2ZW50cyBhcmUgdXBkYXRlZCBvbiBhdXRvcGxheVxuICAgICAgcGxheWVyLmVtYmVkLmdldFBhdXNlZCgpLnRoZW4ocGF1c2VkID0+IHtcbiAgICAgICAgYXNzdXJlUGxheWJhY2tTdGF0ZSQxLmNhbGwocGxheWVyLCAhcGF1c2VkKTtcbiAgICAgICAgaWYgKCFwYXVzZWQpIHtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnQuY2FsbChwbGF5ZXIsIHBsYXllci5tZWRpYSwgJ3BsYXlpbmcnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoaXMuZWxlbWVudChwbGF5ZXIuZW1iZWQuZWxlbWVudCkgJiYgcGxheWVyLnN1cHBvcnRlZC51aSkge1xuICAgICAgICBjb25zdCBmcmFtZSA9IHBsYXllci5lbWJlZC5lbGVtZW50O1xuXG4gICAgICAgIC8vIEZpeCBrZXlib2FyZCBmb2N1cyBpc3N1ZXNcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NhbXBvdHRzL3BseXIvaXNzdWVzLzMxN1xuICAgICAgICBmcmFtZS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgLTEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHBsYXllci5lbWJlZC5vbignYnVmZmVyc3RhcnQnLCAoKSA9PiB7XG4gICAgICB0cmlnZ2VyRXZlbnQuY2FsbChwbGF5ZXIsIHBsYXllci5tZWRpYSwgJ3dhaXRpbmcnKTtcbiAgICB9KTtcbiAgICBwbGF5ZXIuZW1iZWQub24oJ2J1ZmZlcmVuZCcsICgpID0+IHtcbiAgICAgIHRyaWdnZXJFdmVudC5jYWxsKHBsYXllciwgcGxheWVyLm1lZGlhLCAncGxheWluZycpO1xuICAgIH0pO1xuICAgIHBsYXllci5lbWJlZC5vbigncGxheScsICgpID0+IHtcbiAgICAgIGFzc3VyZVBsYXliYWNrU3RhdGUkMS5jYWxsKHBsYXllciwgdHJ1ZSk7XG4gICAgICB0cmlnZ2VyRXZlbnQuY2FsbChwbGF5ZXIsIHBsYXllci5tZWRpYSwgJ3BsYXlpbmcnKTtcbiAgICB9KTtcbiAgICBwbGF5ZXIuZW1iZWQub24oJ3BhdXNlJywgKCkgPT4ge1xuICAgICAgYXNzdXJlUGxheWJhY2tTdGF0ZSQxLmNhbGwocGxheWVyLCBmYWxzZSk7XG4gICAgfSk7XG4gICAgcGxheWVyLmVtYmVkLm9uKCd0aW1ldXBkYXRlJywgZGF0YSA9PiB7XG4gICAgICBwbGF5ZXIubWVkaWEuc2Vla2luZyA9IGZhbHNlO1xuICAgICAgY3VycmVudFRpbWUgPSBkYXRhLnNlY29uZHM7XG4gICAgICB0cmlnZ2VyRXZlbnQuY2FsbChwbGF5ZXIsIHBsYXllci5tZWRpYSwgJ3RpbWV1cGRhdGUnKTtcbiAgICB9KTtcbiAgICBwbGF5ZXIuZW1iZWQub24oJ3Byb2dyZXNzJywgZGF0YSA9PiB7XG4gICAgICBwbGF5ZXIubWVkaWEuYnVmZmVyZWQgPSBkYXRhLnBlcmNlbnQ7XG4gICAgICB0cmlnZ2VyRXZlbnQuY2FsbChwbGF5ZXIsIHBsYXllci5tZWRpYSwgJ3Byb2dyZXNzJyk7XG5cbiAgICAgIC8vIENoZWNrIGFsbCBsb2FkZWRcbiAgICAgIGlmIChOdW1iZXIucGFyc2VJbnQoZGF0YS5wZXJjZW50LCAxMCkgPT09IDEpIHtcbiAgICAgICAgdHJpZ2dlckV2ZW50LmNhbGwocGxheWVyLCBwbGF5ZXIubWVkaWEsICdjYW5wbGF5dGhyb3VnaCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgZHVyYXRpb24gYXMgaWYgd2UgZG8gaXQgYmVmb3JlIGxvYWQsIGl0IGdpdmVzIGFuIGluY29ycmVjdCB2YWx1ZVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NhbXBvdHRzL3BseXIvaXNzdWVzLzg5MVxuICAgICAgcGxheWVyLmVtYmVkLmdldER1cmF0aW9uKCkudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gcGxheWVyLm1lZGlhLmR1cmF0aW9uKSB7XG4gICAgICAgICAgcGxheWVyLm1lZGlhLmR1cmF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50LmNhbGwocGxheWVyLCBwbGF5ZXIubWVkaWEsICdkdXJhdGlvbmNoYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBwbGF5ZXIuZW1iZWQub24oJ3NlZWtlZCcsICgpID0+IHtcbiAgICAgIHBsYXllci5tZWRpYS5zZWVraW5nID0gZmFsc2U7XG4gICAgICB0cmlnZ2VyRXZlbnQuY2FsbChwbGF5ZXIsIHBsYXllci5tZWRpYSwgJ3NlZWtlZCcpO1xuICAgIH0pO1xuICAgIHBsYXllci5lbWJlZC5vbignZW5kZWQnLCAoKSA9PiB7XG4gICAgICBwbGF5ZXIubWVkaWEucGF1c2VkID0gdHJ1ZTtcbiAgICAgIHRyaWdnZXJFdmVudC5jYWxsKHBsYXllciwgcGxheWVyLm1lZGlhLCAnZW5kZWQnKTtcbiAgICB9KTtcbiAgICBwbGF5ZXIuZW1iZWQub24oJ2Vycm9yJywgZGV0YWlsID0+IHtcbiAgICAgIHBsYXllci5tZWRpYS5lcnJvciA9IGRldGFpbDtcbiAgICAgIHRyaWdnZXJFdmVudC5jYWxsKHBsYXllciwgcGxheWVyLm1lZGlhLCAnZXJyb3InKTtcbiAgICB9KTtcblxuICAgIC8vIFJlYnVpbGQgVUlcbiAgICBpZiAoY29uZmlnLmN1c3RvbUNvbnRyb2xzKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHVpLmJ1aWxkLmNhbGwocGxheWVyKSwgMCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gWW91VHViZSBwbHVnaW5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuLy8gUGFyc2UgWW91VHViZSBJRCBmcm9tIFVSTFxuZnVuY3Rpb24gcGFyc2VJZCh1cmwpIHtcbiAgaWYgKGlzLmVtcHR5KHVybCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCByZWdleCA9IC9eLiooeW91dHUuYmVcXC98dlxcL3x1XFwvXFx3XFwvfGVtYmVkXFwvfHdhdGNoXFw/dj18JnY9KShbXiMmP10qKS4qLztcbiAgY29uc3QgbWF0Y2ggPSB1cmwubWF0Y2gocmVnZXgpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMl0gPyBtYXRjaFsyXSA6IHVybDtcbn1cblxuLy8gU2V0IHBsYXliYWNrIHN0YXRlIGFuZCB0cmlnZ2VyIGNoYW5nZSAob25seSBvbiBhY3R1YWwgY2hhbmdlKVxuZnVuY3Rpb24gYXNzdXJlUGxheWJhY2tTdGF0ZShwbGF5KSB7XG4gIGlmIChwbGF5ICYmICF0aGlzLmVtYmVkLmhhc1BsYXllZCkge1xuICAgIHRoaXMuZW1iZWQuaGFzUGxheWVkID0gdHJ1ZTtcbiAgfVxuICBpZiAodGhpcy5tZWRpYS5wYXVzZWQgPT09IHBsYXkpIHtcbiAgICB0aGlzLm1lZGlhLnBhdXNlZCA9ICFwbGF5O1xuICAgIHRyaWdnZXJFdmVudC5jYWxsKHRoaXMsIHRoaXMubWVkaWEsIHBsYXkgPyAncGxheScgOiAncGF1c2UnKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0SG9zdChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5ub0Nvb2tpZSkge1xuICAgIHJldHVybiAnaHR0cHM6Ly93d3cueW91dHViZS1ub2Nvb2tpZS5jb20nO1xuICB9XG4gIGlmICh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwOicpIHtcbiAgICByZXR1cm4gJ2h0dHA6Ly93d3cueW91dHViZS5jb20nO1xuICB9XG5cbiAgLy8gVXNlIFlvdVR1YmUncyBkZWZhdWx0XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5jb25zdCB5b3V0dWJlID0ge1xuICBzZXR1cCgpIHtcbiAgICAvLyBBZGQgZW1iZWQgY2xhc3MgZm9yIHJlc3BvbnNpdmVcbiAgICB0b2dnbGVDbGFzcyh0aGlzLmVsZW1lbnRzLndyYXBwZXIsIHRoaXMuY29uZmlnLmNsYXNzTmFtZXMuZW1iZWQsIHRydWUpO1xuXG4gICAgLy8gU2V0dXAgQVBJXG4gICAgaWYgKGlzLm9iamVjdCh3aW5kb3cuWVQpICYmIGlzLmZ1bmN0aW9uKHdpbmRvdy5ZVC5QbGF5ZXIpKSB7XG4gICAgICB5b3V0dWJlLnJlYWR5LmNhbGwodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlZmVyZW5jZSBjdXJyZW50IGdsb2JhbCBjYWxsYmFja1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSB3aW5kb3cub25Zb3VUdWJlSWZyYW1lQVBJUmVhZHk7XG5cbiAgICAgIC8vIFNldCBjYWxsYmFjayB0byBwcm9jZXNzIHF1ZXVlXG4gICAgICB3aW5kb3cub25Zb3VUdWJlSWZyYW1lQVBJUmVhZHkgPSAoKSA9PiB7XG4gICAgICAgIC8vIENhbGwgZ2xvYmFsIGNhbGxiYWNrIGlmIHNldFxuICAgICAgICBpZiAoaXMuZnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB5b3V0dWJlLnJlYWR5LmNhbGwodGhpcyk7XG4gICAgICB9O1xuXG4gICAgICAvLyBMb2FkIHRoZSBTREtcbiAgICAgIGxvYWRTY3JpcHQodGhpcy5jb25maWcudXJscy55b3V0dWJlLnNkaykuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICB0aGlzLmRlYnVnLndhcm4oJ1lvdVR1YmUgQVBJIGZhaWxlZCB0byBsb2FkJywgZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICAvLyBHZXQgdGhlIG1lZGlhIHRpdGxlXG4gIGdldFRpdGxlKHZpZGVvSWQpIHtcbiAgICBjb25zdCB1cmwgPSBmb3JtYXQodGhpcy5jb25maWcudXJscy55b3V0dWJlLmFwaSwgdmlkZW9JZCk7XG4gICAgZmV0Y2godXJsKS50aGVuKGRhdGEgPT4ge1xuICAgICAgaWYgKGlzLm9iamVjdChkYXRhKSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoXG4gICAgICAgIH0gPSBkYXRhO1xuXG4gICAgICAgIC8vIFNldCB0aXRsZVxuICAgICAgICB0aGlzLmNvbmZpZy50aXRsZSA9IHRpdGxlO1xuICAgICAgICB1aS5zZXRUaXRsZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIC8vIFNldCBhc3BlY3QgcmF0aW9cbiAgICAgICAgdGhpcy5lbWJlZC5yYXRpbyA9IHJvdW5kQXNwZWN0UmF0aW8od2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgICBzZXRBc3BlY3RSYXRpby5jYWxsKHRoaXMpO1xuICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgIC8vIFNldCBhc3BlY3QgcmF0aW9cbiAgICAgIHNldEFzcGVjdFJhdGlvLmNhbGwodGhpcyk7XG4gICAgfSk7XG4gIH0sXG4gIC8vIEFQSSByZWFkeVxuICByZWFkeSgpIHtcbiAgICBjb25zdCBwbGF5ZXIgPSB0aGlzO1xuICAgIGNvbnN0IGNvbmZpZyA9IHBsYXllci5jb25maWcueW91dHViZTtcbiAgICAvLyBJZ25vcmUgYWxyZWFkeSBzZXR1cCAocmFjZSBjb25kaXRpb24pXG4gICAgY29uc3QgY3VycmVudElkID0gcGxheWVyLm1lZGlhICYmIHBsYXllci5tZWRpYS5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgaWYgKCFpcy5lbXB0eShjdXJyZW50SWQpICYmIGN1cnJlbnRJZC5zdGFydHNXaXRoKCd5b3V0dWJlLScpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBzb3VyY2UgVVJMIG9yIElEXG4gICAgbGV0IHNvdXJjZSA9IHBsYXllci5tZWRpYS5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuXG4gICAgLy8gR2V0IGZyb20gPGRpdj4gaWYgbmVlZGVkXG4gICAgaWYgKGlzLmVtcHR5KHNvdXJjZSkpIHtcbiAgICAgIHNvdXJjZSA9IHBsYXllci5tZWRpYS5nZXRBdHRyaWJ1dGUodGhpcy5jb25maWcuYXR0cmlidXRlcy5lbWJlZC5pZCk7XG4gICAgfVxuXG4gICAgLy8gUmVwbGFjZSB0aGUgPGlmcmFtZT4gd2l0aCBhIDxkaXY+IGR1ZSB0byBZb3VUdWJlIEFQSSBpc3N1ZXNcbiAgICBjb25zdCB2aWRlb0lkID0gcGFyc2VJZChzb3VyY2UpO1xuICAgIGNvbnN0IGlkID0gZ2VuZXJhdGVJZChwbGF5ZXIucHJvdmlkZXIpO1xuICAgIC8vIFJlcGxhY2UgbWVkaWEgZWxlbWVudFxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgIGlkLFxuICAgICAgJ2RhdGEtcG9zdGVyJzogY29uZmlnLmN1c3RvbUNvbnRyb2xzID8gcGxheWVyLnBvc3RlciA6IHVuZGVmaW5lZFxuICAgIH0pO1xuICAgIHBsYXllci5tZWRpYSA9IHJlcGxhY2VFbGVtZW50KGNvbnRhaW5lciwgcGxheWVyLm1lZGlhKTtcblxuICAgIC8vIE9ubHkgbG9hZCB0aGUgcG9zdGVyIHdoZW4gdXNpbmcgY3VzdG9tIGNvbnRyb2xzXG4gICAgaWYgKGNvbmZpZy5jdXN0b21Db250cm9scykge1xuICAgICAgY29uc3QgcG9zdGVyU3JjID0gcyA9PiBgaHR0cHM6Ly9pLnl0aW1nLmNvbS92aS8ke3ZpZGVvSWR9LyR7c31kZWZhdWx0LmpwZ2A7XG5cbiAgICAgIC8vIENoZWNrIHRodW1ibmFpbCBpbWFnZXMgaW4gb3JkZXIgb2YgcXVhbGl0eSwgYnV0IHJlamVjdCBmYWxsYmFjayB0aHVtYm5haWxzICgxMjBweCB3aWRlKVxuICAgICAgbG9hZEltYWdlKHBvc3RlclNyYygnbWF4cmVzJyksIDEyMSkgLy8gSGlnaGVzdCBxdWFsaXR5IGFuZCB1bi1wYWRkZWRcbiAgICAgIC5jYXRjaCgoKSA9PiBsb2FkSW1hZ2UocG9zdGVyU3JjKCdzZCcpLCAxMjEpKSAvLyA0ODBwIHBhZGRlZCA0OjNcbiAgICAgIC5jYXRjaCgoKSA9PiBsb2FkSW1hZ2UocG9zdGVyU3JjKCdocScpKSkgLy8gMzYwcCBwYWRkZWQgNDozLiBBbHdheXMgZXhpc3RzXG4gICAgICAudGhlbihpbWFnZSA9PiB1aS5zZXRQb3N0ZXIuY2FsbChwbGF5ZXIsIGltYWdlLnNyYykpLnRoZW4oc3JjID0+IHtcbiAgICAgICAgLy8gSWYgdGhlIGltYWdlIGlzIHBhZGRlZCwgdXNlIGJhY2tncm91bmQtc2l6ZSBcImNvdmVyXCIgaW5zdGVhZCAobGlrZSB5b3V0dWJlIGRvZXMgdG9vIHdpdGggdGhlaXIgcG9zdGVycylcbiAgICAgICAgaWYgKCFzcmMuaW5jbHVkZXMoJ21heHJlcycpKSB7XG4gICAgICAgICAgcGxheWVyLmVsZW1lbnRzLnBvc3Rlci5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9ICdjb3Zlcic7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKCgpID0+IHt9KTtcbiAgICB9XG5cbiAgICAvLyBTZXR1cCBpbnN0YW5jZVxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3lvdXR1YmUvaWZyYW1lX2FwaV9yZWZlcmVuY2VcbiAgICBwbGF5ZXIuZW1iZWQgPSBuZXcgd2luZG93LllULlBsYXllcihwbGF5ZXIubWVkaWEsIHtcbiAgICAgIHZpZGVvSWQsXG4gICAgICBob3N0OiBnZXRIb3N0KGNvbmZpZyksXG4gICAgICBwbGF5ZXJWYXJzOiBleHRlbmQoe30sIHtcbiAgICAgICAgLy8gQXV0b3BsYXlcbiAgICAgICAgYXV0b3BsYXk6IHBsYXllci5jb25maWcuYXV0b3BsYXkgPyAxIDogMCxcbiAgICAgICAgLy8gaWZyYW1lIGludGVyZmFjZSBsYW5ndWFnZVxuICAgICAgICBobDogcGxheWVyLmNvbmZpZy5obCxcbiAgICAgICAgLy8gT25seSBzaG93IGNvbnRyb2xzIGlmIG5vdCBmdWxseSBzdXBwb3J0ZWQgb3Igb3B0ZWQgb3V0XG4gICAgICAgIGNvbnRyb2xzOiBwbGF5ZXIuc3VwcG9ydGVkLnVpICYmIGNvbmZpZy5jdXN0b21Db250cm9scyA/IDAgOiAxLFxuICAgICAgICAvLyBEaXNhYmxlIGtleWJvYXJkIGFzIHdlIGhhbmRsZSBpdFxuICAgICAgICBkaXNhYmxla2I6IDEsXG4gICAgICAgIC8vIEFsbG93IGlPUyBpbmxpbmUgcGxheWJhY2tcbiAgICAgICAgcGxheXNpbmxpbmU6IHBsYXllci5jb25maWcucGxheXNpbmxpbmUgJiYgIXBsYXllci5jb25maWcuZnVsbHNjcmVlbi5pb3NOYXRpdmUgPyAxIDogMCxcbiAgICAgICAgLy8gQ2FwdGlvbnMgYXJlIGZsYWt5IG9uIFlvdVR1YmVcbiAgICAgICAgY2NfbG9hZF9wb2xpY3k6IHBsYXllci5jYXB0aW9ucy5hY3RpdmUgPyAxIDogMCxcbiAgICAgICAgY2NfbGFuZ19wcmVmOiBwbGF5ZXIuY29uZmlnLmNhcHRpb25zLmxhbmd1YWdlLFxuICAgICAgICAvLyBUcmFja2luZyBmb3Igc3RhdHNcbiAgICAgICAgd2lkZ2V0X3JlZmVycmVyOiB3aW5kb3cgPyB3aW5kb3cubG9jYXRpb24uaHJlZiA6IG51bGxcbiAgICAgIH0sIGNvbmZpZyksXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgb25FcnJvcihldmVudCkge1xuICAgICAgICAgIC8vIFlvdVR1YmUgbWF5IGZpcmUgb25FcnJvciB0d2ljZSwgc28gb25seSBoYW5kbGUgaXQgb25jZVxuICAgICAgICAgIGlmICghcGxheWVyLm1lZGlhLmVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIC8vIE1lc3NhZ2VzIGNvcGllZCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3lvdXR1YmUvaWZyYW1lX2FwaV9yZWZlcmVuY2Ujb25FcnJvclxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgMjogJ1RoZSByZXF1ZXN0IGNvbnRhaW5zIGFuIGludmFsaWQgcGFyYW1ldGVyIHZhbHVlLiBGb3IgZXhhbXBsZSwgdGhpcyBlcnJvciBvY2N1cnMgaWYgeW91IHNwZWNpZnkgYSB2aWRlbyBJRCB0aGF0IGRvZXMgbm90IGhhdmUgMTEgY2hhcmFjdGVycywgb3IgaWYgdGhlIHZpZGVvIElEIGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycywgc3VjaCBhcyBleGNsYW1hdGlvbiBwb2ludHMgb3IgYXN0ZXJpc2tzLicsXG4gICAgICAgICAgICAgIDU6ICdUaGUgcmVxdWVzdGVkIGNvbnRlbnQgY2Fubm90IGJlIHBsYXllZCBpbiBhbiBIVE1MNSBwbGF5ZXIgb3IgYW5vdGhlciBlcnJvciByZWxhdGVkIHRvIHRoZSBIVE1MNSBwbGF5ZXIgaGFzIG9jY3VycmVkLicsXG4gICAgICAgICAgICAgIDEwMDogJ1RoZSB2aWRlbyByZXF1ZXN0ZWQgd2FzIG5vdCBmb3VuZC4gVGhpcyBlcnJvciBvY2N1cnMgd2hlbiBhIHZpZGVvIGhhcyBiZWVuIHJlbW92ZWQgKGZvciBhbnkgcmVhc29uKSBvciBoYXMgYmVlbiBtYXJrZWQgYXMgcHJpdmF0ZS4nLFxuICAgICAgICAgICAgICAxMDE6ICdUaGUgb3duZXIgb2YgdGhlIHJlcXVlc3RlZCB2aWRlbyBkb2VzIG5vdCBhbGxvdyBpdCB0byBiZSBwbGF5ZWQgaW4gZW1iZWRkZWQgcGxheWVycy4nLFxuICAgICAgICAgICAgICAxNTA6ICdUaGUgb3duZXIgb2YgdGhlIHJlcXVlc3RlZCB2aWRlbyBkb2VzIG5vdCBhbGxvdyBpdCB0byBiZSBwbGF5ZWQgaW4gZW1iZWRkZWQgcGxheWVycy4nXG4gICAgICAgICAgICB9W2NvZGVdIHx8ICdBbiB1bmtub3duIGVycm9yIG9jY3VycmVkJztcbiAgICAgICAgICAgIHBsYXllci5tZWRpYS5lcnJvciA9IHtcbiAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgbWVzc2FnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudC5jYWxsKHBsYXllciwgcGxheWVyLm1lZGlhLCAnZXJyb3InKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uUGxheWJhY2tSYXRlQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgICAgLy8gR2V0IHRoZSBpbnN0YW5jZVxuICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgICAgICAgLy8gR2V0IGN1cnJlbnQgc3BlZWRcbiAgICAgICAgICBwbGF5ZXIubWVkaWEucGxheWJhY2tSYXRlID0gaW5zdGFuY2UuZ2V0UGxheWJhY2tSYXRlKCk7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50LmNhbGwocGxheWVyLCBwbGF5ZXIubWVkaWEsICdyYXRlY2hhbmdlJyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUmVhZHkoZXZlbnQpIHtcbiAgICAgICAgICAvLyBCYWlsIGlmIG9uUmVhZHkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQuIFNlZSBpc3N1ZSAjMTEwOFxuICAgICAgICAgIGlmIChpcy5mdW5jdGlvbihwbGF5ZXIubWVkaWEucGxheSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gR2V0IHRoZSBpbnN0YW5jZVxuICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgICAgICAgLy8gR2V0IHRoZSB0aXRsZVxuICAgICAgICAgIHlvdXR1YmUuZ2V0VGl0bGUuY2FsbChwbGF5ZXIsIHZpZGVvSWQpO1xuXG4gICAgICAgICAgLy8gQ3JlYXRlIGEgZmF1eCBIVE1MNSBBUEkgdXNpbmcgdGhlIFlvdVR1YmUgQVBJXG4gICAgICAgICAgcGxheWVyLm1lZGlhLnBsYXkgPSAoKSA9PiB7XG4gICAgICAgICAgICBhc3N1cmVQbGF5YmFja1N0YXRlLmNhbGwocGxheWVyLCB0cnVlKTtcbiAgICAgICAgICAgIGluc3RhbmNlLnBsYXlWaWRlbygpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcGxheWVyLm1lZGlhLnBhdXNlID0gKCkgPT4ge1xuICAgICAgICAgICAgYXNzdXJlUGxheWJhY2tTdGF0ZS5jYWxsKHBsYXllciwgZmFsc2UpO1xuICAgICAgICAgICAgaW5zdGFuY2UucGF1c2VWaWRlbygpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcGxheWVyLm1lZGlhLnN0b3AgPSAoKSA9PiB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zdG9wVmlkZW8oKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHBsYXllci5tZWRpYS5kdXJhdGlvbiA9IGluc3RhbmNlLmdldER1cmF0aW9uKCk7XG4gICAgICAgICAgcGxheWVyLm1lZGlhLnBhdXNlZCA9IHRydWU7XG5cbiAgICAgICAgICAvLyBTZWVraW5nXG4gICAgICAgICAgcGxheWVyLm1lZGlhLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGxheWVyLm1lZGlhLCAnY3VycmVudFRpbWUnLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBOdW1iZXIoaW5zdGFuY2UuZ2V0Q3VycmVudFRpbWUoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0KHRpbWUpIHtcbiAgICAgICAgICAgICAgLy8gSWYgcGF1c2VkIGFuZCBuZXZlciBwbGF5ZWQsIG11dGUgYXVkaW8gcHJldmVudGl2ZWx5IChZb3VUdWJlIHN0YXJ0cyBwbGF5aW5nIG9uIHNlZWsgaWYgdGhlIHZpZGVvIGhhc24ndCBiZWVuIHBsYXllZCB5ZXQpLlxuICAgICAgICAgICAgICBpZiAocGxheWVyLnBhdXNlZCAmJiAhcGxheWVyLmVtYmVkLmhhc1BsYXllZCkge1xuICAgICAgICAgICAgICAgIHBsYXllci5lbWJlZC5tdXRlKCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBTZXQgc2Vla2luZyBzdGF0ZSBhbmQgdHJpZ2dlciBldmVudFxuICAgICAgICAgICAgICBwbGF5ZXIubWVkaWEuc2Vla2luZyA9IHRydWU7XG4gICAgICAgICAgICAgIHRyaWdnZXJFdmVudC5jYWxsKHBsYXllciwgcGxheWVyLm1lZGlhLCAnc2Vla2luZycpO1xuXG4gICAgICAgICAgICAgIC8vIFNlZWsgYWZ0ZXIgZXZlbnRzIHNlbnRcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc2Vla1RvKHRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gUGxheWJhY2sgc3BlZWRcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGxheWVyLm1lZGlhLCAncGxheWJhY2tSYXRlJywge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2UuZ2V0UGxheWJhY2tSYXRlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0KGlucHV0KSB7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnNldFBsYXliYWNrUmF0ZShpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBWb2x1bWVcbiAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgdm9sdW1lXG4gICAgICAgICAgfSA9IHBsYXllci5jb25maWc7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBsYXllci5tZWRpYSwgJ3ZvbHVtZScsIHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZvbHVtZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQoaW5wdXQpIHtcbiAgICAgICAgICAgICAgdm9sdW1lID0gaW5wdXQ7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnNldFZvbHVtZSh2b2x1bWUgKiAxMDApO1xuICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQuY2FsbChwbGF5ZXIsIHBsYXllci5tZWRpYSwgJ3ZvbHVtZWNoYW5nZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gTXV0ZWRcbiAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgbXV0ZWRcbiAgICAgICAgICB9ID0gcGxheWVyLmNvbmZpZztcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGxheWVyLm1lZGlhLCAnbXV0ZWQnLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBtdXRlZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQoaW5wdXQpIHtcbiAgICAgICAgICAgICAgY29uc3QgdG9nZ2xlID0gaXMuYm9vbGVhbihpbnB1dCkgPyBpbnB1dCA6IG11dGVkO1xuICAgICAgICAgICAgICBtdXRlZCA9IHRvZ2dsZTtcbiAgICAgICAgICAgICAgaW5zdGFuY2VbdG9nZ2xlID8gJ211dGUnIDogJ3VuTXV0ZSddKCk7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnNldFZvbHVtZSh2b2x1bWUgKiAxMDApO1xuICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQuY2FsbChwbGF5ZXIsIHBsYXllci5tZWRpYSwgJ3ZvbHVtZWNoYW5nZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gU291cmNlXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBsYXllci5tZWRpYSwgJ2N1cnJlbnRTcmMnLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5nZXRWaWRlb1VybCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gRW5kZWRcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGxheWVyLm1lZGlhLCAnZW5kZWQnLCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwbGF5ZXIuY3VycmVudFRpbWUgPT09IHBsYXllci5kdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIEdldCBhdmFpbGFibGUgc3BlZWRzXG4gICAgICAgICAgY29uc3Qgc3BlZWRzID0gaW5zdGFuY2UuZ2V0QXZhaWxhYmxlUGxheWJhY2tSYXRlcygpO1xuICAgICAgICAgIC8vIEZpbHRlciBiYXNlZCBvbiBjb25maWdcbiAgICAgICAgICBwbGF5ZXIub3B0aW9ucy5zcGVlZCA9IHNwZWVkcy5maWx0ZXIocyA9PiBwbGF5ZXIuY29uZmlnLnNwZWVkLm9wdGlvbnMuaW5jbHVkZXMocykpO1xuXG4gICAgICAgICAgLy8gU2V0IHRoZSB0YWJpbmRleCB0byBhdm9pZCBmb2N1cyBlbnRlcmluZyBpZnJhbWVcbiAgICAgICAgICBpZiAocGxheWVyLnN1cHBvcnRlZC51aSAmJiBjb25maWcuY3VzdG9tQ29udHJvbHMpIHtcbiAgICAgICAgICAgIHBsYXllci5tZWRpYS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgLTEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cmlnZ2VyRXZlbnQuY2FsbChwbGF5ZXIsIHBsYXllci5tZWRpYSwgJ3RpbWV1cGRhdGUnKTtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnQuY2FsbChwbGF5ZXIsIHBsYXllci5tZWRpYSwgJ2R1cmF0aW9uY2hhbmdlJyk7XG5cbiAgICAgICAgICAvLyBSZXNldCB0aW1lclxuICAgICAgICAgIGNsZWFySW50ZXJ2YWwocGxheWVyLnRpbWVycy5idWZmZXJpbmcpO1xuXG4gICAgICAgICAgLy8gU2V0dXAgYnVmZmVyaW5nXG4gICAgICAgICAgcGxheWVyLnRpbWVycy5idWZmZXJpbmcgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBHZXQgbG9hZGVkICUgZnJvbSBZb3VUdWJlXG4gICAgICAgICAgICBwbGF5ZXIubWVkaWEuYnVmZmVyZWQgPSBpbnN0YW5jZS5nZXRWaWRlb0xvYWRlZEZyYWN0aW9uKCk7XG5cbiAgICAgICAgICAgIC8vIFRyaWdnZXIgcHJvZ3Jlc3Mgb25seSB3aGVuIHdlIGFjdHVhbGx5IGJ1ZmZlciBzb21ldGhpbmdcbiAgICAgICAgICAgIGlmIChwbGF5ZXIubWVkaWEubGFzdEJ1ZmZlcmVkID09PSBudWxsIHx8IHBsYXllci5tZWRpYS5sYXN0QnVmZmVyZWQgPCBwbGF5ZXIubWVkaWEuYnVmZmVyZWQpIHtcbiAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50LmNhbGwocGxheWVyLCBwbGF5ZXIubWVkaWEsICdwcm9ncmVzcycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXQgbGFzdCBidWZmZXIgcG9pbnRcbiAgICAgICAgICAgIHBsYXllci5tZWRpYS5sYXN0QnVmZmVyZWQgPSBwbGF5ZXIubWVkaWEuYnVmZmVyZWQ7XG5cbiAgICAgICAgICAgIC8vIEJhaWwgaWYgd2UncmUgYXQgMTAwJVxuICAgICAgICAgICAgaWYgKHBsYXllci5tZWRpYS5idWZmZXJlZCA9PT0gMSkge1xuICAgICAgICAgICAgICBjbGVhckludGVydmFsKHBsYXllci50aW1lcnMuYnVmZmVyaW5nKTtcblxuICAgICAgICAgICAgICAvLyBUcmlnZ2VyIGV2ZW50XG4gICAgICAgICAgICAgIHRyaWdnZXJFdmVudC5jYWxsKHBsYXllciwgcGxheWVyLm1lZGlhLCAnY2FucGxheXRocm91Z2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAyMDApO1xuXG4gICAgICAgICAgLy8gUmVidWlsZCBVSVxuICAgICAgICAgIGlmIChjb25maWcuY3VzdG9tQ29udHJvbHMpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdWkuYnVpbGQuY2FsbChwbGF5ZXIpLCA1MCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblN0YXRlQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgICAgLy8gR2V0IHRoZSBpbnN0YW5jZVxuICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgICAgICAgLy8gUmVzZXQgdGltZXJcbiAgICAgICAgICBjbGVhckludGVydmFsKHBsYXllci50aW1lcnMucGxheWluZyk7XG4gICAgICAgICAgY29uc3Qgc2Vla2VkID0gcGxheWVyLm1lZGlhLnNlZWtpbmcgJiYgWzEsIDJdLmluY2x1ZGVzKGV2ZW50LmRhdGEpO1xuICAgICAgICAgIGlmIChzZWVrZWQpIHtcbiAgICAgICAgICAgIC8vIFVuc2V0IHNlZWtpbmcgYW5kIGZpcmUgc2Vla2VkIGV2ZW50XG4gICAgICAgICAgICBwbGF5ZXIubWVkaWEuc2Vla2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50LmNhbGwocGxheWVyLCBwbGF5ZXIubWVkaWEsICdzZWVrZWQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBIYW5kbGUgZXZlbnRzXG4gICAgICAgICAgLy8gLTEgICBVbnN0YXJ0ZWRcbiAgICAgICAgICAvLyAwICAgIEVuZGVkXG4gICAgICAgICAgLy8gMSAgICBQbGF5aW5nXG4gICAgICAgICAgLy8gMiAgICBQYXVzZWRcbiAgICAgICAgICAvLyAzICAgIEJ1ZmZlcmluZ1xuICAgICAgICAgIC8vIDUgICAgVmlkZW8gY3VlZFxuICAgICAgICAgIHN3aXRjaCAoZXZlbnQuZGF0YSkge1xuICAgICAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICAgICAgLy8gVXBkYXRlIHNjcnViYmVyXG4gICAgICAgICAgICAgIHRyaWdnZXJFdmVudC5jYWxsKHBsYXllciwgcGxheWVyLm1lZGlhLCAndGltZXVwZGF0ZScpO1xuXG4gICAgICAgICAgICAgIC8vIEdldCBsb2FkZWQgJSBmcm9tIFlvdVR1YmVcbiAgICAgICAgICAgICAgcGxheWVyLm1lZGlhLmJ1ZmZlcmVkID0gaW5zdGFuY2UuZ2V0VmlkZW9Mb2FkZWRGcmFjdGlvbigpO1xuICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQuY2FsbChwbGF5ZXIsIHBsYXllci5tZWRpYSwgJ3Byb2dyZXNzJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBhc3N1cmVQbGF5YmFja1N0YXRlLmNhbGwocGxheWVyLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgLy8gWW91VHViZSBkb2Vzbid0IHN1cHBvcnQgbG9vcCBmb3IgYSBzaW5nbGUgdmlkZW8sIHNvIG1pbWljayBpdC5cbiAgICAgICAgICAgICAgaWYgKHBsYXllci5tZWRpYS5sb29wKSB7XG4gICAgICAgICAgICAgICAgLy8gWW91VHViZSBuZWVkcyBhIGNhbGwgdG8gYHN0b3BWaWRlb2AgYmVmb3JlIHBsYXlpbmcgYWdhaW5cbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5zdG9wVmlkZW8oKTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5wbGF5VmlkZW8oKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQuY2FsbChwbGF5ZXIsIHBsYXllci5tZWRpYSwgJ2VuZGVkJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIC8vIFJlc3RvcmUgcGF1c2VkIHN0YXRlIChZb3VUdWJlIHN0YXJ0cyBwbGF5aW5nIG9uIHNlZWsgaWYgdGhlIHZpZGVvIGhhc24ndCBiZWVuIHBsYXllZCB5ZXQpXG4gICAgICAgICAgICAgIGlmIChjb25maWcuY3VzdG9tQ29udHJvbHMgJiYgIXBsYXllci5jb25maWcuYXV0b3BsYXkgJiYgcGxheWVyLm1lZGlhLnBhdXNlZCAmJiAhcGxheWVyLmVtYmVkLmhhc1BsYXllZCkge1xuICAgICAgICAgICAgICAgIHBsYXllci5tZWRpYS5wYXVzZSgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzc3VyZVBsYXliYWNrU3RhdGUuY2FsbChwbGF5ZXIsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudC5jYWxsKHBsYXllciwgcGxheWVyLm1lZGlhLCAncGxheWluZycpO1xuXG4gICAgICAgICAgICAgICAgLy8gUG9sbCB0byBnZXQgcGxheWJhY2sgcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICBwbGF5ZXIudGltZXJzLnBsYXlpbmcgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQuY2FsbChwbGF5ZXIsIHBsYXllci5tZWRpYSwgJ3RpbWV1cGRhdGUnKTtcbiAgICAgICAgICAgICAgICB9LCA1MCk7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBkdXJhdGlvbiBhZ2FpbiBkdWUgdG8gWW91VHViZSBidWdcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc2FtcG90dHMvcGx5ci9pc3N1ZXMvMzc0XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9nZGF0YS1pc3N1ZXMvaXNzdWVzL2RldGFpbD9pZD04NjkwXG4gICAgICAgICAgICAgICAgaWYgKHBsYXllci5tZWRpYS5kdXJhdGlvbiAhPT0gaW5zdGFuY2UuZ2V0RHVyYXRpb24oKSkge1xuICAgICAgICAgICAgICAgICAgcGxheWVyLm1lZGlhLmR1cmF0aW9uID0gaW5zdGFuY2UuZ2V0RHVyYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudC5jYWxsKHBsYXllciwgcGxheWVyLm1lZGlhLCAnZHVyYXRpb25jaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIC8vIFJlc3RvcmUgYXVkaW8gKFlvdVR1YmUgc3RhcnRzIHBsYXlpbmcgb24gc2VlayBpZiB0aGUgdmlkZW8gaGFzbid0IGJlZW4gcGxheWVkIHlldClcbiAgICAgICAgICAgICAgaWYgKCFwbGF5ZXIubXV0ZWQpIHtcbiAgICAgICAgICAgICAgICBwbGF5ZXIuZW1iZWQudW5NdXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXNzdXJlUGxheWJhY2tTdGF0ZS5jYWxsKHBsYXllciwgZmFsc2UpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgLy8gVHJpZ2dlciB3YWl0aW5nIGV2ZW50IHRvIGFkZCBsb2FkaW5nIGNsYXNzZXMgdG8gY29udGFpbmVyIGFzIHRoZSB2aWRlbyBidWZmZXJzLlxuICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQuY2FsbChwbGF5ZXIsIHBsYXllci5tZWRpYSwgJ3dhaXRpbmcnKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyaWdnZXJFdmVudC5jYWxsKHBsYXllciwgcGxheWVyLmVsZW1lbnRzLmNvbnRhaW5lciwgJ3N0YXRlY2hhbmdlJywgZmFsc2UsIHtcbiAgICAgICAgICAgIGNvZGU6IGV2ZW50LmRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gUGx5ciBNZWRpYVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgbWVkaWEgPSB7XG4gIC8vIFNldHVwIG1lZGlhXG4gIHNldHVwKCkge1xuICAgIC8vIElmIHRoZXJlJ3Mgbm8gbWVkaWEsIGJhaWxcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHRoaXMuZGVidWcud2FybignTm8gbWVkaWEgZWxlbWVudCBmb3VuZCEnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBZGQgdHlwZSBjbGFzc1xuICAgIHRvZ2dsZUNsYXNzKHRoaXMuZWxlbWVudHMuY29udGFpbmVyLCB0aGlzLmNvbmZpZy5jbGFzc05hbWVzLnR5cGUucmVwbGFjZSgnezB9JywgdGhpcy50eXBlKSwgdHJ1ZSk7XG5cbiAgICAvLyBBZGQgcHJvdmlkZXIgY2xhc3NcbiAgICB0b2dnbGVDbGFzcyh0aGlzLmVsZW1lbnRzLmNvbnRhaW5lciwgdGhpcy5jb25maWcuY2xhc3NOYW1lcy5wcm92aWRlci5yZXBsYWNlKCd7MH0nLCB0aGlzLnByb3ZpZGVyKSwgdHJ1ZSk7XG5cbiAgICAvLyBBZGQgdmlkZW8gY2xhc3MgZm9yIGVtYmVkc1xuICAgIC8vIFRoaXMgd2lsbCByZXF1aXJlIGNoYW5nZXMgaWYgYXVkaW8gZW1iZWRzIGFyZSBhZGRlZFxuICAgIGlmICh0aGlzLmlzRW1iZWQpIHtcbiAgICAgIHRvZ2dsZUNsYXNzKHRoaXMuZWxlbWVudHMuY29udGFpbmVyLCB0aGlzLmNvbmZpZy5jbGFzc05hbWVzLnR5cGUucmVwbGFjZSgnezB9JywgJ3ZpZGVvJyksIHRydWUpO1xuICAgIH1cblxuICAgIC8vIEluamVjdCB0aGUgcGxheWVyIHdyYXBwZXJcbiAgICBpZiAodGhpcy5pc1ZpZGVvKSB7XG4gICAgICAvLyBDcmVhdGUgdGhlIHdyYXBwZXIgZGl2XG4gICAgICB0aGlzLmVsZW1lbnRzLndyYXBwZXIgPSBjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgIGNsYXNzOiB0aGlzLmNvbmZpZy5jbGFzc05hbWVzLnZpZGVvXG4gICAgICB9KTtcblxuICAgICAgLy8gV3JhcCB0aGUgdmlkZW8gaW4gYSBjb250YWluZXJcbiAgICAgIHdyYXAodGhpcy5tZWRpYSwgdGhpcy5lbGVtZW50cy53cmFwcGVyKTtcblxuICAgICAgLy8gUG9zdGVyIGltYWdlIGNvbnRhaW5lclxuICAgICAgdGhpcy5lbGVtZW50cy5wb3N0ZXIgPSBjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgIGNsYXNzOiB0aGlzLmNvbmZpZy5jbGFzc05hbWVzLnBvc3RlclxuICAgICAgfSk7XG4gICAgICB0aGlzLmVsZW1lbnRzLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50cy5wb3N0ZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0hUTUw1KSB7XG4gICAgICBodG1sNS5zZXR1cC5jYWxsKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1lvdVR1YmUpIHtcbiAgICAgIHlvdXR1YmUuc2V0dXAuY2FsbCh0aGlzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNWaW1lbykge1xuICAgICAgdmltZW8uc2V0dXAuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRlc3Ryb3koaW5zdGFuY2UpIHtcbiAgLy8gRGVzdHJveSBvdXIgYWRzTWFuYWdlclxuICBpZiAoaW5zdGFuY2UubWFuYWdlcikge1xuICAgIGluc3RhbmNlLm1hbmFnZXIuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gRGVzdHJveSBvdXIgYWRzTWFuYWdlclxuICBpZiAoaW5zdGFuY2UuZWxlbWVudHMuZGlzcGxheUNvbnRhaW5lcikge1xuICAgIGluc3RhbmNlLmVsZW1lbnRzLmRpc3BsYXlDb250YWluZXIuZGVzdHJveSgpO1xuICB9XG4gIGluc3RhbmNlLmVsZW1lbnRzLmNvbnRhaW5lci5yZW1vdmUoKTtcbn1cbmNsYXNzIEFkcyB7XG4gIC8qKlxuICAgKiBBZHMgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwbGF5ZXJcbiAgICogQHJldHVybiB7QWRzfVxuICAgKi9cbiAgY29uc3RydWN0b3IocGxheWVyKSB7XG4gICAgLyoqXG4gICAgICogTG9hZCB0aGUgSU1BIFNES1xuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwibG9hZFwiLCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBHb29nbGUgSU1BMyBTREsgaXMgbG9hZGVkIG9yIGxvYWQgaXQgb3Vyc2VsdmVzXG4gICAgICBpZiAoIWlzLm9iamVjdCh3aW5kb3cuZ29vZ2xlKSB8fCAhaXMub2JqZWN0KHdpbmRvdy5nb29nbGUuaW1hKSkge1xuICAgICAgICBsb2FkU2NyaXB0KHRoaXMucGxheWVyLmNvbmZpZy51cmxzLmdvb2dsZUlNQS5zZGspLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVhZHkoKTtcbiAgICAgICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIC8vIFNjcmlwdCBmYWlsZWQgdG8gbG9hZCBvciBpcyBibG9ja2VkXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdlcnJvcicsIG5ldyBFcnJvcignR29vZ2xlIElNQSBTREsgZmFpbGVkIHRvIGxvYWQnKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZWFkeSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYWRzIGluc3RhbmNlIHJlYWR5XG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5JDEodGhpcywgXCJyZWFkeVwiLCAoKSA9PiB7XG4gICAgICAvLyBEb3VibGUgY2hlY2sgd2UncmUgZW5hYmxlZFxuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgZGVzdHJveSh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RhcnQgdGlja2luZyBvdXIgc2FmZXR5IHRpbWVyLiBJZiB0aGUgd2hvbGUgYWR2ZXJ0aXNlbWVudFxuICAgICAgLy8gdGhpbmcgZG9lc24ndCByZXNvbHZlIHdpdGhpbiBvdXIgc2V0IHRpbWU7IHdlIGJhaWxcbiAgICAgIHRoaXMuc3RhcnRTYWZldHlUaW1lcigxMjAwMCwgJ3JlYWR5KCknKTtcblxuICAgICAgLy8gQ2xlYXIgdGhlIHNhZmV0eSB0aW1lclxuICAgICAgdGhpcy5tYW5hZ2VyUHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5jbGVhclNhZmV0eVRpbWVyKCdvbkFkc01hbmFnZXJMb2FkZWQoKScpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFNldCBsaXN0ZW5lcnMgb24gdGhlIFBseXIgaW5zdGFuY2VcbiAgICAgIHRoaXMubGlzdGVuZXJzKCk7XG5cbiAgICAgIC8vIFNldHVwIHRoZSBJTUEgU0RLXG4gICAgICB0aGlzLnNldHVwSU1BKCk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogSW4gb3JkZXIgZm9yIHRoZSBTREsgdG8gZGlzcGxheSBhZHMgZm9yIG91ciB2aWRlbywgd2UgbmVlZCB0byB0ZWxsIGl0IHdoZXJlIHRvIHB1dCB0aGVtLFxuICAgICAqIHNvIGhlcmUgd2UgZGVmaW5lIG91ciBhZCBjb250YWluZXIuIFRoaXMgZGl2IGlzIHNldCB1cCB0byByZW5kZXIgb24gdG9wIG9mIHRoZSB2aWRlbyBwbGF5ZXIuXG4gICAgICogVXNpbmcgdGhlIGNvZGUgYmVsb3csIHdlIHRlbGwgdGhlIFNESyB0byByZW5kZXIgYWRzIHdpdGhpbiB0aGF0IGRpdi4gV2UgYWxzbyBwcm92aWRlIGFcbiAgICAgKiBoYW5kbGUgdG8gdGhlIGNvbnRlbnQgdmlkZW8gcGxheWVyIC0gdGhlIFNESyB3aWxsIHBvbGwgdGhlIGN1cnJlbnQgdGltZSBvZiBvdXIgcGxheWVyIHRvXG4gICAgICogcHJvcGVybHkgcGxhY2UgbWlkLXJvbGxzLiBBZnRlciB3ZSBjcmVhdGUgdGhlIGFkIGRpc3BsYXkgY29udGFpbmVyLCB3ZSBpbml0aWFsaXplIGl0LiBPblxuICAgICAqIG1vYmlsZSBkZXZpY2VzLCB0aGlzIGluaXRpYWxpemF0aW9uIGlzIGRvbmUgYXMgdGhlIHJlc3VsdCBvZiBhIHVzZXIgYWN0aW9uLlxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwic2V0dXBJTUFcIiwgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIHRoZSBjb250YWluZXIgZm9yIG91ciBhZHZlcnRpc2VtZW50c1xuICAgICAgdGhpcy5lbGVtZW50cy5jb250YWluZXIgPSBjcmVhdGVFbGVtZW50KCdkaXYnLCB7XG4gICAgICAgIGNsYXNzOiB0aGlzLnBsYXllci5jb25maWcuY2xhc3NOYW1lcy5hZHNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wbGF5ZXIuZWxlbWVudHMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudHMuY29udGFpbmVyKTtcblxuICAgICAgLy8gU28gd2UgY2FuIHJ1biBWUEFJRDJcbiAgICAgIGdvb2dsZS5pbWEuc2V0dGluZ3Muc2V0VnBhaWRNb2RlKGdvb2dsZS5pbWEuSW1hU2RrU2V0dGluZ3MuVnBhaWRNb2RlLkVOQUJMRUQpO1xuXG4gICAgICAvLyBTZXQgbGFuZ3VhZ2VcbiAgICAgIGdvb2dsZS5pbWEuc2V0dGluZ3Muc2V0TG9jYWxlKHRoaXMucGxheWVyLmNvbmZpZy5hZHMubGFuZ3VhZ2UpO1xuXG4gICAgICAvLyBTZXQgcGxheWJhY2sgZm9yIGlPUzEwK1xuICAgICAgZ29vZ2xlLmltYS5zZXR0aW5ncy5zZXREaXNhYmxlQ3VzdG9tUGxheWJhY2tGb3JJT1MxMFBsdXModGhpcy5wbGF5ZXIuY29uZmlnLnBsYXlzaW5saW5lKTtcblxuICAgICAgLy8gV2UgYXNzdW1lIHRoZSBhZENvbnRhaW5lciBpcyB0aGUgdmlkZW8gY29udGFpbmVyIG9mIHRoZSBwbHlyIGVsZW1lbnQgdGhhdCB3aWxsIGhvdXNlIHRoZSBhZHNcbiAgICAgIHRoaXMuZWxlbWVudHMuZGlzcGxheUNvbnRhaW5lciA9IG5ldyBnb29nbGUuaW1hLkFkRGlzcGxheUNvbnRhaW5lcih0aGlzLmVsZW1lbnRzLmNvbnRhaW5lciwgdGhpcy5wbGF5ZXIubWVkaWEpO1xuXG4gICAgICAvLyBDcmVhdGUgYWRzIGxvYWRlclxuICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgZ29vZ2xlLmltYS5BZHNMb2FkZXIodGhpcy5lbGVtZW50cy5kaXNwbGF5Q29udGFpbmVyKTtcblxuICAgICAgLy8gTGlzdGVuIGFuZCByZXNwb25kIHRvIGFkcyBsb2FkZWQgYW5kIGVycm9yIGV2ZW50c1xuICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihnb29nbGUuaW1hLkFkc01hbmFnZXJMb2FkZWRFdmVudC5UeXBlLkFEU19NQU5BR0VSX0xPQURFRCwgZXZlbnQgPT4gdGhpcy5vbkFkc01hbmFnZXJMb2FkZWQoZXZlbnQpLCBmYWxzZSk7XG4gICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKGdvb2dsZS5pbWEuQWRFcnJvckV2ZW50LlR5cGUuQURfRVJST1IsIGVycm9yID0+IHRoaXMub25BZEVycm9yKGVycm9yKSwgZmFsc2UpO1xuXG4gICAgICAvLyBSZXF1ZXN0IHZpZGVvIGFkcyB0byBiZSBwcmUtbG9hZGVkXG4gICAgICB0aGlzLnJlcXVlc3RBZHMoKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGFkdmVydGlzZW1lbnRzXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5JDEodGhpcywgXCJyZXF1ZXN0QWRzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29udGFpbmVyXG4gICAgICB9ID0gdGhpcy5wbGF5ZXIuZWxlbWVudHM7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBSZXF1ZXN0IHZpZGVvIGFkc1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IGdvb2dsZS5pbWEuQWRzUmVxdWVzdCgpO1xuICAgICAgICByZXF1ZXN0LmFkVGFnVXJsID0gdGhpcy50YWdVcmw7XG5cbiAgICAgICAgLy8gU3BlY2lmeSB0aGUgbGluZWFyIGFuZCBub25saW5lYXIgc2xvdCBzaXplcy4gVGhpcyBoZWxwcyB0aGUgU0RLXG4gICAgICAgIC8vIHRvIHNlbGVjdCB0aGUgY29ycmVjdCBjcmVhdGl2ZSBpZiBtdWx0aXBsZSBhcmUgcmV0dXJuZWRcbiAgICAgICAgcmVxdWVzdC5saW5lYXJBZFNsb3RXaWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICAgICAgcmVxdWVzdC5saW5lYXJBZFNsb3RIZWlnaHQgPSBjb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgICByZXF1ZXN0Lm5vbkxpbmVhckFkU2xvdFdpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoO1xuICAgICAgICByZXF1ZXN0Lm5vbkxpbmVhckFkU2xvdEhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgLy8gV2Ugb25seSBvdmVybGF5IGFkcyBhcyB3ZSBvbmx5IHN1cHBvcnQgdmlkZW8uXG4gICAgICAgIHJlcXVlc3QuZm9yY2VOb25MaW5lYXJGdWxsU2xvdCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIE11dGUgYmFzZWQgb24gY3VycmVudCBzdGF0ZVxuICAgICAgICByZXF1ZXN0LnNldEFkV2lsbFBsYXlNdXRlZCghdGhpcy5wbGF5ZXIubXV0ZWQpO1xuICAgICAgICB0aGlzLmxvYWRlci5yZXF1ZXN0QWRzKHJlcXVlc3QpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5vbkFkRXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgYWQgY291bnRkb3duXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdGFydFxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwicG9sbENvdW50ZG93blwiLCAoc3RhcnQgPSBmYWxzZSkgPT4ge1xuICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY291bnRkb3duVGltZXIpO1xuICAgICAgICB0aGlzLmVsZW1lbnRzLmNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtYmFkZ2UtdGV4dCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB1cGRhdGUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRpbWUgPSBmb3JtYXRUaW1lKE1hdGgubWF4KHRoaXMubWFuYWdlci5nZXRSZW1haW5pbmdUaW1lKCksIDApKTtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBgJHtpMThuLmdldCgnYWR2ZXJ0aXNlbWVudCcsIHRoaXMucGxheWVyLmNvbmZpZyl9IC0gJHt0aW1lfWA7XG4gICAgICAgIHRoaXMuZWxlbWVudHMuY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnZGF0YS1iYWRnZS10ZXh0JywgbGFiZWwpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuY291bnRkb3duVGltZXIgPSBzZXRJbnRlcnZhbCh1cGRhdGUsIDEwMCk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSBhZHMgYXJlIHJlYWR5IGluc2lkZSB0aGUgQWREaXNwbGF5Q29udGFpbmVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBhZHNNYW5hZ2VyTG9hZGVkRXZlbnRcbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkkMSh0aGlzLCBcIm9uQWRzTWFuYWdlckxvYWRlZFwiLCBldmVudCA9PiB7XG4gICAgICAvLyBMb2FkIGNvdWxkIG9jY3VyIGFmdGVyIGEgc291cmNlIGNoYW5nZSAocmFjZSBjb25kaXRpb24pXG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB0aGUgYWRzIG1hbmFnZXJcbiAgICAgIGNvbnN0IHNldHRpbmdzID0gbmV3IGdvb2dsZS5pbWEuQWRzUmVuZGVyaW5nU2V0dGluZ3MoKTtcblxuICAgICAgLy8gVGVsbCB0aGUgU0RLIHRvIHNhdmUgYW5kIHJlc3RvcmUgY29udGVudCB2aWRlbyBzdGF0ZSBvbiBvdXIgYmVoYWxmXG4gICAgICBzZXR0aW5ncy5yZXN0b3JlQ3VzdG9tUGxheWJhY2tTdGF0ZU9uQWRCcmVha0NvbXBsZXRlID0gdHJ1ZTtcbiAgICAgIHNldHRpbmdzLmVuYWJsZVByZWxvYWRpbmcgPSB0cnVlO1xuXG4gICAgICAvLyBUaGUgU0RLIGlzIHBvbGxpbmcgY3VycmVudFRpbWUgb24gdGhlIGNvbnRlbnRQbGF5YmFjay4gQW5kIG5lZWRzIGEgZHVyYXRpb25cbiAgICAgIC8vIHNvIGl0IGNhbiBkZXRlcm1pbmUgd2hlbiB0byBzdGFydCB0aGUgbWlkLSBhbmQgcG9zdC1yb2xsXG4gICAgICB0aGlzLm1hbmFnZXIgPSBldmVudC5nZXRBZHNNYW5hZ2VyKHRoaXMucGxheWVyLCBzZXR0aW5ncyk7XG5cbiAgICAgIC8vIEdldCB0aGUgY3VlIHBvaW50cyBmb3IgYW55IG1pZC1yb2xscyBieSBmaWx0ZXJpbmcgb3V0IHRoZSBwcmUtIGFuZCBwb3N0LXJvbGxcbiAgICAgIHRoaXMuY3VlUG9pbnRzID0gdGhpcy5tYW5hZ2VyLmdldEN1ZVBvaW50cygpO1xuXG4gICAgICAvLyBBZGQgbGlzdGVuZXJzIHRvIHRoZSByZXF1aXJlZCBldmVudHNcbiAgICAgIC8vIEFkdmVydGlzZW1lbnQgZXJyb3IgZXZlbnRzXG4gICAgICB0aGlzLm1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcihnb29nbGUuaW1hLkFkRXJyb3JFdmVudC5UeXBlLkFEX0VSUk9SLCBlcnJvciA9PiB0aGlzLm9uQWRFcnJvcihlcnJvcikpO1xuXG4gICAgICAvLyBBZHZlcnRpc2VtZW50IHJlZ3VsYXIgZXZlbnRzXG4gICAgICBPYmplY3Qua2V5cyhnb29nbGUuaW1hLkFkRXZlbnQuVHlwZSkuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIoZ29vZ2xlLmltYS5BZEV2ZW50LlR5cGVbdHlwZV0sIGUgPT4gdGhpcy5vbkFkRXZlbnQoZSkpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlc29sdmUgb3VyIGFkc01hbmFnZXJcbiAgICAgIHRoaXMudHJpZ2dlcignbG9hZGVkJyk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5JDEodGhpcywgXCJhZGRDdWVQb2ludHNcIiwgKCkgPT4ge1xuICAgICAgLy8gQWRkIGFkdmVydGlzZW1lbnQgY3VlJ3Mgd2l0aGluIHRoZSB0aW1lIGxpbmUgaWYgYXZhaWxhYmxlXG4gICAgICBpZiAoIWlzLmVtcHR5KHRoaXMuY3VlUG9pbnRzKSkge1xuICAgICAgICB0aGlzLmN1ZVBvaW50cy5mb3JFYWNoKGN1ZVBvaW50ID0+IHtcbiAgICAgICAgICBpZiAoY3VlUG9pbnQgIT09IDAgJiYgY3VlUG9pbnQgIT09IC0xICYmIGN1ZVBvaW50IDwgdGhpcy5wbGF5ZXIuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZWtFbGVtZW50ID0gdGhpcy5wbGF5ZXIuZWxlbWVudHMucHJvZ3Jlc3M7XG4gICAgICAgICAgICBpZiAoaXMuZWxlbWVudChzZWVrRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgY29uc3QgY3VlUGVyY2VudGFnZSA9IDEwMCAvIHRoaXMucGxheWVyLmR1cmF0aW9uICogY3VlUG9pbnQ7XG4gICAgICAgICAgICAgIGNvbnN0IGN1ZSA9IGNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IHRoaXMucGxheWVyLmNvbmZpZy5jbGFzc05hbWVzLmN1ZXNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGN1ZS5zdHlsZS5sZWZ0ID0gYCR7Y3VlUGVyY2VudGFnZS50b1N0cmluZygpfSVgO1xuICAgICAgICAgICAgICBzZWVrRWxlbWVudC5hcHBlbmRDaGlsZChjdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB3aGVyZSBhbGwgdGhlIGV2ZW50IGhhbmRsaW5nIHRha2VzIHBsYWNlLiBSZXRyaWV2ZSB0aGUgYWQgZnJvbSB0aGUgZXZlbnQuIFNvbWVcbiAgICAgKiBldmVudHMgKGUuZy4gQUxMX0FEU19DT01QTEVURUQpIGRvbid0IGhhdmUgdGhlIGFkIG9iamVjdCBhc3NvY2lhdGVkXG4gICAgICogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vaW50ZXJhY3RpdmUtbWVkaWEtYWRzL2RvY3Mvc2Rrcy9odG1sNS92My9hcGlzI2ltYS5BZEV2ZW50LlR5cGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwib25BZEV2ZW50XCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29udGFpbmVyXG4gICAgICB9ID0gdGhpcy5wbGF5ZXIuZWxlbWVudHM7XG4gICAgICAvLyBSZXRyaWV2ZSB0aGUgYWQgZnJvbSB0aGUgZXZlbnQuIFNvbWUgZXZlbnRzIChlLmcuIEFMTF9BRFNfQ09NUExFVEVEKVxuICAgICAgLy8gZG9uJ3QgaGF2ZSBhZCBvYmplY3QgYXNzb2NpYXRlZFxuICAgICAgY29uc3QgYWQgPSBldmVudC5nZXRBZCgpO1xuICAgICAgY29uc3QgYWREYXRhID0gZXZlbnQuZ2V0QWREYXRhKCk7XG5cbiAgICAgIC8vIFByb3h5IGV2ZW50XG4gICAgICBjb25zdCBkaXNwYXRjaEV2ZW50ID0gdHlwZSA9PiB7XG4gICAgICAgIHRyaWdnZXJFdmVudC5jYWxsKHRoaXMucGxheWVyLCB0aGlzLnBsYXllci5tZWRpYSwgYGFkcyR7dHlwZS5yZXBsYWNlKC9fL2csICcnKS50b0xvd2VyQ2FzZSgpfWApO1xuICAgICAgfTtcblxuICAgICAgLy8gQnViYmxlIHRoZSBldmVudFxuICAgICAgZGlzcGF0Y2hFdmVudChldmVudC50eXBlKTtcbiAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlIGdvb2dsZS5pbWEuQWRFdmVudC5UeXBlLkxPQURFRDpcbiAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBldmVudCBzZW50IGZvciBhbiBhZCAtIGl0IGlzIHBvc3NpYmxlIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZVxuICAgICAgICAgIC8vIGFkIGlzIGEgdmlkZW8gYWQgb3IgYW4gb3ZlcmxheVxuICAgICAgICAgIHRoaXMudHJpZ2dlcignbG9hZGVkJyk7XG5cbiAgICAgICAgICAvLyBTdGFydCBjb3VudGRvd25cbiAgICAgICAgICB0aGlzLnBvbGxDb3VudGRvd24odHJ1ZSk7XG4gICAgICAgICAgaWYgKCFhZC5pc0xpbmVhcigpKSB7XG4gICAgICAgICAgICAvLyBQb3NpdGlvbiBBZERpc3BsYXlDb250YWluZXIgY29ycmVjdGx5IGZvciBvdmVybGF5XG4gICAgICAgICAgICBhZC53aWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIGFkLmhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gY29uc29sZS5pbmZvKCdBZCB0eXBlOiAnICsgZXZlbnQuZ2V0QWQoKS5nZXRBZFBvZEluZm8oKS5nZXRQb2RJbmRleCgpKTtcbiAgICAgICAgICAvLyBjb25zb2xlLmluZm8oJ0FkIHRpbWU6ICcgKyBldmVudC5nZXRBZCgpLmdldEFkUG9kSW5mbygpLmdldFRpbWVPZmZzZXQoKSk7XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBnb29nbGUuaW1hLkFkRXZlbnQuVHlwZS5TVEFSVEVEOlxuICAgICAgICAgIC8vIFNldCB2b2x1bWUgdG8gbWF0Y2ggcGxheWVyXG4gICAgICAgICAgdGhpcy5tYW5hZ2VyLnNldFZvbHVtZSh0aGlzLnBsYXllci52b2x1bWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGdvb2dsZS5pbWEuQWRFdmVudC5UeXBlLkFMTF9BRFNfQ09NUExFVEVEOlxuICAgICAgICAgIC8vIEFsbCBhZHMgZm9yIHRoZSBjdXJyZW50IHZpZGVvcyBhcmUgZG9uZS4gV2UgY2FuIG5vdyByZXF1ZXN0IG5ldyBhZHZlcnRpc2VtZW50c1xuICAgICAgICAgIC8vIGluIGNhc2UgdGhlIHZpZGVvIGlzIHJlLXBsYXllZFxuXG4gICAgICAgICAgLy8gVE9ETzogRXhhbXBsZSBmb3Igd2hhdCBoYXBwZW5zIHdoZW4gYSBuZXh0IHZpZGVvIGluIGEgcGxheWxpc3Qgd291bGQgYmUgbG9hZGVkLlxuICAgICAgICAgIC8vIFNvIGhlcmUgd2UgbG9hZCBhIG5ldyB2aWRlbyB3aGVuIGFsbCBhZHMgYXJlIGRvbmUuXG4gICAgICAgICAgLy8gVGhlbiB3ZSBsb2FkIG5ldyBhZHMgd2l0aGluIGEgbmV3IGFkc01hbmFnZXIuIFdoZW4gdGhlIHZpZGVvXG4gICAgICAgICAgLy8gSXMgc3RhcnRlZCAtIGFmdGVyIC0gdGhlIGFkcyBhcmUgbG9hZGVkLCB0aGVuIHdlIGdldCBhZHMuXG4gICAgICAgICAgLy8gWW91IGNhbiBhbHNvIGVhc2lseSB0ZXN0IGNhbmNlbGxpbmcgYW5kIHJlbG9hZGluZyBieSBydW5uaW5nXG4gICAgICAgICAgLy8gcGxheWVyLmFkcy5jYW5jZWwoKSBhbmQgcGxheWVyLmFkcy5wbGF5IGZyb20gdGhlIGNvbnNvbGUgSSBndWVzcy5cbiAgICAgICAgICAvLyB0aGlzLnBsYXllci5zb3VyY2UgPSB7XG4gICAgICAgICAgLy8gICAgIHR5cGU6ICd2aWRlbycsXG4gICAgICAgICAgLy8gICAgIHRpdGxlOiAnVmlldyBGcm9tIEEgQmx1ZSBNb29uJyxcbiAgICAgICAgICAvLyAgICAgc291cmNlczogW3tcbiAgICAgICAgICAvLyAgICAgICAgIHNyYzpcbiAgICAgICAgICAvLyAnaHR0cHM6Ly9jZG4ucGx5ci5pby9zdGF0aWMvZGVtby9WaWV3X0Zyb21fQV9CbHVlX01vb25fVHJhaWxlci1IRC5tcDQnLCB0eXBlOlxuICAgICAgICAgIC8vICd2aWRlby9tcDQnLCB9XSwgcG9zdGVyOlxuICAgICAgICAgIC8vICdodHRwczovL2Nkbi5wbHlyLmlvL3N0YXRpYy9kZW1vL1ZpZXdfRnJvbV9BX0JsdWVfTW9vbl9UcmFpbGVyLUhELmpwZycsIHRyYWNrczpcbiAgICAgICAgICAvLyBbIHsga2luZDogJ2NhcHRpb25zJywgbGFiZWw6ICdFbmdsaXNoJywgc3JjbGFuZzogJ2VuJywgc3JjOlxuICAgICAgICAgIC8vICdodHRwczovL2Nkbi5wbHlyLmlvL3N0YXRpYy9kZW1vL1ZpZXdfRnJvbV9BX0JsdWVfTW9vbl9UcmFpbGVyLUhELmVuLnZ0dCcsXG4gICAgICAgICAgLy8gZGVmYXVsdDogdHJ1ZSwgfSwgeyBraW5kOiAnY2FwdGlvbnMnLCBsYWJlbDogJ0ZyZW5jaCcsIHNyY2xhbmc6ICdmcicsIHNyYzpcbiAgICAgICAgICAvLyAnaHR0cHM6Ly9jZG4ucGx5ci5pby9zdGF0aWMvZGVtby9WaWV3X0Zyb21fQV9CbHVlX01vb25fVHJhaWxlci1IRC5mci52dHQnLCB9LCBdLFxuICAgICAgICAgIC8vIH07XG5cbiAgICAgICAgICAvLyBUT0RPOiBTbyB0aGVyZSBpcyBzdGlsbCB0aGlzIHRoaW5nIHdoZXJlIGEgdmlkZW8gc2hvdWxkIG9ubHkgYmUgYWxsb3dlZCB0byBzdGFydFxuICAgICAgICAgIC8vIHBsYXlpbmcgd2hlbiB0aGUgSU1BIFNESyBpcyByZWFkeSBvciBoYXMgZmFpbGVkXG5cbiAgICAgICAgICBpZiAodGhpcy5wbGF5ZXIuZW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZEFkcygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgU0RLIHdvbid0IGFsbG93IG5ldyBhZHMgdG8gYmUgY2FsbGVkIHdpdGhvdXQgcmVjZWl2aW5nIGEgY29udGVudENvbXBsZXRlKClcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmNvbnRlbnRDb21wbGV0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBnb29nbGUuaW1hLkFkRXZlbnQuVHlwZS5DT05URU5UX1BBVVNFX1JFUVVFU1RFRDpcbiAgICAgICAgICAvLyBUaGlzIGV2ZW50IGluZGljYXRlcyB0aGUgYWQgaGFzIHN0YXJ0ZWQgLSB0aGUgdmlkZW8gcGxheWVyIGNhbiBhZGp1c3QgdGhlIFVJLFxuICAgICAgICAgIC8vIGZvciBleGFtcGxlIGRpc3BsYXkgYSBwYXVzZSBidXR0b24gYW5kIHJlbWFpbmluZyB0aW1lLiBGaXJlZCB3aGVuIGNvbnRlbnQgc2hvdWxkXG4gICAgICAgICAgLy8gYmUgcGF1c2VkLiBUaGlzIHVzdWFsbHkgaGFwcGVucyByaWdodCBiZWZvcmUgYW4gYWQgaXMgYWJvdXQgdG8gY292ZXIgdGhlIGNvbnRlbnRcblxuICAgICAgICAgIHRoaXMucGF1c2VDb250ZW50KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgZ29vZ2xlLmltYS5BZEV2ZW50LlR5cGUuQ09OVEVOVF9SRVNVTUVfUkVRVUVTVEVEOlxuICAgICAgICAgIC8vIFRoaXMgZXZlbnQgaW5kaWNhdGVzIHRoZSBhZCBoYXMgZmluaXNoZWQgLSB0aGUgdmlkZW8gcGxheWVyIGNhbiBwZXJmb3JtXG4gICAgICAgICAgLy8gYXBwcm9wcmlhdGUgVUkgYWN0aW9ucywgc3VjaCBhcyByZW1vdmluZyB0aGUgdGltZXIgZm9yIHJlbWFpbmluZyB0aW1lIGRldGVjdGlvbi5cbiAgICAgICAgICAvLyBGaXJlZCB3aGVuIGNvbnRlbnQgc2hvdWxkIGJlIHJlc3VtZWQuIFRoaXMgdXN1YWxseSBoYXBwZW5zIHdoZW4gYW4gYWQgZmluaXNoZXNcbiAgICAgICAgICAvLyBvciBjb2xsYXBzZXNcblxuICAgICAgICAgIHRoaXMucG9sbENvdW50ZG93bigpO1xuICAgICAgICAgIHRoaXMucmVzdW1lQ29udGVudCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGdvb2dsZS5pbWEuQWRFdmVudC5UeXBlLkxPRzpcbiAgICAgICAgICBpZiAoYWREYXRhLmFkRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMucGxheWVyLmRlYnVnLndhcm4oYE5vbi1mYXRhbCBhZCBlcnJvcjogJHthZERhdGEuYWRFcnJvci5nZXRNZXNzYWdlKCl9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEFueSBhZCBlcnJvciBoYW5kbGluZyBjb21lcyB0aHJvdWdoIGhlcmVcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwib25BZEVycm9yXCIsIGV2ZW50ID0+IHtcbiAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICB0aGlzLnBsYXllci5kZWJ1Zy53YXJuKCdBZHMgZXJyb3InLCBldmVudCk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogU2V0dXAgaG9va3MgZm9yIFBseXIgYW5kIHdpbmRvdyBldmVudHMuIFRoaXMgZW5zdXJlc1xuICAgICAqIHRoZSBtaWQtIGFuZCBwb3N0LXJvbGwgbGF1bmNoIGF0IHRoZSBjb3JyZWN0IHRpbWUuIEFuZFxuICAgICAqIHJlc2l6ZSB0aGUgYWR2ZXJ0aXNlbWVudCB3aGVuIHRoZSBwbGF5ZXIgcmVzaXplc1xuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwibGlzdGVuZXJzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29udGFpbmVyXG4gICAgICB9ID0gdGhpcy5wbGF5ZXIuZWxlbWVudHM7XG4gICAgICBsZXQgdGltZTtcbiAgICAgIHRoaXMucGxheWVyLm9uKCdjYW5wbGF5JywgKCkgPT4ge1xuICAgICAgICB0aGlzLmFkZEN1ZVBvaW50cygpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnBsYXllci5vbignZW5kZWQnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMubG9hZGVyLmNvbnRlbnRDb21wbGV0ZSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnBsYXllci5vbigndGltZXVwZGF0ZScsICgpID0+IHtcbiAgICAgICAgdGltZSA9IHRoaXMucGxheWVyLmN1cnJlbnRUaW1lO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnBsYXllci5vbignc2Vla2VkJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBzZWVrZWRUaW1lID0gdGhpcy5wbGF5ZXIuY3VycmVudFRpbWU7XG4gICAgICAgIGlmIChpcy5lbXB0eSh0aGlzLmN1ZVBvaW50cykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdWVQb2ludHMuZm9yRWFjaCgoY3VlUG9pbnQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKHRpbWUgPCBjdWVQb2ludCAmJiBjdWVQb2ludCA8IHNlZWtlZFRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5kaXNjYXJkQWRCcmVhaygpO1xuICAgICAgICAgICAgdGhpcy5jdWVQb2ludHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIExpc3RlbiB0byB0aGUgcmVzaXppbmcgb2YgdGhlIHdpbmRvdy4gQW5kIHJlc2l6ZSBhZCBhY2NvcmRpbmdseVxuICAgICAgLy8gVE9ETzogZXZlbnR1YWxseSBpbXBsZW1lbnQgUmVzaXplT2JzZXJ2ZXJcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLm1hbmFnZXIpIHtcbiAgICAgICAgICB0aGlzLm1hbmFnZXIucmVzaXplKGNvbnRhaW5lci5vZmZzZXRXaWR0aCwgY29udGFpbmVyLm9mZnNldEhlaWdodCwgZ29vZ2xlLmltYS5WaWV3TW9kZS5OT1JNQUwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBhZHNNYW5hZ2VyIGFuZCBzdGFydCBwbGF5aW5nIGFkdmVydGlzZW1lbnRzXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5JDEodGhpcywgXCJwbGF5XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29udGFpbmVyXG4gICAgICB9ID0gdGhpcy5wbGF5ZXIuZWxlbWVudHM7XG4gICAgICBpZiAoIXRoaXMubWFuYWdlclByb21pc2UpIHtcbiAgICAgICAgdGhpcy5yZXN1bWVDb250ZW50KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFBsYXkgdGhlIHJlcXVlc3RlZCBhZHZlcnRpc2VtZW50IHdoZW5ldmVyIHRoZSBhZHNNYW5hZ2VyIGlzIHJlYWR5XG4gICAgICB0aGlzLm1hbmFnZXJQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAvLyBTZXQgdm9sdW1lIHRvIG1hdGNoIHBsYXllclxuICAgICAgICB0aGlzLm1hbmFnZXIuc2V0Vm9sdW1lKHRoaXMucGxheWVyLnZvbHVtZSk7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgY29udGFpbmVyLiBNdXN0IGJlIGRvbmUgdmlhIGEgdXNlciBhY3Rpb24gb24gbW9iaWxlIGRldmljZXNcbiAgICAgICAgdGhpcy5lbGVtZW50cy5kaXNwbGF5Q29udGFpbmVyLmluaXRpYWxpemUoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIGFkcyBtYW5hZ2VyLiBBZCBydWxlcyBwbGF5bGlzdCB3aWxsIHN0YXJ0IGF0IHRoaXMgdGltZVxuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmluaXQoY29udGFpbmVyLm9mZnNldFdpZHRoLCBjb250YWluZXIub2Zmc2V0SGVpZ2h0LCBnb29nbGUuaW1hLlZpZXdNb2RlLk5PUk1BTCk7XG5cbiAgICAgICAgICAgIC8vIENhbGwgcGxheSB0byBzdGFydCBzaG93aW5nIHRoZSBhZC4gU2luZ2xlIHZpZGVvIGFuZCBvdmVybGF5IGFkcyB3aWxsXG4gICAgICAgICAgICAvLyBzdGFydCBhdCB0aGlzIHRpbWU7IHRoZSBjYWxsIHdpbGwgYmUgaWdub3JlZCBmb3IgYWQgcnVsZXNcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5zdGFydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoYWRFcnJvcikge1xuICAgICAgICAgIC8vIEFuIGVycm9yIG1heSBiZSB0aHJvd24gaWYgdGhlcmUgd2FzIGEgcHJvYmxlbSB3aXRoIHRoZVxuICAgICAgICAgIC8vIFZBU1QgcmVzcG9uc2VcbiAgICAgICAgICB0aGlzLm9uQWRFcnJvcihhZEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2goKCkgPT4ge30pO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJlc3VtZSBvdXIgdmlkZW9cbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkkMSh0aGlzLCBcInJlc3VtZUNvbnRlbnRcIiwgKCkgPT4ge1xuICAgICAgLy8gSGlkZSB0aGUgYWR2ZXJ0aXNlbWVudCBjb250YWluZXJcbiAgICAgIHRoaXMuZWxlbWVudHMuY29udGFpbmVyLnN0eWxlLnpJbmRleCA9ICcnO1xuXG4gICAgICAvLyBBZCBpcyBzdG9wcGVkXG4gICAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcblxuICAgICAgLy8gUGxheSB2aWRlb1xuICAgICAgc2lsZW5jZVByb21pc2UodGhpcy5wbGF5ZXIubWVkaWEucGxheSgpKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBQYXVzZSBvdXIgdmlkZW9cbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkkMSh0aGlzLCBcInBhdXNlQ29udGVudFwiLCAoKSA9PiB7XG4gICAgICAvLyBTaG93IHRoZSBhZHZlcnRpc2VtZW50IGNvbnRhaW5lclxuICAgICAgdGhpcy5lbGVtZW50cy5jb250YWluZXIuc3R5bGUuekluZGV4ID0gMztcblxuICAgICAgLy8gQWQgaXMgcGxheWluZ1xuICAgICAgdGhpcy5wbGF5aW5nID0gdHJ1ZTtcblxuICAgICAgLy8gUGF1c2Ugb3VyIHZpZGVvLlxuICAgICAgdGhpcy5wbGF5ZXIubWVkaWEucGF1c2UoKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95IHRoZSBhZHNNYW5hZ2VyIHNvIHdlIGNhbiBncmFiIG5ldyBhZHMgYWZ0ZXIgdGhpcy4gSWYgd2UgZG9uJ3QgdGhlbiB3ZSdyZSBub3RcbiAgICAgKiBhbGxvd2VkIHRvIGNhbGwgbmV3IGFkcyBiYXNlZCBvbiBnb29nbGUgcG9saWNpZXMsIGFzIHRoZXkgaW50ZXJwcmV0IHRoaXMgYXMgYW4gYWNjaWRlbnRhbFxuICAgICAqIHZpZGVvIHJlcXVlc3RzLiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9pbnRlcmFjdGl2ZS1cbiAgICAgKiBtZWRpYS1hZHMvZG9jcy9zZGtzL2FuZHJvaWQvZmFxIzhcbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkkMSh0aGlzLCBcImNhbmNlbFwiLCAoKSA9PiB7XG4gICAgICAvLyBQYXVzZSBvdXIgdmlkZW9cbiAgICAgIGlmICh0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMucmVzdW1lQ29udGVudCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBUZWxsIG91ciBpbnN0YW5jZSB0aGF0IHdlJ3JlIGRvbmUgZm9yIG5vd1xuICAgICAgdGhpcy50cmlnZ2VyKCdlcnJvcicpO1xuXG4gICAgICAvLyBSZS1jcmVhdGUgb3VyIGFkc01hbmFnZXJcbiAgICAgIHRoaXMubG9hZEFkcygpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJlLWNyZWF0ZSBvdXIgYWRzTWFuYWdlclxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwibG9hZEFkc1wiLCAoKSA9PiB7XG4gICAgICAvLyBUZWxsIG91ciBhZHNNYW5hZ2VyIHRvIGdvIGJ5ZSBieWVcbiAgICAgIHRoaXMubWFuYWdlclByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgIC8vIERlc3Ryb3kgb3VyIGFkc01hbmFnZXJcbiAgICAgICAgaWYgKHRoaXMubWFuYWdlcikge1xuICAgICAgICAgIHRoaXMubWFuYWdlci5kZXN0cm95KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZS1zZXQgb3VyIGFkc01hbmFnZXIgcHJvbWlzZXNcbiAgICAgICAgdGhpcy5tYW5hZ2VyUHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgIHRoaXMub24oJ2xvYWRlZCcsIHJlc29sdmUpO1xuICAgICAgICAgIHRoaXMucGxheWVyLmRlYnVnLmxvZyh0aGlzLm1hbmFnZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTm93IHRoYXQgdGhlIG1hbmFnZXIgaGFzIGJlZW4gZGVzdHJveWVkIHNldCBpdCB0byBhbHNvIGJlIHVuLWluaXRpYWxpemVkXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBOb3cgcmVxdWVzdCBzb21lIG5ldyBhZHZlcnRpc2VtZW50c1xuICAgICAgICB0aGlzLnJlcXVlc3RBZHMoKTtcbiAgICAgIH0pLmNhdGNoKCgpID0+IHt9KTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGNhbGxiYWNrcyBhZnRlciBhbiBhZCBldmVudCB3YXMgaW52b2tlZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAtIEV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0gYXJnc1xuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwidHJpZ2dlclwiLCAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy5ldmVudHNbZXZlbnRdO1xuICAgICAgaWYgKGlzLmFycmF5KGhhbmRsZXJzKSkge1xuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4ge1xuICAgICAgICAgIGlmIChpcy5mdW5jdGlvbihoYW5kbGVyKSkge1xuICAgICAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEFkZCBldmVudCBsaXN0ZW5lcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBFdmVudCB0eXBlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayBmb3Igd2hlbiBldmVudCBvY2N1cnNcbiAgICAgKiBAcmV0dXJuIHtBZHN9XG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5JDEodGhpcywgXCJvblwiLCAoZXZlbnQsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAoIWlzLmFycmF5KHRoaXMuZXZlbnRzW2V2ZW50XSkpIHtcbiAgICAgICAgdGhpcy5ldmVudHNbZXZlbnRdID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLmV2ZW50c1tldmVudF0ucHVzaChjYWxsYmFjayk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTZXR1cCBhIHNhZmV0eSB0aW1lciBmb3Igd2hlbiB0aGUgYWQgbmV0d29yayBkb2Vzbid0IHJlc3BvbmQgZm9yIHdoYXRldmVyIHJlYXNvbi5cbiAgICAgKiBUaGUgYWR2ZXJ0aXNlbWVudCBoYXMgMTIgc2Vjb25kcyB0byBnZXQgaXRzIHRoaW5ncyB0b2dldGhlci4gV2Ugc3RvcCB0aGlzIHRpbWVyIHdoZW4gdGhlXG4gICAgICogYWR2ZXJ0aXNlbWVudCBpcyBwbGF5aW5nLCBvciB3aGVuIGEgdXNlciBhY3Rpb24gaXMgcmVxdWlyZWQgdG8gc3RhcnQsIHRoZW4gd2UgY2xlYXIgdGhlXG4gICAgICogdGltZXIgb24gYWQgcmVhZHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5JDEodGhpcywgXCJzdGFydFNhZmV0eVRpbWVyXCIsICh0aW1lLCBmcm9tKSA9PiB7XG4gICAgICB0aGlzLnBsYXllci5kZWJ1Zy5sb2coYFNhZmV0eSB0aW1lciBpbnZva2VkIGZyb206ICR7ZnJvbX1gKTtcbiAgICAgIHRoaXMuc2FmZXR5VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5jbGVhclNhZmV0eVRpbWVyKCdzdGFydFNhZmV0eVRpbWVyKCknKTtcbiAgICAgIH0sIHRpbWUpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENsZWFyIG91ciBzYWZldHkgdGltZXIocylcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbVxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwiY2xlYXJTYWZldHlUaW1lclwiLCBmcm9tID0+IHtcbiAgICAgIGlmICghaXMubnVsbE9yVW5kZWZpbmVkKHRoaXMuc2FmZXR5VGltZXIpKSB7XG4gICAgICAgIHRoaXMucGxheWVyLmRlYnVnLmxvZyhgU2FmZXR5IHRpbWVyIGNsZWFyZWQgZnJvbTogJHtmcm9tfWApO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zYWZldHlUaW1lcik7XG4gICAgICAgIHRoaXMuc2FmZXR5VGltZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucGxheWVyID0gcGxheWVyO1xuICAgIHRoaXMuY29uZmlnID0gcGxheWVyLmNvbmZpZy5hZHM7XG4gICAgdGhpcy5wbGF5aW5nID0gZmFsc2U7XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuZWxlbWVudHMgPSB7XG4gICAgICBjb250YWluZXI6IG51bGwsXG4gICAgICBkaXNwbGF5Q29udGFpbmVyOiBudWxsXG4gICAgfTtcbiAgICB0aGlzLm1hbmFnZXIgPSBudWxsO1xuICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICB0aGlzLmN1ZVBvaW50cyA9IG51bGw7XG4gICAgdGhpcy5ldmVudHMgPSB7fTtcbiAgICB0aGlzLnNhZmV0eVRpbWVyID0gbnVsbDtcbiAgICB0aGlzLmNvdW50ZG93blRpbWVyID0gbnVsbDtcblxuICAgIC8vIFNldHVwIGEgcHJvbWlzZSB0byByZXNvbHZlIHdoZW4gdGhlIElNQSBtYW5hZ2VyIGlzIHJlYWR5XG4gICAgdGhpcy5tYW5hZ2VyUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8vIFRoZSBhZCBpcyBsb2FkZWQgYW5kIHJlYWR5XG4gICAgICB0aGlzLm9uKCdsb2FkZWQnLCByZXNvbHZlKTtcblxuICAgICAgLy8gQWRzIGZhaWxlZFxuICAgICAgdGhpcy5vbignZXJyb3InLCByZWplY3QpO1xuICAgIH0pO1xuICAgIHRoaXMubG9hZCgpO1xuICB9XG4gIGdldCBlbmFibGVkKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLnBsYXllci5pc0hUTUw1ICYmIHRoaXMucGxheWVyLmlzVmlkZW8gJiYgY29uZmlnLmVuYWJsZWQgJiYgKCFpcy5lbXB0eShjb25maWcucHVibGlzaGVySWQpIHx8IGlzLnVybChjb25maWcudGFnVXJsKSk7XG4gIH1cbiAgLy8gQnVpbGQgdGhlIHRhZyBVUkxcbiAgZ2V0IHRhZ1VybCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWdcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoaXMudXJsKGNvbmZpZy50YWdVcmwpKSB7XG4gICAgICByZXR1cm4gY29uZmlnLnRhZ1VybDtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgQVZfUFVCTElTSEVSSUQ6ICc1OGMyNWJiMDA3M2VmNDQ4YjEwODdhZDYnLFxuICAgICAgQVZfQ0hBTk5FTElEOiAnNWEwNDU4ZGMyOGEwNjE0NWU0NTE5ZDIxJyxcbiAgICAgIEFWX1VSTDogd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLFxuICAgICAgY2I6IERhdGUubm93KCksXG4gICAgICBBVl9XSURUSDogNjQwLFxuICAgICAgQVZfSEVJR0hUOiA0ODAsXG4gICAgICBBVl9DRElNMjogY29uZmlnLnB1Ymxpc2hlcklkXG4gICAgfTtcbiAgICBjb25zdCBiYXNlID0gJ2h0dHBzOi8vZ28uYW5pdmlldy5jb20vYXBpL2Fkc2VydmVyNi92YXN0Lyc7XG4gICAgcmV0dXJuIGAke2Jhc2V9PyR7YnVpbGRVcmxQYXJhbXMocGFyYW1zKX1gO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG51bWJlciB3aG9zZSB2YWx1ZSBpcyBsaW1pdGVkIHRvIHRoZSBnaXZlbiByYW5nZS5cbiAqXG4gKiBFeGFtcGxlOiBsaW1pdCB0aGUgb3V0cHV0IG9mIHRoaXMgY29tcHV0YXRpb24gdG8gYmV0d2VlbiAwIGFuZCAyNTVcbiAqICh4ICogMjU1KS5jbGFtcCgwLCAyNTUpXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGlucHV0XG4gKiBAcGFyYW0ge251bWJlcn0gbWluIFRoZSBsb3dlciBib3VuZGFyeSBvZiB0aGUgb3V0cHV0IHJhbmdlXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4IFRoZSB1cHBlciBib3VuZGFyeSBvZiB0aGUgb3V0cHV0IHJhbmdlXG4gKiBAcmV0dXJucyBBIG51bWJlciB3aXRoaW4gdGhlIGJvdW5kcyBvZiBtaW4gYW5kIG1heFxuICogQHR5cGUgTnVtYmVyXG4gKi9cbmZ1bmN0aW9uIGNsYW1wKGlucHV0ID0gMCwgbWluID0gMCwgbWF4ID0gMjU1KSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChpbnB1dCwgbWluKSwgbWF4KTtcbn1cblxuLy8gQXJnOiB2dHREYXRhU3RyaW5nIGV4YW1wbGU6IFwiV0VCVlRUXFxuXFxuMVxcbjAwOjAwOjA1LjAwMCAtLT4gMDA6MDA6MTAuMDAwXFxuMTA4MHAtMDAwMDEuanBnXCJcbmZ1bmN0aW9uIHBhcnNlVnR0KHZ0dERhdGFTdHJpbmcpIHtcbiAgY29uc3QgcHJvY2Vzc2VkTGlzdCA9IFtdO1xuICBjb25zdCBmcmFtZXMgPSB2dHREYXRhU3RyaW5nLnNwbGl0KC9cXHJcXG5cXHJcXG58XFxuXFxufFxcclxcci8pO1xuICBmcmFtZXMuZm9yRWFjaChmcmFtZSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgY29uc3QgbGluZXMgPSBmcmFtZS5zcGxpdCgvXFxyXFxufFxcbnxcXHIvKTtcbiAgICBsaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgaWYgKCFpcy5udW1iZXIocmVzdWx0LnN0YXJ0VGltZSkpIHtcbiAgICAgICAgLy8gVGhlIGxpbmUgd2l0aCBzdGFydCBhbmQgZW5kIHRpbWVzIG9uIGl0IGlzIHRoZSBmaXJzdCBsaW5lIG9mIGludGVyZXN0XG4gICAgICAgIGNvbnN0IG1hdGNoVGltZXMgPSBsaW5lLm1hdGNoKC8oXFxkezJ9KT86PyhcXGR7Mn0pOihcXGR7Mn0pLihcXGR7MiwzfSkoID8tLT4gPykoXFxkezJ9KT86PyhcXGR7Mn0pOihcXGR7Mn0pLihcXGR7MiwzfSkvKTsgLy8gTm90ZSB0aGF0IHRoaXMgY3VycmVudGx5IGlnbm9yZXMgY2FwdGlvbiBmb3JtYXR0aW5nIGRpcmVjdGl2ZXMgdGhhdCBhcmUgb3B0aW9uYWxseSBvbiB0aGUgZW5kIG9mIHRoaXMgbGluZSAtIGZpbmUgZm9yIG5vbi1jYXB0aW9ucyBWVFRcblxuICAgICAgICBpZiAobWF0Y2hUaW1lcykge1xuICAgICAgICAgIHJlc3VsdC5zdGFydFRpbWUgPSBOdW1iZXIobWF0Y2hUaW1lc1sxXSB8fCAwKSAqIDYwICogNjAgKyBOdW1iZXIobWF0Y2hUaW1lc1syXSkgKiA2MCArIE51bWJlcihtYXRjaFRpbWVzWzNdKSArIE51bWJlcihgMC4ke21hdGNoVGltZXNbNF19YCk7XG4gICAgICAgICAgcmVzdWx0LmVuZFRpbWUgPSBOdW1iZXIobWF0Y2hUaW1lc1s2XSB8fCAwKSAqIDYwICogNjAgKyBOdW1iZXIobWF0Y2hUaW1lc1s3XSkgKiA2MCArIE51bWJlcihtYXRjaFRpbWVzWzhdKSArIE51bWJlcihgMC4ke21hdGNoVGltZXNbOV19YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWlzLmVtcHR5KGxpbmUudHJpbSgpKSAmJiBpcy5lbXB0eShyZXN1bHQudGV4dCkpIHtcbiAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBoYXZlIHRoZSBzdGFydFRpbWUsIHRoZW4gd2UncmUgZGVmaW5pdGVseSB1cCB0byB0aGUgdGV4dCBsaW5lKHMpXG4gICAgICAgIGNvbnN0IGxpbmVTcGxpdCA9IGxpbmUudHJpbSgpLnNwbGl0KCcjeHl3aD0nKTtcbiAgICAgICAgW3Jlc3VsdC50ZXh0XSA9IGxpbmVTcGxpdDtcblxuICAgICAgICAvLyBJZiB0aGVyZSdzIGNvbnRlbnQgaW4gbGluZVNwbGl0WzFdLCB0aGVuIHdlIGhhdmUgc3ByaXRlcy4gSWYgbm90LCB0aGVuIGl0J3MganVzdCBvbmUgZnJhbWUgcGVyIGltYWdlXG4gICAgICAgIGlmIChsaW5lU3BsaXRbMV0pIHtcbiAgICAgICAgICBbcmVzdWx0LngsIHJlc3VsdC55LCByZXN1bHQudywgcmVzdWx0LmhdID0gbGluZVNwbGl0WzFdLnNwbGl0KCcsJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LnRleHQpIHtcbiAgICAgIHByb2Nlc3NlZExpc3QucHVzaChyZXN1bHQpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwcm9jZXNzZWRMaXN0O1xufVxuXG4vKipcbiAqIFByZXZpZXcgdGh1bWJuYWlscyBmb3Igc2VlayBob3ZlciBhbmQgc2NydWJiaW5nXG4gKiBTZWVraW5nOiBIb3ZlciBvdmVyIHRoZSBzZWVrIGJhciAoZGVza3RvcCBvbmx5KTogc2hvd3MgYSBzbWFsbCBwcmV2aWV3IGNvbnRhaW5lciBhYm92ZSB0aGUgc2VlayBiYXJcbiAqIFNjcnViYmluZzogQ2xpY2sgYW5kIGRyYWcgdGhlIHNlZWsgYmFyIChkZXNrdG9wIGFuZCBtb2JpbGUpOiBzaG93cyB0aGUgcHJldmlldyBpbWFnZSBvdmVyIHRoZSBlbnRpcmUgdmlkZW8sIGFzIGlmIHRoZSB2aWRlbyBpcyBzY3J1YmJpbmcgYXQgdmVyeSBoaWdoIHNwZWVkXG4gKlxuICogTm90ZXM6XG4gKiAtIFRodW1icyBhcmUgc2V0IHZpYSBKUyBzZXR0aW5ncyBvbiBQbHlyIGluaXQsIG5vdCBIVE1MNSAndHJhY2snIHByb3BlcnR5LiBVc2luZyB0aGUgdHJhY2sgcHJvcGVydHkgd291bGQgYmUgYSBiaXQgZ3Jvc3MsIGJlY2F1c2UgaXQgZG9lc24ndCBzdXBwb3J0IGN1c3RvbSAna2luZHMnLiBraW5kPW1ldGFkYXRhIG1pZ2h0IGJlIHVzZWQgZm9yIHNvbWV0aGluZyBlbHNlLCBhbmQgd2Ugd2FudCB0byBhbGxvdyBtdWx0aXBsZSB0aHVtYm5haWxzIHRyYWNrcy4gVHJhY2tzIG11c3QgaGF2ZSBhIHVuaXF1ZSBjb21iaW5hdGlvbiBvZiAna2luZCcgYW5kICdsYWJlbCcuIFdlIHdvdWxkIGhhdmUgdG8gZG8gc29tZXRoaW5nIGxpa2Uga2luZD1tZXRhZGF0YSxsYWJlbD10aHVtYm5haWxzMSAvIGtpbmQ9bWV0YWRhdGEsbGFiZWw9dGh1bWJuYWlsczIuIFNxdWFyZSBwZWcsIHJvdW5kIGhvbGVcbiAqIC0gVlRUIGluZm86IHRoZSBpbWFnZSBVUkwgaXMgcmVsYXRpdmUgdG8gdGhlIFZUVCwgbm90IHRoZSBjdXJyZW50IGRvY3VtZW50LiBCdXQgaWYgdGhlIHVybCBzdGFydHMgd2l0aCBhIHNsYXNoLCBpdCB3aWxsIG5hdHVyYWxseSBiZSByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBkb21haW4uIGh0dHBzOi8vc3VwcG9ydC5qd3BsYXllci5jb20vYXJ0aWNsZXMvaG93LXRvLWFkZC1wcmV2aWV3LXRodW1ibmFpbHNcbiAqIC0gVGhpcyBpbXBsZW1lbnRhdGlvbiB1c2VzIG11bHRpcGxlIHNlcGFyYXRlIGltZyBlbGVtZW50cy4gT3RoZXIgaW1wbGVtZW50YXRpb25zIHVzZSBiYWNrZ3JvdW5kLWltYWdlIG9uIG9uZSBlbGVtZW50LiBUaGlzIHdvdWxkIGJlIG5pY2UgYW5kIHNpbXBsZSwgYnV0IEZpcmVmb3ggYW5kIFNhZmFyaSBoYXZlIGZsaWNrZXJpbmcgaXNzdWVzIHdpdGggcmVwbGFjaW5nIGJhY2tncm91bmRzIG9mIGxhcmdlciBpbWFnZXMuIEl0IHNlZW1zIHRoYXQgWW91VHViZSBwZXJoYXBzIG9ubHkgYXZvaWRzIHRoaXMgYmVjYXVzZSB0aGV5IGRvbid0IGhhdmUgdGhlIG9wdGlvbiBmb3IgaGlnaC1yZXMgcHJldmlld3MgKGV2ZW4gdGhlIGZ1bGxzY3JlZW4gb25lcywgd2hlbiBtb3VzZWRvd24vc2Vla2luZykuIEltYWdlcyBhcHBlYXIgb3ZlciB0aGUgdG9wIG9mIGVhY2ggb3RoZXIsIGFuZCBwcmV2aW91cyBvbmVzIGFyZSBkaXNjYXJkZWQgb25jZSB0aGUgbmV3IG9uZXMgaGF2ZSBiZWVuIHJlbmRlcmVkXG4gKi9cblxuZnVuY3Rpb24gZml0UmF0aW8ocmF0aW8sIG91dGVyKSB7XG4gIGNvbnN0IHRhcmdldFJhdGlvID0gb3V0ZXIud2lkdGggLyBvdXRlci5oZWlnaHQ7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBpZiAocmF0aW8gPiB0YXJnZXRSYXRpbykge1xuICAgIHJlc3VsdC53aWR0aCA9IG91dGVyLndpZHRoO1xuICAgIHJlc3VsdC5oZWlnaHQgPSAxIC8gcmF0aW8gKiBvdXRlci53aWR0aDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQuaGVpZ2h0ID0gb3V0ZXIuaGVpZ2h0O1xuICAgIHJlc3VsdC53aWR0aCA9IHJhdGlvICogb3V0ZXIuaGVpZ2h0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5jbGFzcyBQcmV2aWV3VGh1bWJuYWlscyB7XG4gIC8qKlxuICAgKiBQcmV2aWV3VGh1bWJuYWlscyBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHtQbHlyfSBwbGF5ZXJcbiAgICogQHJldHVybiB7UHJldmlld1RodW1ibmFpbHN9XG4gICAqL1xuICBjb25zdHJ1Y3RvcihwbGF5ZXIpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkkMSh0aGlzLCBcImxvYWRcIiwgKCkgPT4ge1xuICAgICAgLy8gVG9nZ2xlIHRoZSByZWd1bGFyIHNlZWsgdG9vbHRpcFxuICAgICAgaWYgKHRoaXMucGxheWVyLmVsZW1lbnRzLmRpc3BsYXkuc2Vla1Rvb2x0aXApIHtcbiAgICAgICAgdGhpcy5wbGF5ZXIuZWxlbWVudHMuZGlzcGxheS5zZWVrVG9vbHRpcC5oaWRkZW4gPSB0aGlzLmVuYWJsZWQ7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgdGhpcy5nZXRUaHVtYm5haWxzKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVuZGVyIERPTSBlbGVtZW50c1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuXG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aHVtYiBjb250YWluZXIgc2l6ZSB3YXMgc3BlY2lmaWVkIG1hbnVhbGx5IGluIENTU1xuICAgICAgICB0aGlzLmRldGVybWluZUNvbnRhaW5lckF1dG9TaXppbmcoKTtcblxuICAgICAgICAvLyBTZXQgdXAgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMubGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIERvd25sb2FkIFZUVCBmaWxlcyBhbmQgcGFyc2UgdGhlbVxuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwiZ2V0VGh1bWJuYWlsc1wiLCAoKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzcmNcbiAgICAgICAgfSA9IHRoaXMucGxheWVyLmNvbmZpZy5wcmV2aWV3VGh1bWJuYWlscztcbiAgICAgICAgaWYgKGlzLmVtcHR5KHNyYykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHJldmlld1RodW1ibmFpbHMuc3JjIGNvbmZpZyBhdHRyaWJ1dGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc29sdmUgcHJvbWlzZVxuICAgICAgICBjb25zdCBzb3J0QW5kUmVzb2x2ZSA9ICgpID0+IHtcbiAgICAgICAgICAvLyBTb3J0IHNtYWxsZXN0IHRvIGJpZ2dlc3QgKGUuZy4sIFsxMjBwLCA0ODBwLCAxMDgwcF0pXG4gICAgICAgICAgdGhpcy50aHVtYm5haWxzLnNvcnQoKHgsIHkpID0+IHguaGVpZ2h0IC0geS5oZWlnaHQpO1xuICAgICAgICAgIHRoaXMucGxheWVyLmRlYnVnLmxvZygnUHJldmlldyB0aHVtYm5haWxzJywgdGhpcy50aHVtYm5haWxzKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVmlhIGNhbGxiYWNrKClcbiAgICAgICAgaWYgKGlzLmZ1bmN0aW9uKHNyYykpIHtcbiAgICAgICAgICBzcmModGh1bWJuYWlscyA9PiB7XG4gICAgICAgICAgICB0aGlzLnRodW1ibmFpbHMgPSB0aHVtYm5haWxzO1xuICAgICAgICAgICAgc29ydEFuZFJlc29sdmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBWVFQgdXJsc1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBJZiBzdHJpbmcsIGNvbnZlcnQgaW50byBzaW5nbGUtZWxlbWVudCBsaXN0XG4gICAgICAgICAgY29uc3QgdXJscyA9IGlzLnN0cmluZyhzcmMpID8gW3NyY10gOiBzcmM7XG4gICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGVhY2ggc3JjIFVSTC4gRG93bmxvYWQgYW5kIHByb2Nlc3MgdGhlIFZUVCBmaWxlLCBzdG9yaW5nIHRoZSByZXN1bHRpbmcgZGF0YSBpbiB0aGlzLnRodW1ibmFpbHNcbiAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IHVybHMubWFwKHUgPT4gdGhpcy5nZXRUaHVtYm5haWwodSkpO1xuICAgICAgICAgIC8vIFJlc29sdmVcbiAgICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihzb3J0QW5kUmVzb2x2ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIFByb2Nlc3MgaW5kaXZpZHVhbCBWVFQgZmlsZVxuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwiZ2V0VGh1bWJuYWlsXCIsIHVybCA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGZldGNoKHVybCwgdW5kZWZpbmVkLCB0aGlzLnBsYXllci5jb25maWcucHJldmlld1RodW1ibmFpbHMud2l0aENyZWRlbnRpYWxzKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICBjb25zdCB0aHVtYm5haWwgPSB7XG4gICAgICAgICAgICBmcmFtZXM6IHBhcnNlVnR0KHJlc3BvbnNlKSxcbiAgICAgICAgICAgIGhlaWdodDogbnVsbCxcbiAgICAgICAgICAgIHVybFByZWZpeDogJydcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gSWYgdGhlIFVSTHMgZG9uJ3Qgc3RhcnQgd2l0aCAnLycsIHRoZW4gd2UgbmVlZCB0byBzZXQgdGhlaXIgcmVsYXRpdmUgcGF0aCB0byBiZSB0aGUgbG9jYXRpb24gb2YgdGhlIFZUVCBmaWxlXG4gICAgICAgICAgLy8gSWYgdGhlIFVSTHMgZG8gc3RhcnQgd2l0aCAnLycsIHRoZW4gdGhleSBvYnZpb3VzbHkgZG9uJ3QgbmVlZCBhIHByZWZpeCwgc28gaXQgd2lsbCByZW1haW4gYmxhbmtcbiAgICAgICAgICAvLyBJZiB0aGUgdGh1bWJuYWlsIFVSTHMgc3RhcnQgd2l0aCB3aXRoIG5vbmUgb2YgJy8nLCAnaHR0cDovLycgb3IgJ2h0dHBzOi8vJywgdGhlbiB3ZSBuZWVkIHRvIHNldCB0aGVpciByZWxhdGl2ZSBwYXRoIHRvIGJlIHRoZSBsb2NhdGlvbiBvZiB0aGUgVlRUIGZpbGVcbiAgICAgICAgICBpZiAoIXRodW1ibmFpbC5mcmFtZXNbMF0udGV4dC5zdGFydHNXaXRoKCcvJykgJiYgIXRodW1ibmFpbC5mcmFtZXNbMF0udGV4dC5zdGFydHNXaXRoKCdodHRwOi8vJykgJiYgIXRodW1ibmFpbC5mcmFtZXNbMF0udGV4dC5zdGFydHNXaXRoKCdodHRwczovLycpKSB7XG4gICAgICAgICAgICB0aHVtYm5haWwudXJsUHJlZml4ID0gdXJsLnN1YnN0cmluZygwLCB1cmwubGFzdEluZGV4T2YoJy8nKSArIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERvd25sb2FkIHRoZSBmaXJzdCBmcmFtZSwgc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lL3NldCB0aGUgaGVpZ2h0IG9mIHRoaXMgdGh1bWJuYWlsc0RlZlxuICAgICAgICAgIGNvbnN0IHRlbXBJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgIHRlbXBJbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aHVtYm5haWwuaGVpZ2h0ID0gdGVtcEltYWdlLm5hdHVyYWxIZWlnaHQ7XG4gICAgICAgICAgICB0aHVtYm5haWwud2lkdGggPSB0ZW1wSW1hZ2UubmF0dXJhbFdpZHRoO1xuICAgICAgICAgICAgdGhpcy50aHVtYm5haWxzLnB1c2godGh1bWJuYWlsKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRlbXBJbWFnZS5zcmMgPSB0aHVtYm5haWwudXJsUHJlZml4ICsgdGh1bWJuYWlsLmZyYW1lc1swXS50ZXh0O1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwic3RhcnRNb3ZlXCIsIGV2ZW50ID0+IHtcbiAgICAgIGlmICghdGhpcy5sb2FkZWQpIHJldHVybjtcbiAgICAgIGlmICghaXMuZXZlbnQoZXZlbnQpIHx8ICFbJ3RvdWNobW92ZScsICdtb3VzZW1vdmUnXS5pbmNsdWRlcyhldmVudC50eXBlKSkgcmV0dXJuO1xuXG4gICAgICAvLyBXYWl0IHVudGlsIG1lZGlhIGhhcyBhIGR1cmF0aW9uXG4gICAgICBpZiAoIXRoaXMucGxheWVyLm1lZGlhLmR1cmF0aW9uKSByZXR1cm47XG4gICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHNlZWsgaG92ZXIgcG9zaXRpb24gYXMgYXBwcm94IHZpZGVvIHNlY29uZHNcbiAgICAgICAgdGhpcy5zZWVrVGltZSA9IHRoaXMucGxheWVyLm1lZGlhLmR1cmF0aW9uICogKHRoaXMucGxheWVyLmVsZW1lbnRzLmlucHV0cy5zZWVrLnZhbHVlIC8gMTAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfdGhpcyRwbGF5ZXIkY29uZmlnJG0sIF90aGlzJHBsYXllciRjb25maWckbTI7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBzZWVrIGhvdmVyIHBvc2l0aW9uIGFzIGFwcHJveCB2aWRlbyBzZWNvbmRzXG4gICAgICAgIGNvbnN0IGNsaWVudFJlY3QgPSB0aGlzLnBsYXllci5lbGVtZW50cy5wcm9ncmVzcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IDEwMCAvIGNsaWVudFJlY3Qud2lkdGggKiAoZXZlbnQucGFnZVggLSBjbGllbnRSZWN0LmxlZnQpO1xuICAgICAgICB0aGlzLnNlZWtUaW1lID0gdGhpcy5wbGF5ZXIubWVkaWEuZHVyYXRpb24gKiAocGVyY2VudGFnZSAvIDEwMCk7XG4gICAgICAgIGlmICh0aGlzLnNlZWtUaW1lIDwgMCkge1xuICAgICAgICAgIC8vIFRoZSBtb3VzZW1vdmUgZmlyZXMgZm9yIDEwK3B4IG91dCB0byB0aGUgbGVmdFxuICAgICAgICAgIHRoaXMuc2Vla1RpbWUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNlZWtUaW1lID4gdGhpcy5wbGF5ZXIubWVkaWEuZHVyYXRpb24gLSAxKSB7XG4gICAgICAgICAgLy8gVG9vayAxIHNlY29uZCBvZmYgdGhlIGR1cmF0aW9uIGZvciBzYWZldHksIGJlY2F1c2UgZGlmZmVyZW50IHBsYXllcnMgY2FuIGRpc2FncmVlIG9uIHRoZSByZWFsIGR1cmF0aW9uIG9mIGEgdmlkZW9cbiAgICAgICAgICB0aGlzLnNlZWtUaW1lID0gdGhpcy5wbGF5ZXIubWVkaWEuZHVyYXRpb24gLSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW91c2VQb3NYID0gZXZlbnQucGFnZVg7XG5cbiAgICAgICAgLy8gU2V0IHRpbWUgdGV4dCBpbnNpZGUgaW1hZ2UgY29udGFpbmVyXG4gICAgICAgIHRoaXMuZWxlbWVudHMudGh1bWIudGltZS50ZXh0Q29udGVudCA9IGZvcm1hdFRpbWUodGhpcy5zZWVrVGltZSk7XG5cbiAgICAgICAgLy8gR2V0IG1hcmtlciBwb2ludCBmb3IgdGltZVxuICAgICAgICBjb25zdCBwb2ludCA9IChfdGhpcyRwbGF5ZXIkY29uZmlnJG0gPSB0aGlzLnBsYXllci5jb25maWcubWFya2VycykgPT09IG51bGwgfHwgX3RoaXMkcGxheWVyJGNvbmZpZyRtID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3RoaXMkcGxheWVyJGNvbmZpZyRtMiA9IF90aGlzJHBsYXllciRjb25maWckbS5wb2ludHMpID09PSBudWxsIHx8IF90aGlzJHBsYXllciRjb25maWckbTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJHBsYXllciRjb25maWckbTIuZmluZCgoe1xuICAgICAgICAgIHRpbWU6IHRcbiAgICAgICAgfSkgPT4gdCA9PT0gTWF0aC5yb3VuZCh0aGlzLnNlZWtUaW1lKSk7XG5cbiAgICAgICAgLy8gQXBwZW5kIHRoZSBwb2ludCBsYWJlbCB0byB0aGUgdG9vbHRpcFxuICAgICAgICBpZiAocG9pbnQpIHtcbiAgICAgICAgICAvLyB0aGlzLmVsZW1lbnRzLnRodW1iLnRpbWUuaW5uZXJUZXh0LmNvbmNhdCgnXFxuJyk7XG4gICAgICAgICAgdGhpcy5lbGVtZW50cy50aHVtYi50aW1lLmluc2VydEFkamFjZW50SFRNTCgnYWZ0ZXJiZWdpbicsIGAke3BvaW50LmxhYmVsfTxicj5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEb3dubG9hZCBhbmQgc2hvdyBpbWFnZVxuICAgICAgdGhpcy5zaG93SW1hZ2VBdEN1cnJlbnRUaW1lKCk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5JDEodGhpcywgXCJlbmRNb3ZlXCIsICgpID0+IHtcbiAgICAgIHRoaXMudG9nZ2xlVGh1bWJDb250YWluZXIoZmFsc2UsIHRydWUpO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwic3RhcnRTY3J1YmJpbmdcIiwgZXZlbnQgPT4ge1xuICAgICAgLy8gT25seSBhY3Qgb24gbGVmdCBtb3VzZSBidXR0b24gKDApLCBvciB0b3VjaCBkZXZpY2UgKGV2ZW50LmJ1dHRvbiBkb2VzIG5vdCBleGlzdCBvciBpcyBmYWxzZSlcbiAgICAgIGlmIChpcy5udWxsT3JVbmRlZmluZWQoZXZlbnQuYnV0dG9uKSB8fCBldmVudC5idXR0b24gPT09IGZhbHNlIHx8IGV2ZW50LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICB0aGlzLm1vdXNlRG93biA9IHRydWU7XG5cbiAgICAgICAgLy8gV2FpdCB1bnRpbCBtZWRpYSBoYXMgYSBkdXJhdGlvblxuICAgICAgICBpZiAodGhpcy5wbGF5ZXIubWVkaWEuZHVyYXRpb24pIHtcbiAgICAgICAgICB0aGlzLnRvZ2dsZVNjcnViYmluZ0NvbnRhaW5lcih0cnVlKTtcbiAgICAgICAgICB0aGlzLnRvZ2dsZVRodW1iQ29udGFpbmVyKGZhbHNlLCB0cnVlKTtcblxuICAgICAgICAgIC8vIERvd25sb2FkIGFuZCBzaG93IGltYWdlXG4gICAgICAgICAgdGhpcy5zaG93SW1hZ2VBdEN1cnJlbnRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkkMSh0aGlzLCBcImVuZFNjcnViYmluZ1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLm1vdXNlRG93biA9IGZhbHNlO1xuXG4gICAgICAvLyBIaWRlIHNjcnViYmluZyBwcmV2aWV3LiBCdXQgd2FpdCB1bnRpbCB0aGUgdmlkZW8gaGFzIHN1Y2Nlc3NmdWxseSBzZWVrZWQgYmVmb3JlIGhpZGluZyB0aGUgc2NydWJiaW5nIHByZXZpZXdcbiAgICAgIGlmIChNYXRoLmNlaWwodGhpcy5sYXN0VGltZSkgPT09IE1hdGguY2VpbCh0aGlzLnBsYXllci5tZWRpYS5jdXJyZW50VGltZSkpIHtcbiAgICAgICAgLy8gVGhlIHZpZGVvIHdhcyBhbHJlYWR5IHNlZWtlZC9sb2FkZWQgYXQgdGhlIGNob3NlbiB0aW1lIC0gaGlkZSBpbW1lZGlhdGVseVxuICAgICAgICB0aGlzLnRvZ2dsZVNjcnViYmluZ0NvbnRhaW5lcihmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgdmlkZW8gaGFzbid0IHNlZWtlZCB5ZXQuIFdhaXQgZm9yIHRoYXRcbiAgICAgICAgb25jZS5jYWxsKHRoaXMucGxheWVyLCB0aGlzLnBsYXllci5tZWRpYSwgJ3RpbWV1cGRhdGUnLCAoKSA9PiB7XG4gICAgICAgICAgLy8gUmUtY2hlY2sgbW91c2Vkb3duIC0gd2UgbWlnaHQgaGF2ZSBhbHJlYWR5IHN0YXJ0ZWQgc2NydWJiaW5nIGFnYWluXG4gICAgICAgICAgaWYgKCF0aGlzLm1vdXNlRG93bikge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVTY3J1YmJpbmdDb250YWluZXIoZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogU2V0dXAgaG9va3MgZm9yIFBseXIgYW5kIHdpbmRvdyBldmVudHNcbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkkMSh0aGlzLCBcImxpc3RlbmVyc1wiLCAoKSA9PiB7XG4gICAgICAvLyBIaWRlIHRodW1ibmFpbCBwcmV2aWV3IC0gb24gbW91c2UgY2xpY2ssIG1vdXNlIGxlYXZlIChpbiBsaXN0ZW5lcnMuanMgZm9yIG5vdyksIGFuZCB2aWRlbyBwbGF5L3NlZWsuIEFsbCBmb3VyIGFyZSByZXF1aXJlZCwgZS5nLiwgZm9yIGJ1ZmZlcmluZ1xuICAgICAgdGhpcy5wbGF5ZXIub24oJ3BsYXknLCAoKSA9PiB7XG4gICAgICAgIHRoaXMudG9nZ2xlVGh1bWJDb250YWluZXIoZmFsc2UsIHRydWUpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnBsYXllci5vbignc2Vla2VkJywgKCkgPT4ge1xuICAgICAgICB0aGlzLnRvZ2dsZVRodW1iQ29udGFpbmVyKGZhbHNlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wbGF5ZXIub24oJ3RpbWV1cGRhdGUnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMubGFzdFRpbWUgPSB0aGlzLnBsYXllci5tZWRpYS5jdXJyZW50VGltZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBIVE1MIGVsZW1lbnRzIGZvciBpbWFnZSBjb250YWluZXJzXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5JDEodGhpcywgXCJyZW5kZXJcIiwgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIEhUTUwgZWxlbWVudDogcGx5cl9fcHJldmlldy10aHVtYm5haWwtY29udGFpbmVyXG4gICAgICB0aGlzLmVsZW1lbnRzLnRodW1iLmNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgY2xhc3M6IHRoaXMucGxheWVyLmNvbmZpZy5jbGFzc05hbWVzLnByZXZpZXdUaHVtYm5haWxzLnRodW1iQ29udGFpbmVyXG4gICAgICB9KTtcblxuICAgICAgLy8gV3JhcHBlciBmb3IgdGhlIGltYWdlIGZvciBzdHlsaW5nXG4gICAgICB0aGlzLmVsZW1lbnRzLnRodW1iLmltYWdlQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICBjbGFzczogdGhpcy5wbGF5ZXIuY29uZmlnLmNsYXNzTmFtZXMucHJldmlld1RodW1ibmFpbHMuaW1hZ2VDb250YWluZXJcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbGVtZW50cy50aHVtYi5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50cy50aHVtYi5pbWFnZUNvbnRhaW5lcik7XG5cbiAgICAgIC8vIENyZWF0ZSBIVE1MIGVsZW1lbnQsIHBhcmVudCtzcGFuOiB0aW1lIHRleHQgKGUuZy4sIDAxOjMyOjAwKVxuICAgICAgY29uc3QgdGltZUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgICAgY2xhc3M6IHRoaXMucGxheWVyLmNvbmZpZy5jbGFzc05hbWVzLnByZXZpZXdUaHVtYm5haWxzLnRpbWVDb250YWluZXJcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbGVtZW50cy50aHVtYi50aW1lID0gY3JlYXRlRWxlbWVudCgnc3BhbicsIHt9LCAnMDA6MDAnKTtcbiAgICAgIHRpbWVDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50cy50aHVtYi50aW1lKTtcbiAgICAgIHRoaXMuZWxlbWVudHMudGh1bWIuaW1hZ2VDb250YWluZXIuYXBwZW5kQ2hpbGQodGltZUNvbnRhaW5lcik7XG5cbiAgICAgIC8vIEluamVjdCB0aGUgd2hvbGUgdGh1bWJcbiAgICAgIGlmIChpcy5lbGVtZW50KHRoaXMucGxheWVyLmVsZW1lbnRzLnByb2dyZXNzKSkge1xuICAgICAgICB0aGlzLnBsYXllci5lbGVtZW50cy5wcm9ncmVzcy5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnRzLnRodW1iLmNvbnRhaW5lcik7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBIVE1MIGVsZW1lbnQ6IHBseXJfX3ByZXZpZXctc2NydWJiaW5nLWNvbnRhaW5lclxuICAgICAgdGhpcy5lbGVtZW50cy5zY3J1YmJpbmcuY29udGFpbmVyID0gY3JlYXRlRWxlbWVudCgnZGl2Jywge1xuICAgICAgICBjbGFzczogdGhpcy5wbGF5ZXIuY29uZmlnLmNsYXNzTmFtZXMucHJldmlld1RodW1ibmFpbHMuc2NydWJiaW5nQ29udGFpbmVyXG4gICAgICB9KTtcbiAgICAgIHRoaXMucGxheWVyLmVsZW1lbnRzLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50cy5zY3J1YmJpbmcuY29udGFpbmVyKTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkkMSh0aGlzLCBcImRlc3Ryb3lcIiwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudHMudGh1bWIuY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHMudGh1bWIuY29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZWxlbWVudHMuc2NydWJiaW5nLmNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmVsZW1lbnRzLnNjcnViYmluZy5jb250YWluZXIucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5JDEodGhpcywgXCJzaG93SW1hZ2VBdEN1cnJlbnRUaW1lXCIsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLm1vdXNlRG93bikge1xuICAgICAgICB0aGlzLnNldFNjcnViYmluZ0NvbnRhaW5lclNpemUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0VGh1bWJDb250YWluZXJTaXplQW5kUG9zKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmQgdGhlIGRlc2lyZWQgdGh1bWJuYWlsIGluZGV4XG4gICAgICAvLyBUT0RPOiBIYW5kbGUgYSB2aWRlbyBsb25nZXIgdGhhbiB0aGUgdGh1bWJzIHdoZXJlIHRodW1iTnVtIGlzIG51bGxcbiAgICAgIGNvbnN0IHRodW1iTnVtID0gdGhpcy50aHVtYm5haWxzWzBdLmZyYW1lcy5maW5kSW5kZXgoZnJhbWUgPT4gdGhpcy5zZWVrVGltZSA+PSBmcmFtZS5zdGFydFRpbWUgJiYgdGhpcy5zZWVrVGltZSA8PSBmcmFtZS5lbmRUaW1lKTtcbiAgICAgIGNvbnN0IGhhc1RodW1iID0gdGh1bWJOdW0gPj0gMDtcbiAgICAgIGxldCBxdWFsaXR5SW5kZXggPSAwO1xuXG4gICAgICAvLyBTaG93IHRoZSB0aHVtYiBjb250YWluZXIgaWYgd2UncmUgbm90IHNjcnViYmluZ1xuICAgICAgaWYgKCF0aGlzLm1vdXNlRG93bikge1xuICAgICAgICB0aGlzLnRvZ2dsZVRodW1iQ29udGFpbmVyKGhhc1RodW1iKTtcbiAgICAgIH1cblxuICAgICAgLy8gTm8gbWF0Y2hpbmcgdGh1bWIgZm91bmRcbiAgICAgIGlmICghaGFzVGh1bWIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UndmUgYWxyZWFkeSBkb3dubG9hZGVkIGhpZ2hlciBxdWFsaXR5IHZlcnNpb25zIG9mIHRoaXMgaW1hZ2VcbiAgICAgIHRoaXMudGh1bWJuYWlscy5mb3JFYWNoKCh0aHVtYm5haWwsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmxvYWRlZEltYWdlcy5pbmNsdWRlcyh0aHVtYm5haWwuZnJhbWVzW3RodW1iTnVtXS50ZXh0KSkge1xuICAgICAgICAgIHF1YWxpdHlJbmRleCA9IGluZGV4O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gT25seSBwcm9jZWVkIGlmIGVpdGhlciB0aHVtYiBudW0gb3IgdGh1bWJmaWxlbmFtZSBoYXMgY2hhbmdlZFxuICAgICAgaWYgKHRodW1iTnVtICE9PSB0aGlzLnNob3dpbmdUaHVtYikge1xuICAgICAgICB0aGlzLnNob3dpbmdUaHVtYiA9IHRodW1iTnVtO1xuICAgICAgICB0aGlzLmxvYWRJbWFnZShxdWFsaXR5SW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIFNob3cgdGhlIGltYWdlIHRoYXQncyBjdXJyZW50bHkgc3BlY2lmaWVkIGluIHRoaXMuc2hvd2luZ1RodW1iXG4gICAgX2RlZmluZVByb3BlcnR5JDEodGhpcywgXCJsb2FkSW1hZ2VcIiwgKHF1YWxpdHlJbmRleCA9IDApID0+IHtcbiAgICAgIGNvbnN0IHRodW1iTnVtID0gdGhpcy5zaG93aW5nVGh1bWI7XG4gICAgICBjb25zdCB0aHVtYm5haWwgPSB0aGlzLnRodW1ibmFpbHNbcXVhbGl0eUluZGV4XTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdXJsUHJlZml4XG4gICAgICB9ID0gdGh1bWJuYWlsO1xuICAgICAgY29uc3QgZnJhbWUgPSB0aHVtYm5haWwuZnJhbWVzW3RodW1iTnVtXTtcbiAgICAgIGNvbnN0IHRodW1iRmlsZW5hbWUgPSB0aHVtYm5haWwuZnJhbWVzW3RodW1iTnVtXS50ZXh0O1xuICAgICAgY29uc3QgdGh1bWJVcmwgPSB1cmxQcmVmaXggKyB0aHVtYkZpbGVuYW1lO1xuICAgICAgaWYgKCF0aGlzLmN1cnJlbnRJbWFnZUVsZW1lbnQgfHwgdGhpcy5jdXJyZW50SW1hZ2VFbGVtZW50LmRhdGFzZXQuZmlsZW5hbWUgIT09IHRodW1iRmlsZW5hbWUpIHtcbiAgICAgICAgLy8gSWYgd2UncmUgYWxyZWFkeSBsb2FkaW5nIGEgcHJldmlvdXMgaW1hZ2UsIHJlbW92ZSBpdHMgb25sb2FkIGhhbmRsZXIgLSB3ZSBkb24ndCB3YW50IGl0IHRvIGxvYWQgYWZ0ZXIgdGhpcyBvbmVcbiAgICAgICAgLy8gT25seSBkbyB0aGlzIGlmIG5vdCB1c2luZyBzcHJpdGVzLiBXaXRob3V0IHNwcml0ZXMgd2UgcmVhbGx5IHdhbnQgdG8gc2hvdyBhcyBtYW55IGltYWdlcyBhcyBwb3NzaWJsZSwgYXMgYSBiZXN0LWVmZm9ydFxuICAgICAgICBpZiAodGhpcy5sb2FkaW5nSW1hZ2UgJiYgdGhpcy51c2luZ1Nwcml0ZXMpIHtcbiAgICAgICAgICB0aGlzLmxvYWRpbmdJbWFnZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UncmUgYnVpbGRpbmcgYW5kIGFkZGluZyBhIG5ldyBpbWFnZS4gSW4gb3RoZXIgaW1wbGVtZW50YXRpb25zIG9mIHNpbWlsYXIgZnVuY3Rpb25hbGl0eSAoWW91VHViZSksIGJhY2tncm91bmQgaW1hZ2VcbiAgICAgICAgLy8gaXMgaW5zdGVhZCB1c2VkLiBCdXQgdGhpcyBjYXVzZXMgaXNzdWVzIHdpdGggbGFyZ2VyIGltYWdlcyBpbiBGaXJlZm94IGFuZCBTYWZhcmkgLSBzd2l0Y2hpbmcgYmV0d2VlbiBiYWNrZ3JvdW5kXG4gICAgICAgIC8vIGltYWdlcyBjYXVzZXMgYSBmbGlja2VyLiBQdXR0aW5nIGEgbmV3IGltYWdlIG92ZXIgdGhlIHRvcCBkb2VzIG5vdFxuICAgICAgICBjb25zdCBwcmV2aWV3SW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgcHJldmlld0ltYWdlLnNyYyA9IHRodW1iVXJsO1xuICAgICAgICBwcmV2aWV3SW1hZ2UuZGF0YXNldC5pbmRleCA9IHRodW1iTnVtO1xuICAgICAgICBwcmV2aWV3SW1hZ2UuZGF0YXNldC5maWxlbmFtZSA9IHRodW1iRmlsZW5hbWU7XG4gICAgICAgIHRoaXMuc2hvd2luZ1RodW1iRmlsZW5hbWUgPSB0aHVtYkZpbGVuYW1lO1xuICAgICAgICB0aGlzLnBsYXllci5kZWJ1Zy5sb2coYExvYWRpbmcgaW1hZ2U6ICR7dGh1bWJVcmx9YCk7XG5cbiAgICAgICAgLy8gRm9yIHNvbWUgcmVhc29uLCBwYXNzaW5nIHRoZSBuYW1lZCBmdW5jdGlvbiBkaXJlY3RseSBjYXVzZXMgaXQgdG8gZXhlY3V0ZSBpbW1lZGlhdGVseS4gU28gSSd2ZSB3cmFwcGVkIGl0IGluIGFuIGFub255bW91cyBmdW5jdGlvbi4uLlxuICAgICAgICBwcmV2aWV3SW1hZ2Uub25sb2FkID0gKCkgPT4gdGhpcy5zaG93SW1hZ2UocHJldmlld0ltYWdlLCBmcmFtZSwgcXVhbGl0eUluZGV4LCB0aHVtYk51bSwgdGh1bWJGaWxlbmFtZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMubG9hZGluZ0ltYWdlID0gcHJldmlld0ltYWdlO1xuICAgICAgICB0aGlzLnJlbW92ZU9sZEltYWdlcyhwcmV2aWV3SW1hZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbWFnZVxuICAgICAgICB0aGlzLnNob3dJbWFnZSh0aGlzLmN1cnJlbnRJbWFnZUVsZW1lbnQsIGZyYW1lLCBxdWFsaXR5SW5kZXgsIHRodW1iTnVtLCB0aHVtYkZpbGVuYW1lLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuY3VycmVudEltYWdlRWxlbWVudC5kYXRhc2V0LmluZGV4ID0gdGh1bWJOdW07XG4gICAgICAgIHRoaXMucmVtb3ZlT2xkSW1hZ2VzKHRoaXMuY3VycmVudEltYWdlRWxlbWVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5JDEodGhpcywgXCJzaG93SW1hZ2VcIiwgKHByZXZpZXdJbWFnZSwgZnJhbWUsIHF1YWxpdHlJbmRleCwgdGh1bWJOdW0sIHRodW1iRmlsZW5hbWUsIG5ld0ltYWdlID0gdHJ1ZSkgPT4ge1xuICAgICAgdGhpcy5wbGF5ZXIuZGVidWcubG9nKGBTaG93aW5nIHRodW1iOiAke3RodW1iRmlsZW5hbWV9LiBudW06ICR7dGh1bWJOdW19LiBxdWFsOiAke3F1YWxpdHlJbmRleH0uIG5ld2ltZzogJHtuZXdJbWFnZX1gKTtcbiAgICAgIHRoaXMuc2V0SW1hZ2VTaXplQW5kT2Zmc2V0KHByZXZpZXdJbWFnZSwgZnJhbWUpO1xuICAgICAgaWYgKG5ld0ltYWdlKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEltYWdlQ29udGFpbmVyLmFwcGVuZENoaWxkKHByZXZpZXdJbWFnZSk7XG4gICAgICAgIHRoaXMuY3VycmVudEltYWdlRWxlbWVudCA9IHByZXZpZXdJbWFnZTtcbiAgICAgICAgaWYgKCF0aGlzLmxvYWRlZEltYWdlcy5pbmNsdWRlcyh0aHVtYkZpbGVuYW1lKSkge1xuICAgICAgICAgIHRoaXMubG9hZGVkSW1hZ2VzLnB1c2godGh1bWJGaWxlbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUHJlbG9hZCBpbWFnZXMgYmVmb3JlIGFuZCBhZnRlciB0aGUgY3VycmVudCBvbmVcbiAgICAgIC8vIFNob3cgaGlnaGVyIHF1YWxpdHkgb2YgdGhlIHNhbWUgZnJhbWVcbiAgICAgIC8vIEVhY2ggc3RlcCBoZXJlIGhhcyBhIHNob3J0IHRpbWUgZGVsYXksIGFuZCBvbmx5IGNvbnRpbnVlcyBpZiBzdGlsbCBob3ZlcmluZy9zZWVraW5nIHRoZSBzYW1lIHNwb3QuIFRoaXMgaXMgdG8gcHJvdGVjdCBzbG93IGNvbm5lY3Rpb25zIGZyb20gb3ZlcmxvYWRpbmdcbiAgICAgIHRoaXMucHJlbG9hZE5lYXJieSh0aHVtYk51bSwgdHJ1ZSkudGhlbih0aGlzLnByZWxvYWROZWFyYnkodGh1bWJOdW0sIGZhbHNlKSkudGhlbih0aGlzLmdldEhpZ2hlclF1YWxpdHkocXVhbGl0eUluZGV4LCBwcmV2aWV3SW1hZ2UsIGZyYW1lLCB0aHVtYkZpbGVuYW1lKSk7XG4gICAgfSk7XG4gICAgLy8gUmVtb3ZlIGFsbCBwcmV2aWV3IGltYWdlcyB0aGF0IGFyZW4ndCB0aGUgZGVzaWduYXRlZCBjdXJyZW50IGltYWdlXG4gICAgX2RlZmluZVByb3BlcnR5JDEodGhpcywgXCJyZW1vdmVPbGRJbWFnZXNcIiwgY3VycmVudEltYWdlID0+IHtcbiAgICAgIC8vIEdldCBhIGxpc3Qgb2YgYWxsIGltYWdlcywgY29udmVydCBpdCBmcm9tIGEgRE9NIGxpc3QgdG8gYW4gYXJyYXlcbiAgICAgIEFycmF5LmZyb20odGhpcy5jdXJyZW50SW1hZ2VDb250YWluZXIuY2hpbGRyZW4pLmZvckVhY2goaW1hZ2UgPT4ge1xuICAgICAgICBpZiAoaW1hZ2UudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnaW1nJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW1vdmVEZWxheSA9IHRoaXMudXNpbmdTcHJpdGVzID8gNTAwIDogMTAwMDtcbiAgICAgICAgaWYgKGltYWdlLmRhdGFzZXQuaW5kZXggIT09IGN1cnJlbnRJbWFnZS5kYXRhc2V0LmluZGV4ICYmICFpbWFnZS5kYXRhc2V0LmRlbGV0aW5nKSB7XG4gICAgICAgICAgLy8gV2FpdCAyMDBtcywgYXMgdGhlIG5ldyBpbWFnZSBjYW4gdGFrZSBzb21lIHRpbWUgdG8gc2hvdyBvbiBjZXJ0YWluIGJyb3dzZXJzIChldmVuIHRob3VnaCBpdCB3YXMgZG93bmxvYWRlZCBiZWZvcmUgc2hvd2luZykuIFRoaXMgd2lsbCBwcmV2ZW50IGZsaWNrZXIsIGFuZCBzaG93IHNvbWUgZ2VuZXJvc2l0eSB0b3dhcmRzIHNsb3dlciBjbGllbnRzXG4gICAgICAgICAgLy8gRmlyc3Qgc2V0IGF0dHJpYnV0ZSAnZGVsZXRpbmcnIHRvIHByZXZlbnQgbXVsdGktaGFuZGxpbmcgb2YgdGhpcyBvbiByZXBlYXQgZmlyaW5nIG9mIHRoaXMgZnVuY3Rpb25cblxuICAgICAgICAgIGltYWdlLmRhdGFzZXQuZGVsZXRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgLy8gVGhpcyBoYXMgdG8gYmUgc2V0IGJlZm9yZSB0aGUgdGltZW91dCAtIHRvIHByZXZlbnQgaXNzdWVzIHN3aXRjaGluZyBiZXR3ZWVuIGhvdmVyIGFuZCBzY3J1YlxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGN1cnJlbnRJbWFnZUNvbnRhaW5lclxuICAgICAgICAgIH0gPSB0aGlzO1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY3VycmVudEltYWdlQ29udGFpbmVyLnJlbW92ZUNoaWxkKGltYWdlKTtcbiAgICAgICAgICAgIHRoaXMucGxheWVyLmRlYnVnLmxvZyhgUmVtb3ZpbmcgdGh1bWI6ICR7aW1hZ2UuZGF0YXNldC5maWxlbmFtZX1gKTtcbiAgICAgICAgICB9LCByZW1vdmVEZWxheSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIFByZWxvYWQgaW1hZ2VzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGN1cnJlbnQgb25lLiBPbmx5IGlmIHRoZSB1c2VyIGlzIHN0aWxsIGhvdmVyaW5nL3NlZWtpbmcgdGhlIHNhbWUgZnJhbWVcbiAgICAvLyBUaGlzIHdpbGwgb25seSBwcmVsb2FkIHRoZSBsb3dlc3QgcXVhbGl0eVxuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwicHJlbG9hZE5lYXJieVwiLCAodGh1bWJOdW0sIGZvcndhcmQgPSB0cnVlKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG9sZFRodW1iRmlsZW5hbWUgPSB0aGlzLnRodW1ibmFpbHNbMF0uZnJhbWVzW3RodW1iTnVtXS50ZXh0O1xuICAgICAgICAgIGlmICh0aGlzLnNob3dpbmdUaHVtYkZpbGVuYW1lID09PSBvbGRUaHVtYkZpbGVuYW1lKSB7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBuZWFyZXN0IHRodW1icyB3aXRoIGRpZmZlcmVudCBmaWxlbmFtZXMuIFNvbWV0aW1lcyBpdCdsbCBiZSB0aGUgbmV4dCBpbmRleCwgYnV0IGluIHRoZSBjYXNlIG9mIHNwcml0ZXMsIGl0IG1pZ2h0IGJlIDEwMCsgYXdheVxuICAgICAgICAgICAgbGV0IHRodW1ibmFpbHNDbG9uZTtcbiAgICAgICAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICAgICAgIHRodW1ibmFpbHNDbG9uZSA9IHRoaXMudGh1bWJuYWlsc1swXS5mcmFtZXMuc2xpY2UodGh1bWJOdW0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGh1bWJuYWlsc0Nsb25lID0gdGhpcy50aHVtYm5haWxzWzBdLmZyYW1lcy5zbGljZSgwLCB0aHVtYk51bSkucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZvdW5kT25lID0gZmFsc2U7XG4gICAgICAgICAgICB0aHVtYm5haWxzQ2xvbmUuZm9yRWFjaChmcmFtZSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG5ld1RodW1iRmlsZW5hbWUgPSBmcmFtZS50ZXh0O1xuICAgICAgICAgICAgICBpZiAobmV3VGh1bWJGaWxlbmFtZSAhPT0gb2xkVGh1bWJGaWxlbmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIEZvdW5kIG9uZSB3aXRoIGEgZGlmZmVyZW50IGZpbGVuYW1lLiBNYWtlIHN1cmUgaXQgaGFzbid0IGFscmVhZHkgYmVlbiBsb2FkZWQgb24gdGhpcyBwYWdlIHZpc2l0XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxvYWRlZEltYWdlcy5pbmNsdWRlcyhuZXdUaHVtYkZpbGVuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgZm91bmRPbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgdGhpcy5wbGF5ZXIuZGVidWcubG9nKGBQcmVsb2FkaW5nIHRodW1iIGZpbGVuYW1lOiAke25ld1RodW1iRmlsZW5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgICAgIHVybFByZWZpeFxuICAgICAgICAgICAgICAgICAgfSA9IHRoaXMudGh1bWJuYWlsc1swXTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRodW1iVVJMID0gdXJsUHJlZml4ICsgbmV3VGh1bWJGaWxlbmFtZTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpZXdJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgICAgICAgcHJldmlld0ltYWdlLnNyYyA9IHRodW1iVVJMO1xuICAgICAgICAgICAgICAgICAgcHJldmlld0ltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGF5ZXIuZGVidWcubG9nKGBQcmVsb2FkZWQgdGh1bWIgZmlsZW5hbWU6ICR7bmV3VGh1bWJGaWxlbmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxvYWRlZEltYWdlcy5pbmNsdWRlcyhuZXdUaHVtYkZpbGVuYW1lKSkgdGhpcy5sb2FkZWRJbWFnZXMucHVzaChuZXdUaHVtYkZpbGVuYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCByZXNvbHZlIHVudGlsIHRoZSB0aHVtYiBpcyBsb2FkZWRcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm9uZSB0byBwcmVsb2FkIHRoZW4gd2Ugd2FudCB0byByZXNvbHZlIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBpZiAoIWZvdW5kT25lKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIDMwMCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBJZiB1c2VyIGhhcyBiZWVuIGhvdmVyaW5nIGN1cnJlbnQgaW1hZ2UgZm9yIGhhbGYgYSBzZWNvbmQsIGxvb2sgZm9yIGEgaGlnaGVyIHF1YWxpdHkgb25lXG4gICAgX2RlZmluZVByb3BlcnR5JDEodGhpcywgXCJnZXRIaWdoZXJRdWFsaXR5XCIsIChjdXJyZW50UXVhbGl0eUluZGV4LCBwcmV2aWV3SW1hZ2UsIGZyYW1lLCB0aHVtYkZpbGVuYW1lKSA9PiB7XG4gICAgICBpZiAoY3VycmVudFF1YWxpdHlJbmRleCA8IHRoaXMudGh1bWJuYWlscy5sZW5ndGggLSAxKSB7XG4gICAgICAgIC8vIE9ubHkgdXNlIHRoZSBoaWdoZXIgcXVhbGl0eSB2ZXJzaW9uIGlmIGl0J3MgZ29pbmcgdG8gbG9vayBhbnkgYmV0dGVyIC0gaWYgdGhlIGN1cnJlbnQgdGh1bWIgaXMgb2YgYSBsb3dlciBwaXhlbCBkZW5zaXR5IHRoYW4gdGhlIHRodW1ibmFpbCBjb250YWluZXJcbiAgICAgICAgbGV0IHByZXZpZXdJbWFnZUhlaWdodCA9IHByZXZpZXdJbWFnZS5uYXR1cmFsSGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy51c2luZ1Nwcml0ZXMpIHtcbiAgICAgICAgICBwcmV2aWV3SW1hZ2VIZWlnaHQgPSBmcmFtZS5oO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2aWV3SW1hZ2VIZWlnaHQgPCB0aGlzLnRodW1iQ29udGFpbmVySGVpZ2h0KSB7XG4gICAgICAgICAgLy8gUmVjdXJzZSBiYWNrIHRvIHRoZSBsb2FkSW1hZ2UgZnVuY3Rpb24gLSBzaG93IGEgaGlnaGVyIHF1YWxpdHkgb25lLCBidXQgb25seSBpZiB0aGUgdmlld2VyIGlzIG9uIHRoaXMgZnJhbWUgZm9yIGEgd2hpbGVcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgbW91c2UgaGFzbid0IGFscmVhZHkgbW92ZWQgb24gYW5kIHN0YXJ0ZWQgaG92ZXJpbmcgYXQgYW5vdGhlciBpbWFnZVxuICAgICAgICAgICAgaWYgKHRoaXMuc2hvd2luZ1RodW1iRmlsZW5hbWUgPT09IHRodW1iRmlsZW5hbWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5wbGF5ZXIuZGVidWcubG9nKGBTaG93aW5nIGhpZ2hlciBxdWFsaXR5IHRodW1iIGZvcjogJHt0aHVtYkZpbGVuYW1lfWApO1xuICAgICAgICAgICAgICB0aGlzLmxvYWRJbWFnZShjdXJyZW50UXVhbGl0eUluZGV4ICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwidG9nZ2xlVGh1bWJDb250YWluZXJcIiwgKHRvZ2dsZSA9IGZhbHNlLCBjbGVhclNob3dpbmcgPSBmYWxzZSkgPT4ge1xuICAgICAgY29uc3QgY2xhc3NOYW1lID0gdGhpcy5wbGF5ZXIuY29uZmlnLmNsYXNzTmFtZXMucHJldmlld1RodW1ibmFpbHMudGh1bWJDb250YWluZXJTaG93bjtcbiAgICAgIHRoaXMuZWxlbWVudHMudGh1bWIuY29udGFpbmVyLmNsYXNzTGlzdC50b2dnbGUoY2xhc3NOYW1lLCB0b2dnbGUpO1xuICAgICAgaWYgKCF0b2dnbGUgJiYgY2xlYXJTaG93aW5nKSB7XG4gICAgICAgIHRoaXMuc2hvd2luZ1RodW1iID0gbnVsbDtcbiAgICAgICAgdGhpcy5zaG93aW5nVGh1bWJGaWxlbmFtZSA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5JDEodGhpcywgXCJ0b2dnbGVTY3J1YmJpbmdDb250YWluZXJcIiwgKHRvZ2dsZSA9IGZhbHNlKSA9PiB7XG4gICAgICBjb25zdCBjbGFzc05hbWUgPSB0aGlzLnBsYXllci5jb25maWcuY2xhc3NOYW1lcy5wcmV2aWV3VGh1bWJuYWlscy5zY3J1YmJpbmdDb250YWluZXJTaG93bjtcbiAgICAgIHRoaXMuZWxlbWVudHMuc2NydWJiaW5nLmNvbnRhaW5lci5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzTmFtZSwgdG9nZ2xlKTtcbiAgICAgIGlmICghdG9nZ2xlKSB7XG4gICAgICAgIHRoaXMuc2hvd2luZ1RodW1iID0gbnVsbDtcbiAgICAgICAgdGhpcy5zaG93aW5nVGh1bWJGaWxlbmFtZSA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5JDEodGhpcywgXCJkZXRlcm1pbmVDb250YWluZXJBdXRvU2l6aW5nXCIsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnRzLnRodW1iLmltYWdlQ29udGFpbmVyLmNsaWVudEhlaWdodCA+IDIwIHx8IHRoaXMuZWxlbWVudHMudGh1bWIuaW1hZ2VDb250YWluZXIuY2xpZW50V2lkdGggPiAyMCkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgcHJldmVudCBhdXRvIHNpemluZyBpbiB0aGlzLnNldFRodW1iQ29udGFpbmVyU2l6ZUFuZFBvcygpXG4gICAgICAgIHRoaXMuc2l6ZVNwZWNpZmllZEluQ1NTID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBTZXQgdGhlIHNpemUgdG8gYmUgYWJvdXQgYSBxdWFydGVyIG9mIHRoZSBzaXplIG9mIHZpZGVvLiBVbmxlc3Mgb3B0aW9uIGR5bmFtaWNTaXplID09PSBmYWxzZSwgaW4gd2hpY2ggY2FzZSBpdCBuZWVkcyB0byBiZSBzZXQgaW4gQ1NTXG4gICAgX2RlZmluZVByb3BlcnR5JDEodGhpcywgXCJzZXRUaHVtYkNvbnRhaW5lclNpemVBbmRQb3NcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBpbWFnZUNvbnRhaW5lclxuICAgICAgfSA9IHRoaXMuZWxlbWVudHMudGh1bWI7XG4gICAgICBpZiAoIXRoaXMuc2l6ZVNwZWNpZmllZEluQ1NTKSB7XG4gICAgICAgIGNvbnN0IHRodW1iV2lkdGggPSBNYXRoLmZsb29yKHRoaXMudGh1bWJDb250YWluZXJIZWlnaHQgKiB0aGlzLnRodW1iQXNwZWN0UmF0aW8pO1xuICAgICAgICBpbWFnZUNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLnRodW1iQ29udGFpbmVySGVpZ2h0fXB4YDtcbiAgICAgICAgaW1hZ2VDb250YWluZXIuc3R5bGUud2lkdGggPSBgJHt0aHVtYldpZHRofXB4YDtcbiAgICAgIH0gZWxzZSBpZiAoaW1hZ2VDb250YWluZXIuY2xpZW50SGVpZ2h0ID4gMjAgJiYgaW1hZ2VDb250YWluZXIuY2xpZW50V2lkdGggPCAyMCkge1xuICAgICAgICBjb25zdCB0aHVtYldpZHRoID0gTWF0aC5mbG9vcihpbWFnZUNvbnRhaW5lci5jbGllbnRIZWlnaHQgKiB0aGlzLnRodW1iQXNwZWN0UmF0aW8pO1xuICAgICAgICBpbWFnZUNvbnRhaW5lci5zdHlsZS53aWR0aCA9IGAke3RodW1iV2lkdGh9cHhgO1xuICAgICAgfSBlbHNlIGlmIChpbWFnZUNvbnRhaW5lci5jbGllbnRIZWlnaHQgPCAyMCAmJiBpbWFnZUNvbnRhaW5lci5jbGllbnRXaWR0aCA+IDIwKSB7XG4gICAgICAgIGNvbnN0IHRodW1iSGVpZ2h0ID0gTWF0aC5mbG9vcihpbWFnZUNvbnRhaW5lci5jbGllbnRXaWR0aCAvIHRoaXMudGh1bWJBc3BlY3RSYXRpbyk7XG4gICAgICAgIGltYWdlQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGAke3RodW1iSGVpZ2h0fXB4YDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0VGh1bWJDb250YWluZXJQb3MoKTtcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkkMSh0aGlzLCBcInNldFRodW1iQ29udGFpbmVyUG9zXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHNjcnViYmVyUmVjdCA9IHRoaXMucGxheWVyLmVsZW1lbnRzLnByb2dyZXNzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY29udGFpbmVyUmVjdCA9IHRoaXMucGxheWVyLmVsZW1lbnRzLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29udGFpbmVyXG4gICAgICB9ID0gdGhpcy5lbGVtZW50cy50aHVtYjtcbiAgICAgIC8vIEZpbmQgdGhlIGxvd2VzdCBhbmQgaGlnaGVzdCBkZXNpcmVkIGxlZnQtcG9zaXRpb24sIHNvIHdlIGRvbid0IHNsaWRlIG91dCB0aGUgc2lkZSBvZiB0aGUgdmlkZW8gY29udGFpbmVyXG4gICAgICBjb25zdCBtaW4gPSBjb250YWluZXJSZWN0LmxlZnQgLSBzY3J1YmJlclJlY3QubGVmdCArIDEwO1xuICAgICAgY29uc3QgbWF4ID0gY29udGFpbmVyUmVjdC5yaWdodCAtIHNjcnViYmVyUmVjdC5sZWZ0IC0gY29udGFpbmVyLmNsaWVudFdpZHRoIC0gMTA7XG4gICAgICAvLyBTZXQgcHJldmlldyBjb250YWluZXIgcG9zaXRpb24gdG86IG1vdXNlcG9zLCBtaW51cyBzZWVrYmFyLmxlZnQsIG1pbnVzIGhhbGYgb2YgcHJldmlld0NvbnRhaW5lci5jbGllbnRXaWR0aFxuICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLm1vdXNlUG9zWCAtIHNjcnViYmVyUmVjdC5sZWZ0IC0gY29udGFpbmVyLmNsaWVudFdpZHRoIC8gMjtcbiAgICAgIGNvbnN0IGNsYW1wZWQgPSBjbGFtcChwb3NpdGlvbiwgbWluLCBtYXgpO1xuXG4gICAgICAvLyBNb3ZlIHRoZSBwb3BvdmVyIHBvc2l0aW9uXG4gICAgICBjb250YWluZXIuc3R5bGUubGVmdCA9IGAke2NsYW1wZWR9cHhgO1xuXG4gICAgICAvLyBUaGUgYXJyb3cgY2FuIGZvbGxvdyB0aGUgY3Vyc29yXG4gICAgICBjb250YWluZXIuc3R5bGUuc2V0UHJvcGVydHkoJy0tcHJldmlldy1hcnJvdy1vZmZzZXQnLCBgJHtwb3NpdGlvbiAtIGNsYW1wZWR9cHhgKTtcbiAgICB9KTtcbiAgICAvLyBDYW4ndCB1c2UgMTAwJSB3aWR0aCwgaW4gY2FzZSB0aGUgdmlkZW8gaXMgYSBkaWZmZXJlbnQgYXNwZWN0IHJhdGlvIHRvIHRoZSB2aWRlbyBjb250YWluZXJcbiAgICBfZGVmaW5lUHJvcGVydHkkMSh0aGlzLCBcInNldFNjcnViYmluZ0NvbnRhaW5lclNpemVcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9ID0gZml0UmF0aW8odGhpcy50aHVtYkFzcGVjdFJhdGlvLCB7XG4gICAgICAgIHdpZHRoOiB0aGlzLnBsYXllci5tZWRpYS5jbGllbnRXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLnBsYXllci5tZWRpYS5jbGllbnRIZWlnaHRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbGVtZW50cy5zY3J1YmJpbmcuY29udGFpbmVyLnN0eWxlLndpZHRoID0gYCR7d2lkdGh9cHhgO1xuICAgICAgdGhpcy5lbGVtZW50cy5zY3J1YmJpbmcuY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGA7XG4gICAgfSk7XG4gICAgLy8gU3ByaXRlcyBuZWVkIHRvIGJlIG9mZnNldCB0byB0aGUgY29ycmVjdCBsb2NhdGlvblxuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwic2V0SW1hZ2VTaXplQW5kT2Zmc2V0XCIsIChwcmV2aWV3SW1hZ2UsIGZyYW1lKSA9PiB7XG4gICAgICBpZiAoIXRoaXMudXNpbmdTcHJpdGVzKSByZXR1cm47XG5cbiAgICAgIC8vIEZpbmQgZGlmZmVyZW5jZSBiZXR3ZWVuIGhlaWdodCBhbmQgcHJldmlldyBjb250YWluZXIgaGVpZ2h0XG4gICAgICBjb25zdCBtdWx0aXBsaWVyID0gdGhpcy50aHVtYkNvbnRhaW5lckhlaWdodCAvIGZyYW1lLmg7XG4gICAgICBwcmV2aWV3SW1hZ2Uuc3R5bGUuaGVpZ2h0ID0gYCR7cHJldmlld0ltYWdlLm5hdHVyYWxIZWlnaHQgKiBtdWx0aXBsaWVyfXB4YDtcbiAgICAgIHByZXZpZXdJbWFnZS5zdHlsZS53aWR0aCA9IGAke3ByZXZpZXdJbWFnZS5uYXR1cmFsV2lkdGggKiBtdWx0aXBsaWVyfXB4YDtcbiAgICAgIHByZXZpZXdJbWFnZS5zdHlsZS5sZWZ0ID0gYC0ke2ZyYW1lLnggKiBtdWx0aXBsaWVyfXB4YDtcbiAgICAgIHByZXZpZXdJbWFnZS5zdHlsZS50b3AgPSBgLSR7ZnJhbWUueSAqIG11bHRpcGxpZXJ9cHhgO1xuICAgIH0pO1xuICAgIHRoaXMucGxheWVyID0gcGxheWVyO1xuICAgIHRoaXMudGh1bWJuYWlscyA9IFtdO1xuICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgdGhpcy5sYXN0TW91c2VNb3ZlVGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy5tb3VzZURvd24gPSBmYWxzZTtcbiAgICB0aGlzLmxvYWRlZEltYWdlcyA9IFtdO1xuICAgIHRoaXMuZWxlbWVudHMgPSB7XG4gICAgICB0aHVtYjoge30sXG4gICAgICBzY3J1YmJpbmc6IHt9XG4gICAgfTtcbiAgICB0aGlzLmxvYWQoKTtcbiAgfVxuICBnZXQgZW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5ZXIuaXNIVE1MNSAmJiB0aGlzLnBsYXllci5pc1ZpZGVvICYmIHRoaXMucGxheWVyLmNvbmZpZy5wcmV2aWV3VGh1bWJuYWlscy5lbmFibGVkO1xuICB9XG4gIGdldCBjdXJyZW50SW1hZ2VDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubW91c2VEb3duID8gdGhpcy5lbGVtZW50cy5zY3J1YmJpbmcuY29udGFpbmVyIDogdGhpcy5lbGVtZW50cy50aHVtYi5pbWFnZUNvbnRhaW5lcjtcbiAgfVxuICBnZXQgdXNpbmdTcHJpdGVzKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnRodW1ibmFpbHNbMF0uZnJhbWVzWzBdKS5pbmNsdWRlcygndycpO1xuICB9XG4gIGdldCB0aHVtYkFzcGVjdFJhdGlvKCkge1xuICAgIGlmICh0aGlzLnVzaW5nU3ByaXRlcykge1xuICAgICAgcmV0dXJuIHRoaXMudGh1bWJuYWlsc1swXS5mcmFtZXNbMF0udyAvIHRoaXMudGh1bWJuYWlsc1swXS5mcmFtZXNbMF0uaDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGh1bWJuYWlsc1swXS53aWR0aCAvIHRoaXMudGh1bWJuYWlsc1swXS5oZWlnaHQ7XG4gIH1cbiAgZ2V0IHRodW1iQ29udGFpbmVySGVpZ2h0KCkge1xuICAgIGlmICh0aGlzLm1vdXNlRG93bikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSBmaXRSYXRpbyh0aGlzLnRodW1iQXNwZWN0UmF0aW8sIHtcbiAgICAgICAgd2lkdGg6IHRoaXMucGxheWVyLm1lZGlhLmNsaWVudFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMucGxheWVyLm1lZGlhLmNsaWVudEhlaWdodFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIElmIGNzcyBpcyB1c2VkIHRoaXMgbmVlZHMgdG8gcmV0dXJuIHRoZSBjc3MgaGVpZ2h0IGZvciBzcHJpdGVzIHRvIHdvcmsgKHNlZSBzZXRJbWFnZVNpemVBbmRPZmZzZXQpXG4gICAgaWYgKHRoaXMuc2l6ZVNwZWNpZmllZEluQ1NTKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50cy50aHVtYi5pbWFnZUNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMucGxheWVyLm1lZGlhLmNsaWVudFdpZHRoIC8gdGhpcy50aHVtYkFzcGVjdFJhdGlvIC8gNCk7XG4gIH1cbiAgZ2V0IGN1cnJlbnRJbWFnZUVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubW91c2VEb3duID8gdGhpcy5jdXJyZW50U2NydWJiaW5nSW1hZ2VFbGVtZW50IDogdGhpcy5jdXJyZW50VGh1bWJuYWlsSW1hZ2VFbGVtZW50O1xuICB9XG4gIHNldCBjdXJyZW50SW1hZ2VFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5tb3VzZURvd24pIHtcbiAgICAgIHRoaXMuY3VycmVudFNjcnViYmluZ0ltYWdlRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3VycmVudFRodW1ibmFpbEltYWdlRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgfVxuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBQbHlyIHNvdXJjZSB1cGRhdGVcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmNvbnN0IHNvdXJjZSA9IHtcbiAgLy8gQWRkIGVsZW1lbnRzIHRvIEhUTUw1IG1lZGlhIChzb3VyY2UsIHRyYWNrcywgZXRjKVxuICBpbnNlcnRFbGVtZW50cyh0eXBlLCBhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKGlzLnN0cmluZyhhdHRyaWJ1dGVzKSkge1xuICAgICAgaW5zZXJ0RWxlbWVudCh0eXBlLCB0aGlzLm1lZGlhLCB7XG4gICAgICAgIHNyYzogYXR0cmlidXRlc1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpcy5hcnJheShhdHRyaWJ1dGVzKSkge1xuICAgICAgYXR0cmlidXRlcy5mb3JFYWNoKGF0dHJpYnV0ZSA9PiB7XG4gICAgICAgIGluc2VydEVsZW1lbnQodHlwZSwgdGhpcy5tZWRpYSwgYXR0cmlidXRlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgLy8gVXBkYXRlIHNvdXJjZVxuICAvLyBTb3VyY2VzIGFyZSBub3QgY2hlY2tlZCBmb3Igc3VwcG9ydCBzbyBiZSBjYXJlZnVsXG4gIGNoYW5nZShpbnB1dCkge1xuICAgIGlmICghZ2V0RGVlcChpbnB1dCwgJ3NvdXJjZXMubGVuZ3RoJykpIHtcbiAgICAgIHRoaXMuZGVidWcud2FybignSW52YWxpZCBzb3VyY2UgZm9ybWF0Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2FuY2VsIGN1cnJlbnQgbmV0d29yayByZXF1ZXN0c1xuICAgIGh0bWw1LmNhbmNlbFJlcXVlc3RzLmNhbGwodGhpcyk7XG5cbiAgICAvLyBEZXN0cm95IGluc3RhbmNlIGFuZCByZS1zZXR1cFxuICAgIHRoaXMuZGVzdHJveSgoKSA9PiB7XG4gICAgICAvLyBSZXNldCBxdWFsaXR5IG9wdGlvbnNcbiAgICAgIHRoaXMub3B0aW9ucy5xdWFsaXR5ID0gW107XG5cbiAgICAgIC8vIFJlbW92ZSBlbGVtZW50c1xuICAgICAgcmVtb3ZlRWxlbWVudCh0aGlzLm1lZGlhKTtcbiAgICAgIHRoaXMubWVkaWEgPSBudWxsO1xuXG4gICAgICAvLyBSZXNldCBjbGFzcyBuYW1lXG4gICAgICBpZiAoaXMuZWxlbWVudCh0aGlzLmVsZW1lbnRzLmNvbnRhaW5lcikpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5jb250YWluZXIucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdGhlIHR5cGUgYW5kIHByb3ZpZGVyXG4gICAgICBjb25zdCB7XG4gICAgICAgIHNvdXJjZXMsXG4gICAgICAgIHR5cGVcbiAgICAgIH0gPSBpbnB1dDtcbiAgICAgIGNvbnN0IFt7XG4gICAgICAgIHByb3ZpZGVyID0gcHJvdmlkZXJzLmh0bWw1LFxuICAgICAgICBzcmNcbiAgICAgIH1dID0gc291cmNlcztcbiAgICAgIGNvbnN0IHRhZ05hbWUgPSBwcm92aWRlciA9PT0gJ2h0bWw1JyA/IHR5cGUgOiAnZGl2JztcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBwcm92aWRlciA9PT0gJ2h0bWw1JyA/IHt9IDoge1xuICAgICAgICBzcmNcbiAgICAgIH07XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcbiAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIC8vIENoZWNrIGZvciBzdXBwb3J0XG4gICAgICAgIHN1cHBvcnRlZDogc3VwcG9ydC5jaGVjayh0eXBlLCBwcm92aWRlciwgdGhpcy5jb25maWcucGxheXNpbmxpbmUpLFxuICAgICAgICAvLyBDcmVhdGUgbmV3IGVsZW1lbnRcbiAgICAgICAgbWVkaWE6IGNyZWF0ZUVsZW1lbnQodGFnTmFtZSwgYXR0cmlidXRlcylcbiAgICAgIH0pO1xuXG4gICAgICAvLyBJbmplY3QgdGhlIG5ldyBlbGVtZW50XG4gICAgICB0aGlzLmVsZW1lbnRzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLm1lZGlhKTtcblxuICAgICAgLy8gQXV0b3BsYXkgdGhlIG5ldyBzb3VyY2U/XG4gICAgICBpZiAoaXMuYm9vbGVhbihpbnB1dC5hdXRvcGxheSkpIHtcbiAgICAgICAgdGhpcy5jb25maWcuYXV0b3BsYXkgPSBpbnB1dC5hdXRvcGxheTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IGF0dHJpYnV0ZXMgZm9yIGF1ZGlvIGFuZCB2aWRlb1xuICAgICAgaWYgKHRoaXMuaXNIVE1MNSkge1xuICAgICAgICBpZiAodGhpcy5jb25maWcuY3Jvc3NvcmlnaW4pIHtcbiAgICAgICAgICB0aGlzLm1lZGlhLnNldEF0dHJpYnV0ZSgnY3Jvc3NvcmlnaW4nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmF1dG9wbGF5KSB7XG4gICAgICAgICAgdGhpcy5tZWRpYS5zZXRBdHRyaWJ1dGUoJ2F1dG9wbGF5JywgJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXMuZW1wdHkoaW5wdXQucG9zdGVyKSkge1xuICAgICAgICAgIHRoaXMucG9zdGVyID0gaW5wdXQucG9zdGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5sb29wLmFjdGl2ZSkge1xuICAgICAgICAgIHRoaXMubWVkaWEuc2V0QXR0cmlidXRlKCdsb29wJywgJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5tdXRlZCkge1xuICAgICAgICAgIHRoaXMubWVkaWEuc2V0QXR0cmlidXRlKCdtdXRlZCcsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25maWcucGxheXNpbmxpbmUpIHtcbiAgICAgICAgICB0aGlzLm1lZGlhLnNldEF0dHJpYnV0ZSgncGxheXNpbmxpbmUnLCAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVzdG9yZSBjbGFzcyBob29rXG4gICAgICB1aS5hZGRTdHlsZUhvb2suY2FsbCh0aGlzKTtcblxuICAgICAgLy8gU2V0IG5ldyBzb3VyY2VzIGZvciBodG1sNVxuICAgICAgaWYgKHRoaXMuaXNIVE1MNSkge1xuICAgICAgICBzb3VyY2UuaW5zZXJ0RWxlbWVudHMuY2FsbCh0aGlzLCAnc291cmNlJywgc291cmNlcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB2aWRlbyB0aXRsZVxuICAgICAgdGhpcy5jb25maWcudGl0bGUgPSBpbnB1dC50aXRsZTtcblxuICAgICAgLy8gU2V0IHVwIGZyb20gc2NyYXRjaFxuICAgICAgbWVkaWEuc2V0dXAuY2FsbCh0aGlzKTtcblxuICAgICAgLy8gSFRNTDUgc3R1ZmZcbiAgICAgIGlmICh0aGlzLmlzSFRNTDUpIHtcbiAgICAgICAgLy8gU2V0dXAgY2FwdGlvbnNcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGlucHV0KS5pbmNsdWRlcygndHJhY2tzJykpIHtcbiAgICAgICAgICBzb3VyY2UuaW5zZXJ0RWxlbWVudHMuY2FsbCh0aGlzLCAndHJhY2snLCBpbnB1dC50cmFja3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIEhUTUw1IG9yIGVtYmVkIGJ1dCBub3QgZnVsbHkgc3VwcG9ydGVkLCBzZXR1cEludGVyZmFjZSBhbmQgY2FsbCByZWFkeSBub3dcbiAgICAgIGlmICh0aGlzLmlzSFRNTDUgfHwgdGhpcy5pc0VtYmVkICYmICF0aGlzLnN1cHBvcnRlZC51aSkge1xuICAgICAgICAvLyBTZXR1cCBpbnRlcmZhY2VcbiAgICAgICAgdWkuYnVpbGQuY2FsbCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgLy8gTG9hZCBIVE1MNSBzb3VyY2VzXG4gICAgICBpZiAodGhpcy5pc0hUTUw1KSB7XG4gICAgICAgIHRoaXMubWVkaWEubG9hZCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgcHJldmlld1RodW1ibmFpbHMgY29uZmlnICYgcmVsb2FkIHBsdWdpblxuICAgICAgaWYgKCFpcy5lbXB0eShpbnB1dC5wcmV2aWV3VGh1bWJuYWlscykpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmNvbmZpZy5wcmV2aWV3VGh1bWJuYWlscywgaW5wdXQucHJldmlld1RodW1ibmFpbHMpO1xuXG4gICAgICAgIC8vIENsZWFudXAgcHJldmlld1RodW1ibmFpbHMgcGx1Z2luIGlmIGl0IHdhcyBsb2FkZWRcbiAgICAgICAgaWYgKHRoaXMucHJldmlld1RodW1ibmFpbHMgJiYgdGhpcy5wcmV2aWV3VGh1bWJuYWlscy5sb2FkZWQpIHtcbiAgICAgICAgICB0aGlzLnByZXZpZXdUaHVtYm5haWxzLmRlc3Ryb3koKTtcbiAgICAgICAgICB0aGlzLnByZXZpZXdUaHVtYm5haWxzID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2UgaWYgaXQgaXMgc3RpbGwgZW5hYmxlZFxuICAgICAgICBpZiAodGhpcy5jb25maWcucHJldmlld1RodW1ibmFpbHMuZW5hYmxlZCkge1xuICAgICAgICAgIHRoaXMucHJldmlld1RodW1ibmFpbHMgPSBuZXcgUHJldmlld1RodW1ibmFpbHModGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIHRoZSBmdWxsc2NyZWVuIHN1cHBvcnRcbiAgICAgIHRoaXMuZnVsbHNjcmVlbi51cGRhdGUoKTtcbiAgICB9LCB0cnVlKTtcbiAgfVxufTtcblxuLy8gUHJpdmF0ZSBwcm9wZXJ0aWVzXG4vLyBUT0RPOiBVc2UgYSBXZWFrTWFwIGZvciBwcml2YXRlIGdsb2JhbHNcbi8vIGNvbnN0IGdsb2JhbHMgPSBuZXcgV2Vha01hcCgpO1xuXG4vLyBQbHlyIGluc3RhbmNlXG5jbGFzcyBQbHlyIHtcbiAgY29uc3RydWN0b3IodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogUGxheSB0aGUgbWVkaWEsIG9yIHBsYXkgdGhlIGFkdmVydGlzZW1lbnQgKGlmIHRoZXkgYXJlIG5vdCBibG9ja2VkKVxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwicGxheVwiLCAoKSA9PiB7XG4gICAgICBpZiAoIWlzLmZ1bmN0aW9uKHRoaXMubWVkaWEucGxheSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVjZXB0IHBsYXkgd2l0aCBhZHNcbiAgICAgIGlmICh0aGlzLmFkcyAmJiB0aGlzLmFkcy5lbmFibGVkKSB7XG4gICAgICAgIHRoaXMuYWRzLm1hbmFnZXJQcm9taXNlLnRoZW4oKCkgPT4gdGhpcy5hZHMucGxheSgpKS5jYXRjaCgoKSA9PiBzaWxlbmNlUHJvbWlzZSh0aGlzLm1lZGlhLnBsYXkoKSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gdGhlIHByb21pc2UgKGZvciBIVE1MNSlcbiAgICAgIHJldHVybiB0aGlzLm1lZGlhLnBsYXkoKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBQYXVzZSB0aGUgbWVkaWFcbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkkMSh0aGlzLCBcInBhdXNlXCIsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5wbGF5aW5nIHx8ICFpcy5mdW5jdGlvbih0aGlzLm1lZGlhLnBhdXNlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1lZGlhLnBhdXNlKCk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHBsYXliYWNrIGJhc2VkIG9uIGN1cnJlbnQgc3RhdHVzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbnB1dFxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwidG9nZ2xlUGxheVwiLCBpbnB1dCA9PiB7XG4gICAgICAvLyBUb2dnbGUgYmFzZWQgb24gY3VycmVudCBzdGF0ZSBpZiBub3RoaW5nIHBhc3NlZFxuICAgICAgY29uc3QgdG9nZ2xlID0gaXMuYm9vbGVhbihpbnB1dCkgPyBpbnB1dCA6ICF0aGlzLnBsYXlpbmc7XG4gICAgICBpZiAodG9nZ2xlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBsYXkoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBhdXNlKCk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogU3RvcCBwbGF5YmFja1xuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwic3RvcFwiLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pc0hUTUw1KSB7XG4gICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgdGhpcy5yZXN0YXJ0KCk7XG4gICAgICB9IGVsc2UgaWYgKGlzLmZ1bmN0aW9uKHRoaXMubWVkaWEuc3RvcCkpIHtcbiAgICAgICAgdGhpcy5tZWRpYS5zdG9wKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmVzdGFydCBwbGF5YmFja1xuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwicmVzdGFydFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXdpbmRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2Vla1RpbWUgLSBob3cgZmFyIHRvIHJld2luZCBpbiBzZWNvbmRzLiBEZWZhdWx0cyB0byB0aGUgY29uZmlnLnNlZWtUaW1lXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5JDEodGhpcywgXCJyZXdpbmRcIiwgc2Vla1RpbWUgPT4ge1xuICAgICAgdGhpcy5jdXJyZW50VGltZSAtPSBpcy5udW1iZXIoc2Vla1RpbWUpID8gc2Vla1RpbWUgOiB0aGlzLmNvbmZpZy5zZWVrVGltZTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBGYXN0IGZvcndhcmRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2Vla1RpbWUgLSBob3cgZmFyIHRvIGZhc3QgZm9yd2FyZCBpbiBzZWNvbmRzLiBEZWZhdWx0cyB0byB0aGUgY29uZmlnLnNlZWtUaW1lXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5JDEodGhpcywgXCJmb3J3YXJkXCIsIHNlZWtUaW1lID0+IHtcbiAgICAgIHRoaXMuY3VycmVudFRpbWUgKz0gaXMubnVtYmVyKHNlZWtUaW1lKSA/IHNlZWtUaW1lIDogdGhpcy5jb25maWcuc2Vla1RpbWU7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogSW5jcmVhc2Ugdm9sdW1lXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdGVwIC0gSG93IG11Y2ggdG8gZGVjcmVhc2UgYnkgKGJldHdlZW4gMCBhbmQgMSlcbiAgICAgKi9cbiAgICBfZGVmaW5lUHJvcGVydHkkMSh0aGlzLCBcImluY3JlYXNlVm9sdW1lXCIsIHN0ZXAgPT4ge1xuICAgICAgY29uc3Qgdm9sdW1lID0gdGhpcy5tZWRpYS5tdXRlZCA/IDAgOiB0aGlzLnZvbHVtZTtcbiAgICAgIHRoaXMudm9sdW1lID0gdm9sdW1lICsgKGlzLm51bWJlcihzdGVwKSA/IHN0ZXAgOiAwKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBEZWNyZWFzZSB2b2x1bWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0ZXAgLSBIb3cgbXVjaCB0byBkZWNyZWFzZSBieSAoYmV0d2VlbiAwIGFuZCAxKVxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwiZGVjcmVhc2VWb2x1bWVcIiwgc3RlcCA9PiB7XG4gICAgICB0aGlzLmluY3JlYXNlVm9sdW1lKC1zdGVwKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIHRoZSBhaXJwbGF5IGRpYWxvZ1xuICAgICAqIFRPRE86IHVwZGF0ZSBwbGF5ZXIgd2l0aCBzdGF0ZSwgc3VwcG9ydCwgZW5hYmxlZFxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwiYWlycGxheVwiLCAoKSA9PiB7XG4gICAgICAvLyBTaG93IGRpYWxvZyBpZiBzdXBwb3J0ZWRcbiAgICAgIGlmIChzdXBwb3J0LmFpcnBsYXkpIHtcbiAgICAgICAgdGhpcy5tZWRpYS53ZWJraXRTaG93UGxheWJhY2tUYXJnZXRQaWNrZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBUb2dnbGUgdGhlIHBsYXllciBjb250cm9sc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3RvZ2dsZV0gLSBXaGV0aGVyIHRvIHNob3cgdGhlIGNvbnRyb2xzXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5JDEodGhpcywgXCJ0b2dnbGVDb250cm9sc1wiLCB0b2dnbGUgPT4ge1xuICAgICAgLy8gRG9uJ3QgdG9nZ2xlIGlmIG1pc3NpbmcgVUkgc3VwcG9ydCBvciBpZiBpdCdzIGF1ZGlvXG4gICAgICBpZiAodGhpcy5zdXBwb3J0ZWQudWkgJiYgIXRoaXMuaXNBdWRpbykge1xuICAgICAgICAvLyBHZXQgc3RhdGUgYmVmb3JlIGNoYW5nZVxuICAgICAgICBjb25zdCBpc0hpZGRlbiA9IGhhc0NsYXNzKHRoaXMuZWxlbWVudHMuY29udGFpbmVyLCB0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmhpZGVDb250cm9scyk7XG4gICAgICAgIC8vIE5lZ2F0ZSB0aGUgYXJndW1lbnQgaWYgbm90IHVuZGVmaW5lZCBzaW5jZSBhZGRpbmcgdGhlIGNsYXNzIHRvIGhpZGVzIHRoZSBjb250cm9sc1xuICAgICAgICBjb25zdCBmb3JjZSA9IHR5cGVvZiB0b2dnbGUgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogIXRvZ2dsZTtcbiAgICAgICAgLy8gQXBwbHkgYW5kIGdldCB1cGRhdGVkIHN0YXRlXG4gICAgICAgIGNvbnN0IGhpZGluZyA9IHRvZ2dsZUNsYXNzKHRoaXMuZWxlbWVudHMuY29udGFpbmVyLCB0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmhpZGVDb250cm9scywgZm9yY2UpO1xuXG4gICAgICAgIC8vIENsb3NlIG1lbnVcbiAgICAgICAgaWYgKGhpZGluZyAmJiBpcy5hcnJheSh0aGlzLmNvbmZpZy5jb250cm9scykgJiYgdGhpcy5jb25maWcuY29udHJvbHMuaW5jbHVkZXMoJ3NldHRpbmdzJykgJiYgIWlzLmVtcHR5KHRoaXMuY29uZmlnLnNldHRpbmdzKSkge1xuICAgICAgICAgIGNvbnRyb2xzLnRvZ2dsZU1lbnUuY2FsbCh0aGlzLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmlnZ2VyIGV2ZW50IG9uIGNoYW5nZVxuICAgICAgICBpZiAoaGlkaW5nICE9PSBpc0hpZGRlbikge1xuICAgICAgICAgIGNvbnN0IGV2ZW50TmFtZSA9IGhpZGluZyA/ICdjb250cm9sc2hpZGRlbicgOiAnY29udHJvbHNzaG93bic7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50LmNhbGwodGhpcywgdGhpcy5tZWRpYSwgZXZlbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWhpZGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBBZGQgZXZlbnQgbGlzdGVuZXJzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IC0gRXZlbnQgdHlwZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlbnQgb2NjdXJzXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5JDEodGhpcywgXCJvblwiLCAoZXZlbnQsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBvbi5jYWxsKHRoaXMsIHRoaXMuZWxlbWVudHMuY29udGFpbmVyLCBldmVudCwgY2FsbGJhY2spO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEFkZCBldmVudCBsaXN0ZW5lcnMgb25jZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAtIEV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIGZvciB3aGVuIGV2ZW50IG9jY3Vyc1xuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwib25jZVwiLCAoZXZlbnQsIGNhbGxiYWNrKSA9PiB7XG4gICAgICBvbmNlLmNhbGwodGhpcywgdGhpcy5lbGVtZW50cy5jb250YWluZXIsIGV2ZW50LCBjYWxsYmFjayk7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAtIEV2ZW50IHR5cGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIGZvciB3aGVuIGV2ZW50IG9jY3Vyc1xuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwib2ZmXCIsIChldmVudCwgY2FsbGJhY2spID0+IHtcbiAgICAgIG9mZih0aGlzLmVsZW1lbnRzLmNvbnRhaW5lciwgZXZlbnQsIGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95IGFuIGluc3RhbmNlXG4gICAgICogRXZlbnQgbGlzdGVuZXJzIGFyZSByZW1vdmVkIHdoZW4gZWxlbWVudHMgYXJlIHJlbW92ZWRcbiAgICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyNTI4MDQ5L2lmLWEtZG9tLWVsZW1lbnQtaXMtcmVtb3ZlZC1hcmUtaXRzLWxpc3RlbmVycy1hbHNvLXJlbW92ZWQtZnJvbS1tZW1vcnlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIGZvciB3aGVuIGRlc3Ryb3kgaXMgY29tcGxldGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNvZnQgLSBXaGV0aGVyIGl0J3MgYSBzb2Z0IGRlc3Ryb3kgKGZvciBzb3VyY2UgY2hhbmdlcyBldGMpXG4gICAgICovXG4gICAgX2RlZmluZVByb3BlcnR5JDEodGhpcywgXCJkZXN0cm95XCIsIChjYWxsYmFjaywgc29mdCA9IGZhbHNlKSA9PiB7XG4gICAgICBpZiAoIXRoaXMucmVhZHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICAgICAgLy8gUmVzZXQgb3ZlcmZsb3cgKGluY2FzZSBkZXN0cm95ZWQgd2hpbGUgaW4gZnVsbHNjcmVlbilcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICcnO1xuXG4gICAgICAgIC8vIEdDIGZvciBlbWJlZFxuICAgICAgICB0aGlzLmVtYmVkID0gbnVsbDtcblxuICAgICAgICAvLyBJZiBpdCdzIGEgc29mdCBkZXN0cm95LCBtYWtlIG1pbmltYWwgY2hhbmdlc1xuICAgICAgICBpZiAoc29mdCkge1xuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmVsZW1lbnRzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBlbGVtZW50c1xuICAgICAgICAgICAgcmVtb3ZlRWxlbWVudCh0aGlzLmVsZW1lbnRzLmJ1dHRvbnMucGxheSk7XG4gICAgICAgICAgICByZW1vdmVFbGVtZW50KHRoaXMuZWxlbWVudHMuY2FwdGlvbnMpO1xuICAgICAgICAgICAgcmVtb3ZlRWxlbWVudCh0aGlzLmVsZW1lbnRzLmNvbnRyb2xzKTtcbiAgICAgICAgICAgIHJlbW92ZUVsZW1lbnQodGhpcy5lbGVtZW50cy53cmFwcGVyKTtcblxuICAgICAgICAgICAgLy8gQ2xlYXIgZm9yIEdDXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzLmJ1dHRvbnMucGxheSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzLmNhcHRpb25zID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMuY29udHJvbHMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50cy53cmFwcGVyID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDYWxsYmFja1xuICAgICAgICAgIGlmIChpcy5mdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFVuYmluZCBsaXN0ZW5lcnNcbiAgICAgICAgICB1bmJpbmRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcblxuICAgICAgICAgIC8vIENhbmNlbCBjdXJyZW50IG5ldHdvcmsgcmVxdWVzdHNcbiAgICAgICAgICBodG1sNS5jYW5jZWxSZXF1ZXN0cy5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgLy8gUmVwbGFjZSB0aGUgY29udGFpbmVyIHdpdGggdGhlIG9yaWdpbmFsIGVsZW1lbnQgcHJvdmlkZWRcbiAgICAgICAgICByZXBsYWNlRWxlbWVudCh0aGlzLmVsZW1lbnRzLm9yaWdpbmFsLCB0aGlzLmVsZW1lbnRzLmNvbnRhaW5lcik7XG5cbiAgICAgICAgICAvLyBFdmVudFxuICAgICAgICAgIHRyaWdnZXJFdmVudC5jYWxsKHRoaXMsIHRoaXMuZWxlbWVudHMub3JpZ2luYWwsICdkZXN0cm95ZWQnLCB0cnVlKTtcblxuICAgICAgICAgIC8vIENhbGxiYWNrXG4gICAgICAgICAgaWYgKGlzLmZ1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLmVsZW1lbnRzLm9yaWdpbmFsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZXNldCBzdGF0ZVxuICAgICAgICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcblxuICAgICAgICAgIC8vIENsZWFyIGZvciBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5tZWRpYSA9IG51bGw7XG4gICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gU3RvcCBwbGF5YmFja1xuICAgICAgdGhpcy5zdG9wKCk7XG5cbiAgICAgIC8vIENsZWFyIHRpbWVvdXRzXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcnMubG9hZGluZyk7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcnMuY29udHJvbHMpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnJlc2l6ZWQpO1xuXG4gICAgICAvLyBQcm92aWRlciBzcGVjaWZpYyBzdHVmZlxuICAgICAgaWYgKHRoaXMuaXNIVE1MNSkge1xuICAgICAgICAvLyBSZXN0b3JlIG5hdGl2ZSB2aWRlbyBjb250cm9sc1xuICAgICAgICB1aS50b2dnbGVOYXRpdmVDb250cm9scy5jYWxsKHRoaXMsIHRydWUpO1xuXG4gICAgICAgIC8vIENsZWFuIHVwXG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1lvdVR1YmUpIHtcbiAgICAgICAgLy8gQ2xlYXIgdGltZXJzXG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcnMuYnVmZmVyaW5nKTtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVycy5wbGF5aW5nKTtcblxuICAgICAgICAvLyBEZXN0cm95IFlvdVR1YmUgQVBJXG4gICAgICAgIGlmICh0aGlzLmVtYmVkICE9PSBudWxsICYmIGlzLmZ1bmN0aW9uKHRoaXMuZW1iZWQuZGVzdHJveSkpIHtcbiAgICAgICAgICB0aGlzLmVtYmVkLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENsZWFuIHVwXG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1ZpbWVvKSB7XG4gICAgICAgIC8vIERlc3Ryb3kgVmltZW8gQVBJXG4gICAgICAgIC8vIHRoZW4gY2xlYW4gdXAgKHdhaXQsIHRvIHByZXZlbnQgcG9zdG1lc3NhZ2UgZXJyb3JzKVxuICAgICAgICBpZiAodGhpcy5lbWJlZCAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuZW1iZWQudW5sb2FkKCkudGhlbihkb25lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZpbWVvIGRvZXMgbm90IGFsd2F5cyByZXR1cm5cbiAgICAgICAgc2V0VGltZW91dChkb25lLCAyMDApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENoZWNrIGZvciBzdXBwb3J0IGZvciBhIG1pbWUgdHlwZSAoSFRNTDUgb25seSlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIE1pbWUgdHlwZVxuICAgICAqL1xuICAgIF9kZWZpbmVQcm9wZXJ0eSQxKHRoaXMsIFwic3VwcG9ydHNcIiwgdHlwZSA9PiBzdXBwb3J0Lm1pbWUuY2FsbCh0aGlzLCB0eXBlKSk7XG4gICAgdGhpcy50aW1lcnMgPSB7fTtcblxuICAgIC8vIFN0YXRlXG4gICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZmFpbGVkID0gZmFsc2U7XG5cbiAgICAvLyBUb3VjaCBkZXZpY2VcbiAgICB0aGlzLnRvdWNoID0gc3VwcG9ydC50b3VjaDtcblxuICAgIC8vIFNldCB0aGUgbWVkaWEgZWxlbWVudFxuICAgIHRoaXMubWVkaWEgPSB0YXJnZXQ7XG5cbiAgICAvLyBTdHJpbmcgc2VsZWN0b3IgcGFzc2VkXG4gICAgaWYgKGlzLnN0cmluZyh0aGlzLm1lZGlhKSkge1xuICAgICAgdGhpcy5tZWRpYSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5tZWRpYSk7XG4gICAgfVxuXG4gICAgLy8galF1ZXJ5LCBOb2RlTGlzdCBvciBBcnJheSBwYXNzZWQsIHVzZSBmaXJzdCBlbGVtZW50XG4gICAgaWYgKHdpbmRvdy5qUXVlcnkgJiYgdGhpcy5tZWRpYSBpbnN0YW5jZW9mIGpRdWVyeSB8fCBpcy5ub2RlTGlzdCh0aGlzLm1lZGlhKSB8fCBpcy5hcnJheSh0aGlzLm1lZGlhKSkge1xuICAgICAgdGhpcy5tZWRpYSA9IHRoaXMubWVkaWFbMF07XG4gICAgfVxuXG4gICAgLy8gU2V0IGNvbmZpZ1xuICAgIHRoaXMuY29uZmlnID0gZXh0ZW5kKHt9LCBkZWZhdWx0cywgUGx5ci5kZWZhdWx0cywgb3B0aW9ucyB8fCB7fSwgKCgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMubWVkaWEuZ2V0QXR0cmlidXRlKCdkYXRhLXBseXItY29uZmlnJykpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9KSgpKTtcblxuICAgIC8vIEVsZW1lbnRzIGNhY2hlXG4gICAgdGhpcy5lbGVtZW50cyA9IHtcbiAgICAgIGNvbnRhaW5lcjogbnVsbCxcbiAgICAgIGZ1bGxzY3JlZW46IG51bGwsXG4gICAgICBjYXB0aW9uczogbnVsbCxcbiAgICAgIGJ1dHRvbnM6IHt9LFxuICAgICAgZGlzcGxheToge30sXG4gICAgICBwcm9ncmVzczoge30sXG4gICAgICBpbnB1dHM6IHt9LFxuICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgcG9wdXA6IG51bGwsXG4gICAgICAgIG1lbnU6IG51bGwsXG4gICAgICAgIHBhbmVsczoge30sXG4gICAgICAgIGJ1dHRvbnM6IHt9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIENhcHRpb25zXG4gICAgdGhpcy5jYXB0aW9ucyA9IHtcbiAgICAgIGFjdGl2ZTogbnVsbCxcbiAgICAgIGN1cnJlbnRUcmFjazogLTEsXG4gICAgICBtZXRhOiBuZXcgV2Vha01hcCgpXG4gICAgfTtcblxuICAgIC8vIEZ1bGxzY3JlZW5cbiAgICB0aGlzLmZ1bGxzY3JlZW4gPSB7XG4gICAgICBhY3RpdmU6IGZhbHNlXG4gICAgfTtcblxuICAgIC8vIE9wdGlvbnNcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBzcGVlZDogW10sXG4gICAgICBxdWFsaXR5OiBbXVxuICAgIH07XG5cbiAgICAvLyBEZWJ1Z2dpbmdcbiAgICAvLyBUT0RPOiBtb3ZlIHRvIGdsb2JhbHNcbiAgICB0aGlzLmRlYnVnID0gbmV3IENvbnNvbGUodGhpcy5jb25maWcuZGVidWcpO1xuXG4gICAgLy8gTG9nIGNvbmZpZyBvcHRpb25zIGFuZCBzdXBwb3J0XG4gICAgdGhpcy5kZWJ1Zy5sb2coJ0NvbmZpZycsIHRoaXMuY29uZmlnKTtcbiAgICB0aGlzLmRlYnVnLmxvZygnU3VwcG9ydCcsIHN1cHBvcnQpO1xuXG4gICAgLy8gV2UgbmVlZCBhbiBlbGVtZW50IHRvIHNldHVwXG4gICAgaWYgKGlzLm51bGxPclVuZGVmaW5lZCh0aGlzLm1lZGlhKSB8fCAhaXMuZWxlbWVudCh0aGlzLm1lZGlhKSkge1xuICAgICAgdGhpcy5kZWJ1Zy5lcnJvcignU2V0dXAgZmFpbGVkOiBubyBzdWl0YWJsZSBlbGVtZW50IHBhc3NlZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEJhaWwgaWYgdGhlIGVsZW1lbnQgaXMgaW5pdGlhbGl6ZWRcbiAgICBpZiAodGhpcy5tZWRpYS5wbHlyKSB7XG4gICAgICB0aGlzLmRlYnVnLndhcm4oJ1RhcmdldCBhbHJlYWR5IHNldHVwJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQmFpbCBpZiBub3QgZW5hYmxlZFxuICAgIGlmICghdGhpcy5jb25maWcuZW5hYmxlZCkge1xuICAgICAgdGhpcy5kZWJ1Zy5lcnJvcignU2V0dXAgZmFpbGVkOiBkaXNhYmxlZCBieSBjb25maWcnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBCYWlsIGlmIGRpc2FibGVkIG9yIG5vIGJhc2ljIHN1cHBvcnRcbiAgICAvLyBZb3UgbWF5IHdhbnQgdG8gZGlzYWJsZSBjZXJ0YWluIFVBcyBldGNcbiAgICBpZiAoIXN1cHBvcnQuY2hlY2soKS5hcGkpIHtcbiAgICAgIHRoaXMuZGVidWcuZXJyb3IoJ1NldHVwIGZhaWxlZDogbm8gc3VwcG9ydCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENhY2hlIG9yaWdpbmFsIGVsZW1lbnQgc3RhdGUgZm9yIC5kZXN0cm95KClcbiAgICBjb25zdCBjbG9uZSA9IHRoaXMubWVkaWEuY2xvbmVOb2RlKHRydWUpO1xuICAgIGNsb25lLmF1dG9wbGF5ID0gZmFsc2U7XG4gICAgdGhpcy5lbGVtZW50cy5vcmlnaW5hbCA9IGNsb25lO1xuXG4gICAgLy8gU2V0IG1lZGlhIHR5cGUgYmFzZWQgb24gdGFnIG9yIGRhdGEgYXR0cmlidXRlXG4gICAgLy8gU3VwcG9ydGVkOiB2aWRlbywgYXVkaW8sIHZpbWVvLCB5b3V0dWJlXG4gICAgY29uc3QgX3R5cGUgPSB0aGlzLm1lZGlhLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBFbWJlZCBwcm9wZXJ0aWVzXG4gICAgbGV0IGlmcmFtZSA9IG51bGw7XG4gICAgbGV0IHVybCA9IG51bGw7XG5cbiAgICAvLyBEaWZmZXJlbnQgc2V0dXAgYmFzZWQgb24gdHlwZVxuICAgIHN3aXRjaCAoX3R5cGUpIHtcbiAgICAgIGNhc2UgJ2Rpdic6XG4gICAgICAgIC8vIEZpbmQgdGhlIGZyYW1lXG4gICAgICAgIGlmcmFtZSA9IHRoaXMubWVkaWEucXVlcnlTZWxlY3RvcignaWZyYW1lJyk7XG5cbiAgICAgICAgLy8gPGlmcmFtZT4gdHlwZVxuICAgICAgICBpZiAoaXMuZWxlbWVudChpZnJhbWUpKSB7XG4gICAgICAgICAgLy8gRGV0ZWN0IHByb3ZpZGVyXG4gICAgICAgICAgdXJsID0gcGFyc2VVcmwoaWZyYW1lLmdldEF0dHJpYnV0ZSgnc3JjJykpO1xuICAgICAgICAgIHRoaXMucHJvdmlkZXIgPSBnZXRQcm92aWRlckJ5VXJsKHVybC50b1N0cmluZygpKTtcblxuICAgICAgICAgIC8vIFJld29yayBlbGVtZW50c1xuICAgICAgICAgIHRoaXMuZWxlbWVudHMuY29udGFpbmVyID0gdGhpcy5tZWRpYTtcbiAgICAgICAgICB0aGlzLm1lZGlhID0gaWZyYW1lO1xuXG4gICAgICAgICAgLy8gUmVzZXQgY2xhc3NuYW1lXG4gICAgICAgICAgdGhpcy5lbGVtZW50cy5jb250YWluZXIuY2xhc3NOYW1lID0gJyc7XG5cbiAgICAgICAgICAvLyBHZXQgYXR0cmlidXRlcyBmcm9tIFVSTCBhbmQgc2V0IGNvbmZpZ1xuICAgICAgICAgIGlmICh1cmwuc2VhcmNoLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgdHJ1dGh5ID0gWycxJywgJ3RydWUnXTtcbiAgICAgICAgICAgIGlmICh0cnV0aHkuaW5jbHVkZXModXJsLnNlYXJjaFBhcmFtcy5nZXQoJ2F1dG9wbGF5JykpKSB7XG4gICAgICAgICAgICAgIHRoaXMuY29uZmlnLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cnV0aHkuaW5jbHVkZXModXJsLnNlYXJjaFBhcmFtcy5nZXQoJ2xvb3AnKSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5jb25maWcubG9vcC5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUT0RPOiByZXBsYWNlIGZ1bGxzY3JlZW4uaW9zTmF0aXZlIHdpdGggdGhpcyBwbGF5c2lubGluZSBjb25maWcgb3B0aW9uXG4gICAgICAgICAgICAvLyBZb3VUdWJlIHJlcXVpcmVzIHRoZSBwbGF5c2lubGluZSBpbiB0aGUgVVJMXG4gICAgICAgICAgICBpZiAodGhpcy5pc1lvdVR1YmUpIHtcbiAgICAgICAgICAgICAgdGhpcy5jb25maWcucGxheXNpbmxpbmUgPSB0cnV0aHkuaW5jbHVkZXModXJsLnNlYXJjaFBhcmFtcy5nZXQoJ3BsYXlzaW5saW5lJykpO1xuICAgICAgICAgICAgICB0aGlzLmNvbmZpZy55b3V0dWJlLmhsID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoJ2hsJyk7IC8vIFRPRE86IFNob3VsZCB0aGlzIGJlIHNldHRpbmcgbGFuZ3VhZ2U/XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5wbGF5c2lubGluZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIDxkaXY+IHdpdGggYXR0cmlidXRlc1xuICAgICAgICAgIHRoaXMucHJvdmlkZXIgPSB0aGlzLm1lZGlhLmdldEF0dHJpYnV0ZSh0aGlzLmNvbmZpZy5hdHRyaWJ1dGVzLmVtYmVkLnByb3ZpZGVyKTtcblxuICAgICAgICAgIC8vIFJlbW92ZSBhdHRyaWJ1dGVcbiAgICAgICAgICB0aGlzLm1lZGlhLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLmNvbmZpZy5hdHRyaWJ1dGVzLmVtYmVkLnByb3ZpZGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVuc3VwcG9ydGVkIG9yIG1pc3NpbmcgcHJvdmlkZXJcbiAgICAgICAgaWYgKGlzLmVtcHR5KHRoaXMucHJvdmlkZXIpIHx8ICFPYmplY3QudmFsdWVzKHByb3ZpZGVycykuaW5jbHVkZXModGhpcy5wcm92aWRlcikpIHtcbiAgICAgICAgICB0aGlzLmRlYnVnLmVycm9yKCdTZXR1cCBmYWlsZWQ6IEludmFsaWQgcHJvdmlkZXInKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBdWRpbyB3aWxsIGNvbWUgbGF0ZXIgZm9yIGV4dGVybmFsIHByb3ZpZGVyc1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlcy52aWRlbztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd2aWRlbyc6XG4gICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgIHRoaXMudHlwZSA9IF90eXBlO1xuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXJzLmh0bWw1O1xuXG4gICAgICAgIC8vIEdldCBjb25maWcgZnJvbSBhdHRyaWJ1dGVzXG4gICAgICAgIGlmICh0aGlzLm1lZGlhLmhhc0F0dHJpYnV0ZSgnY3Jvc3NvcmlnaW4nKSkge1xuICAgICAgICAgIHRoaXMuY29uZmlnLmNyb3Nzb3JpZ2luID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tZWRpYS5oYXNBdHRyaWJ1dGUoJ2F1dG9wbGF5JykpIHtcbiAgICAgICAgICB0aGlzLmNvbmZpZy5hdXRvcGxheSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWVkaWEuaGFzQXR0cmlidXRlKCdwbGF5c2lubGluZScpIHx8IHRoaXMubWVkaWEuaGFzQXR0cmlidXRlKCd3ZWJraXQtcGxheXNpbmxpbmUnKSkge1xuICAgICAgICAgIHRoaXMuY29uZmlnLnBsYXlzaW5saW5lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tZWRpYS5oYXNBdHRyaWJ1dGUoJ211dGVkJykpIHtcbiAgICAgICAgICB0aGlzLmNvbmZpZy5tdXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWVkaWEuaGFzQXR0cmlidXRlKCdsb29wJykpIHtcbiAgICAgICAgICB0aGlzLmNvbmZpZy5sb29wLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmRlYnVnLmVycm9yKCdTZXR1cCBmYWlsZWQ6IHVuc3VwcG9ydGVkIHR5cGUnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBzdXBwb3J0IGFnYWluIGJ1dCB3aXRoIHR5cGVcbiAgICB0aGlzLnN1cHBvcnRlZCA9IHN1cHBvcnQuY2hlY2sodGhpcy50eXBlLCB0aGlzLnByb3ZpZGVyKTtcblxuICAgIC8vIElmIG5vIHN1cHBvcnQgZm9yIGV2ZW4gQVBJLCBiYWlsXG4gICAgaWYgKCF0aGlzLnN1cHBvcnRlZC5hcGkpIHtcbiAgICAgIHRoaXMuZGVidWcuZXJyb3IoJ1NldHVwIGZhaWxlZDogbm8gc3VwcG9ydCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0gW107XG5cbiAgICAvLyBDcmVhdGUgbGlzdGVuZXJzXG4gICAgdGhpcy5saXN0ZW5lcnMgPSBuZXcgTGlzdGVuZXJzKHRoaXMpO1xuXG4gICAgLy8gU2V0dXAgbG9jYWwgc3RvcmFnZSBmb3IgdXNlciBzZXR0aW5nc1xuICAgIHRoaXMuc3RvcmFnZSA9IG5ldyBTdG9yYWdlKHRoaXMpO1xuXG4gICAgLy8gU3RvcmUgcmVmZXJlbmNlXG4gICAgdGhpcy5tZWRpYS5wbHlyID0gdGhpcztcblxuICAgIC8vIFdyYXAgbWVkaWFcbiAgICBpZiAoIWlzLmVsZW1lbnQodGhpcy5lbGVtZW50cy5jb250YWluZXIpKSB7XG4gICAgICB0aGlzLmVsZW1lbnRzLmNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgd3JhcCh0aGlzLm1lZGlhLCB0aGlzLmVsZW1lbnRzLmNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgLy8gTWlncmF0ZSBjdXN0b20gcHJvcGVydGllcyBmcm9tIG1lZGlhIHRvIGNvbnRhaW5lciAoc28gdGhleSB3b3JrIPCfmIkpXG4gICAgdWkubWlncmF0ZVN0eWxlcy5jYWxsKHRoaXMpO1xuXG4gICAgLy8gQWRkIHN0eWxlIGhvb2tcbiAgICB1aS5hZGRTdHlsZUhvb2suY2FsbCh0aGlzKTtcblxuICAgIC8vIFNldHVwIG1lZGlhXG4gICAgbWVkaWEuc2V0dXAuY2FsbCh0aGlzKTtcblxuICAgIC8vIExpc3RlbiBmb3IgZXZlbnRzIGlmIGRlYnVnZ2luZ1xuICAgIGlmICh0aGlzLmNvbmZpZy5kZWJ1Zykge1xuICAgICAgb24uY2FsbCh0aGlzLCB0aGlzLmVsZW1lbnRzLmNvbnRhaW5lciwgdGhpcy5jb25maWcuZXZlbnRzLmpvaW4oJyAnKSwgZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLmRlYnVnLmxvZyhgZXZlbnQ6ICR7ZXZlbnQudHlwZX1gKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFNldHVwIGZ1bGxzY3JlZW5cbiAgICB0aGlzLmZ1bGxzY3JlZW4gPSBuZXcgRnVsbHNjcmVlbih0aGlzKTtcblxuICAgIC8vIFNldHVwIGludGVyZmFjZVxuICAgIC8vIElmIGVtYmVkIGJ1dCBub3QgZnVsbHkgc3VwcG9ydGVkLCBidWlsZCBpbnRlcmZhY2Ugbm93IHRvIGF2b2lkIGZsYXNoIG9mIGNvbnRyb2xzXG4gICAgaWYgKHRoaXMuaXNIVE1MNSB8fCB0aGlzLmlzRW1iZWQgJiYgIXRoaXMuc3VwcG9ydGVkLnVpKSB7XG4gICAgICB1aS5idWlsZC5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIENvbnRhaW5lciBsaXN0ZW5lcnNcbiAgICB0aGlzLmxpc3RlbmVycy5jb250YWluZXIoKTtcblxuICAgIC8vIEdsb2JhbCBsaXN0ZW5lcnNcbiAgICB0aGlzLmxpc3RlbmVycy5nbG9iYWwoKTtcblxuICAgIC8vIFNldHVwIGFkcyBpZiBwcm92aWRlZFxuICAgIGlmICh0aGlzLmNvbmZpZy5hZHMuZW5hYmxlZCkge1xuICAgICAgdGhpcy5hZHMgPSBuZXcgQWRzKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIEF1dG9wbGF5IGlmIHJlcXVpcmVkXG4gICAgaWYgKHRoaXMuaXNIVE1MNSAmJiB0aGlzLmNvbmZpZy5hdXRvcGxheSkge1xuICAgICAgdGhpcy5vbmNlKCdjYW5wbGF5JywgKCkgPT4gc2lsZW5jZVByb21pc2UodGhpcy5wbGF5KCkpKTtcbiAgICB9XG5cbiAgICAvLyBTZWVrIHRpbWUgd2lsbCBiZSByZWNvcmRlZCAoaW4gbGlzdGVuZXJzLmpzKSBzbyB3ZSBjYW4gcHJldmVudCBoaWRpbmcgY29udHJvbHMgZm9yIGEgZmV3IHNlY29uZHMgYWZ0ZXIgc2Vla1xuICAgIHRoaXMubGFzdFNlZWtUaW1lID0gMDtcblxuICAgIC8vIFNldHVwIHByZXZpZXcgdGh1bWJuYWlscyBpZiBlbmFibGVkXG4gICAgaWYgKHRoaXMuY29uZmlnLnByZXZpZXdUaHVtYm5haWxzLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMucHJldmlld1RodW1ibmFpbHMgPSBuZXcgUHJldmlld1RodW1ibmFpbHModGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEFQSVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogVHlwZXMgYW5kIHByb3ZpZGVyIGhlbHBlcnNcbiAgICovXG4gIGdldCBpc0hUTUw1KCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyID09PSBwcm92aWRlcnMuaHRtbDU7XG4gIH1cbiAgZ2V0IGlzRW1iZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNZb3VUdWJlIHx8IHRoaXMuaXNWaW1lbztcbiAgfVxuICBnZXQgaXNZb3VUdWJlKCkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyID09PSBwcm92aWRlcnMueW91dHViZTtcbiAgfVxuICBnZXQgaXNWaW1lbygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlciA9PT0gcHJvdmlkZXJzLnZpbWVvO1xuICB9XG4gIGdldCBpc1ZpZGVvKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGVzLnZpZGVvO1xuICB9XG4gIGdldCBpc0F1ZGlvKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGVzLmF1ZGlvO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgcGxheWluZyBzdGF0ZVxuICAgKi9cbiAgZ2V0IHBsYXlpbmcoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5yZWFkeSAmJiAhdGhpcy5wYXVzZWQgJiYgIXRoaXMuZW5kZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBwYXVzZWQgc3RhdGVcbiAgICovXG4gIGdldCBwYXVzZWQoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5tZWRpYS5wYXVzZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzdG9wcGVkIHN0YXRlXG4gICAqL1xuICBnZXQgc3RvcHBlZCgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLnBhdXNlZCAmJiB0aGlzLmN1cnJlbnRUaW1lID09PSAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZW5kZWQgc3RhdGVcbiAgICovXG4gIGdldCBlbmRlZCgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLm1lZGlhLmVuZGVkKTtcbiAgfVxuICAvKipcbiAgICogU2VlayB0byBhIHRpbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGlucHV0IC0gd2hlcmUgdG8gc2VlayB0byBpbiBzZWNvbmRzLiBEZWZhdWx0cyB0byAwICh0aGUgc3RhcnQpXG4gICAqL1xuICBzZXQgY3VycmVudFRpbWUoaW5wdXQpIHtcbiAgICAvLyBCYWlsIGlmIG1lZGlhIGR1cmF0aW9uIGlzbid0IGF2YWlsYWJsZSB5ZXRcbiAgICBpZiAoIXRoaXMuZHVyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBpbnB1dFxuICAgIGNvbnN0IGlucHV0SXNWYWxpZCA9IGlzLm51bWJlcihpbnB1dCkgJiYgaW5wdXQgPiAwO1xuXG4gICAgLy8gU2V0XG4gICAgdGhpcy5tZWRpYS5jdXJyZW50VGltZSA9IGlucHV0SXNWYWxpZCA/IE1hdGgubWluKGlucHV0LCB0aGlzLmR1cmF0aW9uKSA6IDA7XG5cbiAgICAvLyBMb2dnaW5nXG4gICAgdGhpcy5kZWJ1Zy5sb2coYFNlZWtpbmcgdG8gJHt0aGlzLmN1cnJlbnRUaW1lfSBzZWNvbmRzYCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgdGltZVxuICAgKi9cbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5tZWRpYS5jdXJyZW50VGltZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGJ1ZmZlcmVkXG4gICAqL1xuICBnZXQgYnVmZmVyZWQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYnVmZmVyZWRcbiAgICB9ID0gdGhpcy5tZWRpYTtcblxuICAgIC8vIFlvdVR1YmUgLyBWaW1lbyByZXR1cm4gYSBmbG9hdCBiZXR3ZWVuIDAtMVxuICAgIGlmIChpcy5udW1iZXIoYnVmZmVyZWQpKSB7XG4gICAgICByZXR1cm4gYnVmZmVyZWQ7XG4gICAgfVxuXG4gICAgLy8gSFRNTDVcbiAgICAvLyBUT0RPOiBIYW5kbGUgYnVmZmVyZWQgY2h1bmtzIG9mIHRoZSBtZWRpYVxuICAgIC8vIChpLmUuIHNlZWsgdG8gYW5vdGhlciBzZWN0aW9uIGJ1ZmZlcnMgb25seSB0aGF0IHNlY3Rpb24pXG4gICAgaWYgKGJ1ZmZlcmVkICYmIGJ1ZmZlcmVkLmxlbmd0aCAmJiB0aGlzLmR1cmF0aW9uID4gMCkge1xuICAgICAgcmV0dXJuIGJ1ZmZlcmVkLmVuZCgwKSAvIHRoaXMuZHVyYXRpb247XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzZWVraW5nIHN0YXR1c1xuICAgKi9cbiAgZ2V0IHNlZWtpbmcoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5tZWRpYS5zZWVraW5nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGR1cmF0aW9uIG9mIHRoZSBjdXJyZW50IG1lZGlhXG4gICAqL1xuICBnZXQgZHVyYXRpb24oKSB7XG4gICAgLy8gRmF1eCBkdXJhdGlvbiBzZXQgdmlhIGNvbmZpZ1xuICAgIGNvbnN0IGZhdXhEdXJhdGlvbiA9IE51bWJlci5wYXJzZUZsb2F0KHRoaXMuY29uZmlnLmR1cmF0aW9uKTtcbiAgICAvLyBNZWRpYSBkdXJhdGlvbiBjYW4gYmUgTmFOIG9yIEluZmluaXR5IGJlZm9yZSB0aGUgbWVkaWEgaGFzIGxvYWRlZFxuICAgIGNvbnN0IHJlYWxEdXJhdGlvbiA9ICh0aGlzLm1lZGlhIHx8IHt9KS5kdXJhdGlvbjtcbiAgICBjb25zdCBkdXJhdGlvbiA9ICFpcy5udW1iZXIocmVhbER1cmF0aW9uKSB8fCByZWFsRHVyYXRpb24gPT09IEluZmluaXR5ID8gMCA6IHJlYWxEdXJhdGlvbjtcblxuICAgIC8vIElmIGNvbmZpZyBkdXJhdGlvbiBpcyBmdW5reSwgdXNlIHJlZ3VsYXIgZHVyYXRpb25cbiAgICByZXR1cm4gZmF1eER1cmF0aW9uIHx8IGR1cmF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcGxheWVyIHZvbHVtZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMS4gRGVmYXVsdHMgdG8gdGhlIHZhbHVlIGZyb20gbG9jYWwgc3RvcmFnZSBhbmQgY29uZmlnLnZvbHVtZSBpZiBub3Qgc2V0IGluIHN0b3JhZ2VcbiAgICovXG4gIHNldCB2b2x1bWUodmFsdWUpIHtcbiAgICBsZXQgdm9sdW1lID0gdmFsdWU7XG4gICAgY29uc3QgbWF4ID0gMTtcbiAgICBjb25zdCBtaW4gPSAwO1xuICAgIGlmIChpcy5zdHJpbmcodm9sdW1lKSkge1xuICAgICAgdm9sdW1lID0gTnVtYmVyKHZvbHVtZSk7XG4gICAgfVxuXG4gICAgLy8gTG9hZCB2b2x1bWUgZnJvbSBzdG9yYWdlIGlmIG5vIHZhbHVlIHNwZWNpZmllZFxuICAgIGlmICghaXMubnVtYmVyKHZvbHVtZSkpIHtcbiAgICAgIHZvbHVtZSA9IHRoaXMuc3RvcmFnZS5nZXQoJ3ZvbHVtZScpO1xuICAgIH1cblxuICAgIC8vIFVzZSBjb25maWcgaWYgYWxsIGVsc2UgZmFpbHNcbiAgICBpZiAoIWlzLm51bWJlcih2b2x1bWUpKSB7XG4gICAgICAoe1xuICAgICAgICB2b2x1bWVcbiAgICAgIH0gPSB0aGlzLmNvbmZpZyk7XG4gICAgfVxuXG4gICAgLy8gTWF4aW11bSBpcyB2b2x1bWVNYXhcbiAgICBpZiAodm9sdW1lID4gbWF4KSB7XG4gICAgICB2b2x1bWUgPSBtYXg7XG4gICAgfVxuICAgIC8vIE1pbmltdW0gaXMgdm9sdW1lTWluXG4gICAgaWYgKHZvbHVtZSA8IG1pbikge1xuICAgICAgdm9sdW1lID0gbWluO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBjb25maWdcbiAgICB0aGlzLmNvbmZpZy52b2x1bWUgPSB2b2x1bWU7XG5cbiAgICAvLyBTZXQgdGhlIHBsYXllciB2b2x1bWVcbiAgICB0aGlzLm1lZGlhLnZvbHVtZSA9IHZvbHVtZTtcblxuICAgIC8vIElmIG11dGVkLCBhbmQgd2UncmUgaW5jcmVhc2luZyB2b2x1bWUgbWFudWFsbHksIHJlc2V0IG11dGVkIHN0YXRlXG4gICAgaWYgKCFpcy5lbXB0eSh2YWx1ZSkgJiYgdGhpcy5tdXRlZCAmJiB2b2x1bWUgPiAwKSB7XG4gICAgICB0aGlzLm11dGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBwbGF5ZXIgdm9sdW1lXG4gICAqL1xuICBnZXQgdm9sdW1lKCkge1xuICAgIHJldHVybiBOdW1iZXIodGhpcy5tZWRpYS52b2x1bWUpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgbXV0ZWQgc3RhdGVcbiAgICogQHBhcmFtIHtib29sZWFufSBtdXRlXG4gICAqL1xuICBzZXQgbXV0ZWQobXV0ZSkge1xuICAgIGxldCB0b2dnbGUgPSBtdXRlO1xuXG4gICAgLy8gTG9hZCBtdXRlZCBzdGF0ZSBmcm9tIHN0b3JhZ2VcbiAgICBpZiAoIWlzLmJvb2xlYW4odG9nZ2xlKSkge1xuICAgICAgdG9nZ2xlID0gdGhpcy5zdG9yYWdlLmdldCgnbXV0ZWQnKTtcbiAgICB9XG5cbiAgICAvLyBVc2UgY29uZmlnIGlmIGFsbCBlbHNlIGZhaWxzXG4gICAgaWYgKCFpcy5ib29sZWFuKHRvZ2dsZSkpIHtcbiAgICAgIHRvZ2dsZSA9IHRoaXMuY29uZmlnLm11dGVkO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBjb25maWdcbiAgICB0aGlzLmNvbmZpZy5tdXRlZCA9IHRvZ2dsZTtcblxuICAgIC8vIFNldCBtdXRlIG9uIHRoZSBwbGF5ZXJcbiAgICB0aGlzLm1lZGlhLm11dGVkID0gdG9nZ2xlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IG11dGVkIHN0YXRlXG4gICAqL1xuICBnZXQgbXV0ZWQoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5tZWRpYS5tdXRlZCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIG1lZGlhIGhhcyBhdWRpb1xuICAgKi9cbiAgZ2V0IGhhc0F1ZGlvKCkge1xuICAgIC8vIEFzc3VtZSB5ZXMgZm9yIGFsbCBub24gSFRNTDUgKGFzIHdlIGNhbid0IHRlbGwuLi4pXG4gICAgaWYgKCF0aGlzLmlzSFRNTDUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0F1ZGlvKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBHZXQgYXVkaW8gdHJhY2tzXG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5tZWRpYS5tb3pIYXNBdWRpbykgfHwgQm9vbGVhbih0aGlzLm1lZGlhLndlYmtpdEF1ZGlvRGVjb2RlZEJ5dGVDb3VudCkgfHwgQm9vbGVhbih0aGlzLm1lZGlhLmF1ZGlvVHJhY2tzICYmIHRoaXMubWVkaWEuYXVkaW9UcmFja3MubGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcGxheWJhY2sgc3BlZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGlucHV0IC0gdGhlIHNwZWVkIG9mIHBsYXliYWNrICgwLjUtMi4wKVxuICAgKi9cbiAgc2V0IHNwZWVkKGlucHV0KSB7XG4gICAgbGV0IHNwZWVkID0gbnVsbDtcbiAgICBpZiAoaXMubnVtYmVyKGlucHV0KSkge1xuICAgICAgc3BlZWQgPSBpbnB1dDtcbiAgICB9XG4gICAgaWYgKCFpcy5udW1iZXIoc3BlZWQpKSB7XG4gICAgICBzcGVlZCA9IHRoaXMuc3RvcmFnZS5nZXQoJ3NwZWVkJyk7XG4gICAgfVxuICAgIGlmICghaXMubnVtYmVyKHNwZWVkKSkge1xuICAgICAgc3BlZWQgPSB0aGlzLmNvbmZpZy5zcGVlZC5zZWxlY3RlZDtcbiAgICB9XG5cbiAgICAvLyBDbGFtcCB0byBtaW4vbWF4XG4gICAgY29uc3Qge1xuICAgICAgbWluaW11bVNwZWVkOiBtaW4sXG4gICAgICBtYXhpbXVtU3BlZWQ6IG1heFxuICAgIH0gPSB0aGlzO1xuICAgIHNwZWVkID0gY2xhbXAoc3BlZWQsIG1pbiwgbWF4KTtcblxuICAgIC8vIFVwZGF0ZSBjb25maWdcbiAgICB0aGlzLmNvbmZpZy5zcGVlZC5zZWxlY3RlZCA9IHNwZWVkO1xuXG4gICAgLy8gU2V0IG1lZGlhIHNwZWVkXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgICB0aGlzLm1lZGlhLnBsYXliYWNrUmF0ZSA9IHNwZWVkO1xuICAgICAgfVxuICAgIH0sIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IHBsYXliYWNrIHNwZWVkXG4gICAqL1xuICBnZXQgc3BlZWQoKSB7XG4gICAgcmV0dXJuIE51bWJlcih0aGlzLm1lZGlhLnBsYXliYWNrUmF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaW5pbXVtIGFsbG93ZWQgc3BlZWRcbiAgICovXG4gIGdldCBtaW5pbXVtU3BlZWQoKSB7XG4gICAgaWYgKHRoaXMuaXNZb3VUdWJlKSB7XG4gICAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS95b3V0dWJlL2lmcmFtZV9hcGlfcmVmZXJlbmNlI3NldFBsYXliYWNrUmF0ZVxuICAgICAgcmV0dXJuIE1hdGgubWluKC4uLnRoaXMub3B0aW9ucy5zcGVlZCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVmltZW8pIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92aW1lby9wbGF5ZXIuanMvI3NldHBsYXliYWNrcmF0ZXBsYXliYWNrcmF0ZS1udW1iZXItcHJvbWlzZW51bWJlci1yYW5nZWVycm9yZXJyb3JcbiAgICAgIHJldHVybiAwLjU7XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMyMzIwMDIwLzExOTEzMTlcbiAgICByZXR1cm4gMC4wNjI1O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWF4aW11bSBhbGxvd2VkIHNwZWVkXG4gICAqL1xuICBnZXQgbWF4aW11bVNwZWVkKCkge1xuICAgIGlmICh0aGlzLmlzWW91VHViZSkge1xuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20veW91dHViZS9pZnJhbWVfYXBpX3JlZmVyZW5jZSNzZXRQbGF5YmFja1JhdGVcbiAgICAgIHJldHVybiBNYXRoLm1heCguLi50aGlzLm9wdGlvbnMuc3BlZWQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1ZpbWVvKSB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmltZW8vcGxheWVyLmpzLyNzZXRwbGF5YmFja3JhdGVwbGF5YmFja3JhdGUtbnVtYmVyLXByb21pc2VudW1iZXItcmFuZ2VlcnJvcmVycm9yXG4gICAgICByZXR1cm4gMjtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzIzMjAwMjAvMTE5MTMxOVxuICAgIHJldHVybiAxNjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgcGxheWJhY2sgcXVhbGl0eVxuICAgKiBDdXJyZW50bHkgSFRNTDUgJiBZb3VUdWJlIG9ubHlcbiAgICogQHBhcmFtIHtudW1iZXJ9IGlucHV0IC0gUXVhbGl0eSBsZXZlbFxuICAgKi9cbiAgc2V0IHF1YWxpdHkoaW5wdXQpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZy5xdWFsaXR5O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMucXVhbGl0eTtcbiAgICBpZiAoIW9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBxdWFsaXR5ID0gWyFpcy5lbXB0eShpbnB1dCkgJiYgTnVtYmVyKGlucHV0KSwgdGhpcy5zdG9yYWdlLmdldCgncXVhbGl0eScpLCBjb25maWcuc2VsZWN0ZWQsIGNvbmZpZy5kZWZhdWx0XS5maW5kKGlzLm51bWJlcik7XG4gICAgbGV0IHVwZGF0ZVN0b3JhZ2UgPSB0cnVlO1xuICAgIGlmICghb3B0aW9ucy5pbmNsdWRlcyhxdWFsaXR5KSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBjbG9zZXN0KG9wdGlvbnMsIHF1YWxpdHkpO1xuICAgICAgdGhpcy5kZWJ1Zy53YXJuKGBVbnN1cHBvcnRlZCBxdWFsaXR5IG9wdGlvbjogJHtxdWFsaXR5fSwgdXNpbmcgJHt2YWx1ZX0gaW5zdGVhZGApO1xuICAgICAgcXVhbGl0eSA9IHZhbHVlO1xuXG4gICAgICAvLyBEb24ndCB1cGRhdGUgc3RvcmFnZSBpZiBxdWFsaXR5IGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgIHVwZGF0ZVN0b3JhZ2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgY29uZmlnXG4gICAgY29uZmlnLnNlbGVjdGVkID0gcXVhbGl0eTtcblxuICAgIC8vIFNldCBxdWFsaXR5XG4gICAgdGhpcy5tZWRpYS5xdWFsaXR5ID0gcXVhbGl0eTtcblxuICAgIC8vIFNhdmUgdG8gc3RvcmFnZVxuICAgIGlmICh1cGRhdGVTdG9yYWdlKSB7XG4gICAgICB0aGlzLnN0b3JhZ2Uuc2V0KHtcbiAgICAgICAgcXVhbGl0eVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjdXJyZW50IHF1YWxpdHkgbGV2ZWxcbiAgICovXG4gIGdldCBxdWFsaXR5KCkge1xuICAgIHJldHVybiB0aGlzLm1lZGlhLnF1YWxpdHk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlIGxvb3BcbiAgICogVE9ETzogRmluaXNoIGZhbmN5IG5ldyBsb2dpYy4gU2V0IHRoZSBpbmRpY2F0b3Igb24gbG9hZCBhcyB1c2VyIG1heSBwYXNzIGxvb3AgYXMgY29uZmlnXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5wdXQgLSBXaGV0aGVyIHRvIGxvb3Agb3Igbm90XG4gICAqL1xuICBzZXQgbG9vcChpbnB1dCkge1xuICAgIGNvbnN0IHRvZ2dsZSA9IGlzLmJvb2xlYW4oaW5wdXQpID8gaW5wdXQgOiB0aGlzLmNvbmZpZy5sb29wLmFjdGl2ZTtcbiAgICB0aGlzLmNvbmZpZy5sb29wLmFjdGl2ZSA9IHRvZ2dsZTtcbiAgICB0aGlzLm1lZGlhLmxvb3AgPSB0b2dnbGU7XG5cbiAgICAvLyBTZXQgZGVmYXVsdCB0byBiZSBhIHRydWUgdG9nZ2xlXG4gICAgLyogY29uc3QgdHlwZSA9IFsnc3RhcnQnLCAnZW5kJywgJ2FsbCcsICdub25lJywgJ3RvZ2dsZSddLmluY2x1ZGVzKGlucHV0KSA/IGlucHV0IDogJ3RvZ2dsZSc7XG4gICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcubG9vcC5lbmQgJiYgdGhpcy5jb25maWcubG9vcC5lbmQgPD0gdGhpcy5jdXJyZW50VGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5sb29wLmVuZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmxvb3Auc3RhcnQgPSB0aGlzLmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuY29uZmlnLmxvb3AuaW5kaWNhdG9yLnN0YXJ0ID0gdGhpcy5lbGVtZW50cy5kaXNwbGF5LnBsYXllZC52YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5sb29wLnN0YXJ0ID49IHRoaXMuY3VycmVudFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmxvb3AuZW5kID0gdGhpcy5jdXJyZW50VGltZTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLmNvbmZpZy5sb29wLmluZGljYXRvci5lbmQgPSB0aGlzLmVsZW1lbnRzLmRpc3BsYXkucGxheWVkLnZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgIGNhc2UgJ2FsbCc6XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcubG9vcC5zdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcubG9vcC5lbmQgPSB0aGlzLmR1cmF0aW9uIC0gMjtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5sb29wLmluZGljYXRvci5zdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcubG9vcC5pbmRpY2F0b3IuZW5kID0gMTAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgIGNhc2UgJ3RvZ2dsZSc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxvb3AuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmxvb3Auc3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5sb29wLmVuZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcubG9vcC5zdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmxvb3AuZW5kID0gdGhpcy5kdXJhdGlvbiAtIDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcubG9vcC5zdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcubG9vcC5lbmQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9ICovXG4gIH1cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgbG9vcCBzdGF0ZVxuICAgKi9cbiAgZ2V0IGxvb3AoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5tZWRpYS5sb29wKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgbmV3IG1lZGlhIHNvdXJjZVxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXQgLSBUaGUgbmV3IHNvdXJjZSBvYmplY3QgKHNlZSBkb2NzKVxuICAgKi9cbiAgc2V0IHNvdXJjZShpbnB1dCkge1xuICAgIHNvdXJjZS5jaGFuZ2UuY2FsbCh0aGlzLCBpbnB1dCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgc291cmNlXG4gICAqL1xuICBnZXQgc291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLm1lZGlhLmN1cnJlbnRTcmM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgZG93bmxvYWQgVVJMIChlaXRoZXIgc291cmNlIG9yIGN1c3RvbSlcbiAgICovXG4gIGdldCBkb3dubG9hZCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBkb3dubG9hZFxuICAgIH0gPSB0aGlzLmNvbmZpZy51cmxzO1xuICAgIHJldHVybiBpcy51cmwoZG93bmxvYWQpID8gZG93bmxvYWQgOiB0aGlzLnNvdXJjZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRvd25sb2FkIFVSTFxuICAgKi9cbiAgc2V0IGRvd25sb2FkKGlucHV0KSB7XG4gICAgaWYgKCFpcy51cmwoaW5wdXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY29uZmlnLnVybHMuZG93bmxvYWQgPSBpbnB1dDtcbiAgICBjb250cm9scy5zZXREb3dubG9hZFVybC5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcG9zdGVyIGltYWdlIGZvciBhIHZpZGVvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCAtIHRoZSBVUkwgZm9yIHRoZSBuZXcgcG9zdGVyIGltYWdlXG4gICAqL1xuICBzZXQgcG9zdGVyKGlucHV0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmlkZW8pIHtcbiAgICAgIHRoaXMuZGVidWcud2FybignUG9zdGVyIGNhbiBvbmx5IGJlIHNldCBmb3IgdmlkZW8nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdWkuc2V0UG9zdGVyLmNhbGwodGhpcywgaW5wdXQsIGZhbHNlKS5jYXRjaCgoKSA9PiB7fSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHBvc3RlciBpbWFnZVxuICAgKi9cbiAgZ2V0IHBvc3RlcigpIHtcbiAgICBpZiAoIXRoaXMuaXNWaWRlbykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1lZGlhLmdldEF0dHJpYnV0ZSgncG9zdGVyJykgfHwgdGhpcy5tZWRpYS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcG9zdGVyJyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGFzcGVjdCByYXRpbyBpbiB1c2VcbiAgICovXG4gIGdldCByYXRpbygpIHtcbiAgICBpZiAoIXRoaXMuaXNWaWRlbykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJhdGlvID0gcmVkdWNlQXNwZWN0UmF0aW8oZ2V0QXNwZWN0UmF0aW8uY2FsbCh0aGlzKSk7XG4gICAgcmV0dXJuIGlzLmFycmF5KHJhdGlvKSA/IHJhdGlvLmpvaW4oJzonKSA6IHJhdGlvO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB2aWRlbyBhc3BlY3QgcmF0aW9cbiAgICovXG4gIHNldCByYXRpbyhpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZpZGVvKSB7XG4gICAgICB0aGlzLmRlYnVnLndhcm4oJ0FzcGVjdCByYXRpbyBjYW4gb25seSBiZSBzZXQgZm9yIHZpZGVvJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaXMuc3RyaW5nKGlucHV0KSB8fCAhdmFsaWRhdGVBc3BlY3RSYXRpbyhpbnB1dCkpIHtcbiAgICAgIHRoaXMuZGVidWcuZXJyb3IoYEludmFsaWQgYXNwZWN0IHJhdGlvIHNwZWNpZmllZCAoJHtpbnB1dH0pYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY29uZmlnLnJhdGlvID0gcmVkdWNlQXNwZWN0UmF0aW8oaW5wdXQpO1xuICAgIHNldEFzcGVjdFJhdGlvLmNhbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBhdXRvcGxheSBzdGF0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlucHV0IC0gV2hldGhlciB0byBhdXRvcGxheSBvciBub3RcbiAgICovXG4gIHNldCBhdXRvcGxheShpbnB1dCkge1xuICAgIHRoaXMuY29uZmlnLmF1dG9wbGF5ID0gaXMuYm9vbGVhbihpbnB1dCkgPyBpbnB1dCA6IHRoaXMuY29uZmlnLmF1dG9wbGF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBhdXRvcGxheSBzdGF0ZVxuICAgKi9cbiAgZ2V0IGF1dG9wbGF5KCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMuY29uZmlnLmF1dG9wbGF5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGUgY2FwdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBpbnB1dCAtIFdoZXRoZXIgdG8gZW5hYmxlIGNhcHRpb25zXG4gICAqL1xuICB0b2dnbGVDYXB0aW9ucyhpbnB1dCkge1xuICAgIGNhcHRpb25zLnRvZ2dsZS5jYWxsKHRoaXMsIGlucHV0LCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjYXB0aW9uIHRyYWNrIGJ5IGluZGV4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbnB1dCAtIENhcHRpb24gaW5kZXhcbiAgICovXG4gIHNldCBjdXJyZW50VHJhY2soaW5wdXQpIHtcbiAgICBjYXB0aW9ucy5zZXQuY2FsbCh0aGlzLCBpbnB1dCwgZmFsc2UpO1xuICAgIGNhcHRpb25zLnNldHVwLmNhbGwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IGNhcHRpb24gdHJhY2sgaW5kZXggKC0xIGlmIGRpc2FibGVkKVxuICAgKi9cbiAgZ2V0IGN1cnJlbnRUcmFjaygpIHtcbiAgICBjb25zdCB7XG4gICAgICB0b2dnbGVkLFxuICAgICAgY3VycmVudFRyYWNrXG4gICAgfSA9IHRoaXMuY2FwdGlvbnM7XG4gICAgcmV0dXJuIHRvZ2dsZWQgPyBjdXJyZW50VHJhY2sgOiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHdhbnRlZCBsYW5ndWFnZSBmb3IgY2FwdGlvbnNcbiAgICogU2luY2UgdHJhY2tzIGNhbiBiZSBhZGRlZCBsYXRlciBpdCB3b24ndCB1cGRhdGUgdGhlIGFjdHVhbCBjYXB0aW9uIHRyYWNrIHVudGlsIHRoZXJlIGlzIGEgbWF0Y2hpbmcgdHJhY2tcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IC0gVHdvIGNoYXJhY3RlciBJU08gbGFuZ3VhZ2UgY29kZSAoZS5nLiBFTiwgRlIsIFBULCBldGMpXG4gICAqL1xuICBzZXQgbGFuZ3VhZ2UoaW5wdXQpIHtcbiAgICBjYXB0aW9ucy5zZXRMYW5ndWFnZS5jYWxsKHRoaXMsIGlucHV0LCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHRyYWNrJ3MgbGFuZ3VhZ2VcbiAgICovXG4gIGdldCBsYW5ndWFnZSgpIHtcbiAgICByZXR1cm4gKGNhcHRpb25zLmdldEN1cnJlbnRUcmFjay5jYWxsKHRoaXMpIHx8IHt9KS5sYW5ndWFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGUgcGljdHVyZS1pbi1waWN0dXJlIHBsYXliYWNrIG9uIFdlYktpdC9NYWNPU1xuICAgKiBUT0RPOiB1cGRhdGUgcGxheWVyIHdpdGggc3RhdGUsIHN1cHBvcnQsIGVuYWJsZWRcbiAgICogVE9ETzogZGV0ZWN0IG91dHNpZGUgY2hhbmdlc1xuICAgKi9cbiAgc2V0IHBpcChpbnB1dCkge1xuICAgIC8vIEJhaWwgaWYgbm8gc3VwcG9ydFxuICAgIGlmICghc3VwcG9ydC5waXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUb2dnbGUgYmFzZWQgb24gY3VycmVudCBzdGF0ZSBpZiBub3QgcGFzc2VkXG4gICAgY29uc3QgdG9nZ2xlID0gaXMuYm9vbGVhbihpbnB1dCkgPyBpbnB1dCA6ICF0aGlzLnBpcDtcblxuICAgIC8vIFRvZ2dsZSBiYXNlZCBvbiBjdXJyZW50IHN0YXRlXG4gICAgLy8gU2FmYXJpXG4gICAgaWYgKGlzLmZ1bmN0aW9uKHRoaXMubWVkaWEud2Via2l0U2V0UHJlc2VudGF0aW9uTW9kZSkpIHtcbiAgICAgIHRoaXMubWVkaWEud2Via2l0U2V0UHJlc2VudGF0aW9uTW9kZSh0b2dnbGUgPyBwaXAuYWN0aXZlIDogcGlwLmluYWN0aXZlKTtcbiAgICB9XG5cbiAgICAvLyBDaHJvbWVcbiAgICBpZiAoaXMuZnVuY3Rpb24odGhpcy5tZWRpYS5yZXF1ZXN0UGljdHVyZUluUGljdHVyZSkpIHtcbiAgICAgIGlmICghdGhpcy5waXAgJiYgdG9nZ2xlKSB7XG4gICAgICAgIHRoaXMubWVkaWEucmVxdWVzdFBpY3R1cmVJblBpY3R1cmUoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5waXAgJiYgIXRvZ2dsZSkge1xuICAgICAgICBkb2N1bWVudC5leGl0UGljdHVyZUluUGljdHVyZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgcGljdHVyZS1pbi1waWN0dXJlIHN0YXRlXG4gICAqL1xuICBnZXQgcGlwKCkge1xuICAgIGlmICghc3VwcG9ydC5waXApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFNhZmFyaVxuICAgIGlmICghaXMuZW1wdHkodGhpcy5tZWRpYS53ZWJraXRQcmVzZW50YXRpb25Nb2RlKSkge1xuICAgICAgcmV0dXJuIHRoaXMubWVkaWEud2Via2l0UHJlc2VudGF0aW9uTW9kZSA9PT0gcGlwLmFjdGl2ZTtcbiAgICB9XG5cbiAgICAvLyBDaHJvbWVcbiAgICByZXR1cm4gdGhpcy5tZWRpYSA9PT0gZG9jdW1lbnQucGljdHVyZUluUGljdHVyZUVsZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcHJldmlldyB0aHVtYm5haWxzIGZvciB0aGUgY3VycmVudCBzb3VyY2VcbiAgICovXG4gIHNldFByZXZpZXdUaHVtYm5haWxzKHRodW1ibmFpbFNvdXJjZSkge1xuICAgIGlmICh0aGlzLnByZXZpZXdUaHVtYm5haWxzICYmIHRoaXMucHJldmlld1RodW1ibmFpbHMubG9hZGVkKSB7XG4gICAgICB0aGlzLnByZXZpZXdUaHVtYm5haWxzLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMucHJldmlld1RodW1ibmFpbHMgPSBudWxsO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHRoaXMuY29uZmlnLnByZXZpZXdUaHVtYm5haWxzLCB0aHVtYm5haWxTb3VyY2UpO1xuXG4gICAgLy8gQ3JlYXRlIG5ldyBpbnN0YW5jZSBpZiBpdCBpcyBzdGlsbCBlbmFibGVkXG4gICAgaWYgKHRoaXMuY29uZmlnLnByZXZpZXdUaHVtYm5haWxzLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMucHJldmlld1RodW1ibmFpbHMgPSBuZXcgUHJldmlld1RodW1ibmFpbHModGhpcyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDaGVjayBmb3Igc3VwcG9ydFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFBsYXllciB0eXBlIChhdWRpby92aWRlbylcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3ZpZGVyIC0gUHJvdmlkZXIgKGh0bWw1L3lvdXR1YmUvdmltZW8pXG4gICAqL1xuICBzdGF0aWMgc3VwcG9ydGVkKHR5cGUsIHByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIHN1cHBvcnQuY2hlY2sodHlwZSwgcHJvdmlkZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgYW4gU1ZHIHNwcml0ZSBpbnRvIHRoZSBwYWdlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBVUkwgZm9yIHRoZSBTVkcgc3ByaXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbaWRdIC0gVW5pcXVlIElEXG4gICAqL1xuICBzdGF0aWMgbG9hZFNwcml0ZSh1cmwsIGlkKSB7XG4gICAgcmV0dXJuIGxvYWRTcHJpdGUodXJsLCBpZCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAgbXVsdGlwbGUgaW5zdGFuY2VzXG4gICAqIEBwYXJhbSB7Kn0gc2VsZWN0b3JcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIHN0YXRpYyBzZXR1cChzZWxlY3Rvciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IHRhcmdldHMgPSBudWxsO1xuICAgIGlmIChpcy5zdHJpbmcoc2VsZWN0b3IpKSB7XG4gICAgICB0YXJnZXRzID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gICAgfSBlbHNlIGlmIChpcy5ub2RlTGlzdChzZWxlY3RvcikpIHtcbiAgICAgIHRhcmdldHMgPSBBcnJheS5mcm9tKHNlbGVjdG9yKTtcbiAgICB9IGVsc2UgaWYgKGlzLmFycmF5KHNlbGVjdG9yKSkge1xuICAgICAgdGFyZ2V0cyA9IHNlbGVjdG9yLmZpbHRlcihpcy5lbGVtZW50KTtcbiAgICB9XG4gICAgaWYgKGlzLmVtcHR5KHRhcmdldHMpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldHMubWFwKHQgPT4gbmV3IFBseXIodCwgb3B0aW9ucykpO1xuICB9XG59XG5QbHlyLmRlZmF1bHRzID0gY2xvbmVEZWVwKGRlZmF1bHRzKTtcblxuZXhwb3J0IHsgUGx5ciBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHlyLmpzLm1hcFxuIl0sIm5hbWVzIjpbIl9kZWZpbmVQcm9wZXJ0eSQxIiwiZSIsInIiLCJ0IiwiX3RvUHJvcGVydHlLZXkiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX3RvUHJpbWl0aXZlIiwiU3ltYm9sIiwidG9QcmltaXRpdmUiLCJpIiwiY2FsbCIsIlR5cGVFcnJvciIsIlN0cmluZyIsIk51bWJlciIsIl9jbGFzc0NhbGxDaGVjayIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwibiIsImxlbmd0aCIsImtleSIsIl9jcmVhdGVDbGFzcyIsInByb3RvdHlwZSIsIl9kZWZpbmVQcm9wZXJ0eSIsIm93bktleXMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZDIiLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZhdWx0cyQxIiwiYWRkQ1NTIiwidGh1bWJXaWR0aCIsIndhdGNoIiwibWF0Y2hlcyQxIiwiQXJyYXkiLCJmcm9tIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaW5jbHVkZXMiLCJ0cmlnZ2VyIiwiRXZlbnQiLCJidWJibGVzIiwiZGlzcGF0Y2hFdmVudCIsImdldENvbnN0cnVjdG9yJDEiLCJpbnN0YW5jZU9mJDEiLCJpc051bGxPclVuZGVmaW5lZCQxIiwiaXNPYmplY3QkMSIsImlzTnVtYmVyJDEiLCJpc05hTiIsImlzU3RyaW5nJDEiLCJpc0Jvb2xlYW4kMSIsIkJvb2xlYW4iLCJpc0Z1bmN0aW9uJDEiLCJGdW5jdGlvbiIsImlzQXJyYXkkMSIsImlzQXJyYXkiLCJpc05vZGVMaXN0JDEiLCJOb2RlTGlzdCIsImlzRWxlbWVudCQxIiwiRWxlbWVudCIsImlzRXZlbnQkMSIsImlzRW1wdHkkMSIsImlzJDEiLCJudWxsT3JVbmRlZmluZWQiLCJvYmplY3QiLCJudW1iZXIiLCJzdHJpbmciLCJib29sZWFuIiwiZnVuY3Rpb24iLCJhcnJheSIsIm5vZGVMaXN0IiwiZWxlbWVudCIsImV2ZW50IiwiZW1wdHkiLCJnZXREZWNpbWFsUGxhY2VzIiwiY29uY2F0IiwibWF0Y2giLCJNYXRoIiwibWF4Iiwicm91bmQiLCJwYXJzZUZsb2F0IiwidG9GaXhlZCIsIlJhbmdlVG91Y2giLCJxdWVyeVNlbGVjdG9yIiwicmFuZ2VUb3VjaCIsImNvbmZpZyIsImluaXQiLCJlbmFibGVkIiwic3R5bGUiLCJ1c2VyU2VsZWN0Iiwid2ViS2l0VXNlclNlbGVjdCIsInRvdWNoQWN0aW9uIiwibGlzdGVuZXJzIiwic2V0IiwidGFyZ2V0IiwiY2hhbmdlZFRvdWNoZXMiLCJvIiwiZ2V0QXR0cmlidXRlIiwicyIsInUiLCJjIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiYSIsIndpZHRoIiwiY2xpZW50WCIsImxlZnQiLCJkaXNhYmxlZCIsInByZXZlbnREZWZhdWx0IiwiZ2V0IiwidHlwZSIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJhZGRlZE5vZGVzIiwib2JzZXJ2ZSIsImJvZHkiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwibWFwIiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0Q29uc3RydWN0b3IiLCJpbnB1dCIsImluc3RhbmNlT2YiLCJjb25zdHJ1Y3RvciIsImlzTnVsbE9yVW5kZWZpbmVkIiwiaXNPYmplY3QiLCJpc051bWJlciIsImlzU3RyaW5nIiwiaXNCb29sZWFuIiwiaXNGdW5jdGlvbiIsImlzV2Vha01hcCIsIldlYWtNYXAiLCJpc05vZGVMaXN0IiwiaXNUZXh0Tm9kZSIsIlRleHQiLCJpc0V2ZW50IiwiaXNLZXlib2FyZEV2ZW50IiwiS2V5Ym9hcmRFdmVudCIsImlzQ3VlIiwid2luZG93IiwiVGV4dFRyYWNrQ3VlIiwiVlRUQ3VlIiwiaXNUcmFjayIsIlRleHRUcmFjayIsImtpbmQiLCJpc1Byb21pc2UiLCJQcm9taXNlIiwidGhlbiIsImlzRWxlbWVudCIsIm5vZGVUeXBlIiwib3duZXJEb2N1bWVudCIsImlzRW1wdHkiLCJpc1VybCIsIlVSTCIsInN0YXJ0c1dpdGgiLCJob3N0bmFtZSIsImlzIiwid2Vha01hcCIsInRleHROb2RlIiwia2V5Ym9hcmRFdmVudCIsImN1ZSIsInRyYWNrIiwicHJvbWlzZSIsInVybCIsInRyYW5zaXRpb25FbmRFdmVudCIsImNyZWF0ZUVsZW1lbnQiLCJldmVudHMiLCJXZWJraXRUcmFuc2l0aW9uIiwiTW96VHJhbnNpdGlvbiIsIk9UcmFuc2l0aW9uIiwidHJhbnNpdGlvbiIsImZpbmQiLCJ1bmRlZmluZWQiLCJyZXBhaW50IiwiZGVsYXkiLCJzZXRUaW1lb3V0IiwiaGlkZGVuIiwib2Zmc2V0SGVpZ2h0IiwiY2xvbmVEZWVwIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiZ2V0RGVlcCIsInBhdGgiLCJzcGxpdCIsInJlZHVjZSIsIm9iaiIsImV4dGVuZCIsInNvdXJjZXMiLCJzb3VyY2UiLCJzaGlmdCIsImFzc2lnbiIsIndyYXAiLCJlbGVtZW50cyIsIndyYXBwZXIiLCJ0YXJnZXRzIiwicmV2ZXJzZSIsImluZGV4IiwiY2hpbGQiLCJjbG9uZU5vZGUiLCJwYXJlbnQiLCJwYXJlbnROb2RlIiwic2libGluZyIsIm5leHRTaWJsaW5nIiwiYXBwZW5kQ2hpbGQiLCJpbnNlcnRCZWZvcmUiLCJzZXRBdHRyaWJ1dGVzIiwiYXR0cmlidXRlcyIsImVudHJpZXMiLCJzZXRBdHRyaWJ1dGUiLCJ0ZXh0IiwidGV4dENvbnRlbnQiLCJpbnNlcnRBZnRlciIsImluc2VydEVsZW1lbnQiLCJyZW1vdmVFbGVtZW50IiwicmVtb3ZlQ2hpbGQiLCJlbXB0eUVsZW1lbnQiLCJjaGlsZE5vZGVzIiwibGFzdENoaWxkIiwicmVwbGFjZUVsZW1lbnQiLCJuZXdDaGlsZCIsIm9sZENoaWxkIiwicmVwbGFjZUNoaWxkIiwiZ2V0QXR0cmlidXRlc0Zyb21TZWxlY3RvciIsInNlbCIsImV4aXN0aW5nQXR0cmlidXRlcyIsImV4aXN0aW5nIiwic2VsZWN0b3IiLCJ0cmltIiwiY2xhc3NOYW1lIiwicmVwbGFjZSIsInN0cmlwcGVkIiwicGFydHMiLCJzdGFydCIsImNoYXJBdCIsImNsYXNzIiwiaWQiLCJ0b2dnbGVIaWRkZW4iLCJoaWRlIiwidG9nZ2xlQ2xhc3MiLCJmb3JjZSIsIm1ldGhvZCIsImNsYXNzTGlzdCIsImNvbnRhaW5zIiwiaGFzQ2xhc3MiLCJtYXRjaGVzIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJjbG9zZXN0JDEiLCJjbG9zZXN0RWxlbWVudCIsImVsIiwicGFyZW50RWxlbWVudCIsImNsb3Nlc3QiLCJnZXRFbGVtZW50cyIsImNvbnRhaW5lciIsImdldEVsZW1lbnQiLCJzZXRGb2N1cyIsImZvY3VzVmlzaWJsZSIsImZvY3VzIiwicHJldmVudFNjcm9sbCIsImRlZmF1bHRDb2RlY3MiLCJzdXBwb3J0IiwiYXVkaW8iLCJ2aWRlbyIsImNoZWNrIiwicHJvdmlkZXIiLCJhcGkiLCJ1aSIsInJhbmdlSW5wdXQiLCJwaXAiLCJwaWN0dXJlSW5QaWN0dXJlRW5hYmxlZCIsImRpc2FibGVQaWN0dXJlSW5QaWN0dXJlIiwiYWlycGxheSIsIldlYktpdFBsYXliYWNrVGFyZ2V0QXZhaWxhYmlsaXR5RXZlbnQiLCJwbGF5c2lubGluZSIsIm1pbWUiLCJtZWRpYVR5cGUiLCJpc0hUTUw1IiwibWVkaWEiLCJjYW5QbGF5VHlwZSIsInRleHRUcmFja3MiLCJyYW5nZSIsInRvdWNoIiwidHJhbnNpdGlvbnMiLCJyZWR1Y2VkTW90aW9uIiwibWF0Y2hNZWRpYSIsInN1cHBvcnRzUGFzc2l2ZUxpc3RlbmVycyIsInN1cHBvcnRlZCIsIm9wdGlvbnMiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInRvZ2dsZUxpc3RlbmVyIiwiY2FsbGJhY2siLCJ0b2dnbGUiLCJwYXNzaXZlIiwiY2FwdHVyZSIsImV2ZW50TGlzdGVuZXJzIiwib24iLCJvZmYiLCJvbmNlIiwib25jZUNhbGxiYWNrIiwiYXJncyIsInRyaWdnZXJFdmVudCIsImRldGFpbCIsIkN1c3RvbUV2ZW50IiwicGx5ciIsInVuYmluZExpc3RlbmVycyIsIml0ZW0iLCJyZWFkeSIsInJlc29sdmUiLCJzaWxlbmNlUHJvbWlzZSIsImRlZHVwZSIsImluZGV4T2YiLCJwcmV2IiwiY3VyciIsImFicyIsInN1cHBvcnRzQ1NTIiwiZGVjbGFyYXRpb24iLCJDU1MiLCJzdXBwb3J0cyIsInN0YW5kYXJkUmF0aW9zIiwib3V0IiwieCIsInkiLCJ2YWxpZGF0ZUFzcGVjdFJhdGlvIiwicmF0aW8iLCJldmVyeSIsInJlZHVjZUFzcGVjdFJhdGlvIiwiaGVpZ2h0IiwiZ2V0RGl2aWRlciIsInciLCJoIiwiZGl2aWRlciIsImdldEFzcGVjdFJhdGlvIiwiZW1iZWQiLCJ2aWRlb1dpZHRoIiwidmlkZW9IZWlnaHQiLCJzZXRBc3BlY3RSYXRpbyIsImlzVmlkZW8iLCJ1c2VOYXRpdmUiLCJwYWRkaW5nIiwiYXNwZWN0UmF0aW8iLCJwYWRkaW5nQm90dG9tIiwiaXNWaW1lbyIsInZpbWVvIiwicHJlbWl1bSIsIm9mZnNldFdpZHRoIiwicGFyc2VJbnQiLCJnZXRDb21wdXRlZFN0eWxlIiwib2Zmc2V0IiwiZnVsbHNjcmVlbiIsImFjdGl2ZSIsInRyYW5zZm9ybSIsImFkZCIsImNsYXNzTmFtZXMiLCJ2aWRlb0ZpeGVkUmF0aW8iLCJyb3VuZEFzcGVjdFJhdGlvIiwidG9sZXJhbmNlIiwiY2xvc2VzdFJhdGlvIiwiZ2V0Vmlld3BvcnRTaXplIiwiY2xpZW50V2lkdGgiLCJpbm5lcldpZHRoIiwiY2xpZW50SGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJodG1sNSIsImdldFNvdXJjZXMiLCJnZXRRdWFsaXR5T3B0aW9ucyIsInF1YWxpdHkiLCJmb3JjZWQiLCJzZXR1cCIsInBsYXllciIsInNwZWVkIiwib25DaGFuZ2UiLCJjdXJyZW50VGltZSIsInBhdXNlZCIsInByZWxvYWQiLCJyZWFkeVN0YXRlIiwicGxheWJhY2tSYXRlIiwic3JjIiwicGxheSIsImxvYWQiLCJjYW5jZWxSZXF1ZXN0cyIsImJsYW5rVmlkZW8iLCJkZWJ1ZyIsImxvZyIsImlzSUUiLCJkb2N1bWVudE1vZGUiLCJpc0VkZ2UiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaXNXZWJLaXQiLCJpc0lQYWRPUyIsInBsYXRmb3JtIiwibWF4VG91Y2hQb2ludHMiLCJpc0lvcyIsImJyb3dzZXIiLCJnZW5lcmF0ZUlkIiwicHJlZml4IiwiZmxvb3IiLCJyYW5kb20iLCJmb3JtYXQiLCJ0b1N0cmluZyIsIl8iLCJnZXRQZXJjZW50YWdlIiwiY3VycmVudCIsInJlcGxhY2VBbGwiLCJSZWdFeHAiLCJ0b1RpdGxlQ2FzZSIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJ0b0xvd2VyQ2FzZSIsInRvUGFzY2FsQ2FzZSIsInRvQ2FtZWxDYXNlIiwic3RyaXBIVE1MIiwiZnJhZ21lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiaW5uZXJIVE1MIiwiZmlyc3RDaGlsZCIsImdldEhUTUwiLCJyZXNvdXJjZXMiLCJ5b3V0dWJlIiwiaTE4biIsInNlZWtUaW1lIiwidGl0bGUiLCJrIiwidiIsIlN0b3JhZ2UiLCJzdG9yZSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJqc29uIiwic3RvcmFnZSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwiZmV0Y2giLCJyZXNwb25zZVR5cGUiLCJ3aXRoQ3JlZGVudGlhbHMiLCJyZWplY3QiLCJyZXF1ZXN0IiwiWE1MSHR0cFJlcXVlc3QiLCJyZXNwb25zZVRleHQiLCJyZXNwb25zZSIsIkVycm9yIiwic3RhdHVzIiwib3BlbiIsInNlbmQiLCJlcnJvciIsImxvYWRTcHJpdGUiLCJoYXNJZCIsImlzQ2FjaGVkIiwiZXhpc3RzIiwiZ2V0RWxlbWVudEJ5SWQiLCJ1cGRhdGUiLCJkYXRhIiwiaW5zZXJ0QWRqYWNlbnRFbGVtZW50IiwidXNlU3RvcmFnZSIsImNhY2hlZCIsImNvbnRlbnQiLCJyZXN1bHQiLCJjYXRjaCIsImdldEhvdXJzIiwidHJ1bmMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImZvcm1hdFRpbWUiLCJ0aW1lIiwiZGlzcGxheUhvdXJzIiwiaW52ZXJ0ZWQiLCJob3VycyIsIm1pbnMiLCJzZWNzIiwiY29udHJvbHMiLCJnZXRJY29uVXJsIiwiaWNvblVybCIsImxvY2F0aW9uIiwiaG9zdCIsInRvcCIsImNvcnMiLCJzdmc0ZXZlcnlib2R5IiwiZmluZEVsZW1lbnRzIiwic2VsZWN0b3JzIiwiYnV0dG9ucyIsInBhdXNlIiwicmVzdGFydCIsInJld2luZCIsImZhc3RGb3J3YXJkIiwibXV0ZSIsInNldHRpbmdzIiwiY2FwdGlvbnMiLCJwcm9ncmVzcyIsImlucHV0cyIsInNlZWsiLCJ2b2x1bWUiLCJkaXNwbGF5IiwiYnVmZmVyIiwiZHVyYXRpb24iLCJzZWVrVG9vbHRpcCIsInRvb2x0aXAiLCJ3YXJuIiwidG9nZ2xlTmF0aXZlQ29udHJvbHMiLCJjcmVhdGVJY29uIiwibmFtZXNwYWNlIiwiaWNvblBhdGgiLCJpY29uUHJlZml4IiwiaWNvbiIsImNyZWF0ZUVsZW1lbnROUyIsInVzZSIsInNldEF0dHJpYnV0ZU5TIiwiY3JlYXRlTGFiZWwiLCJhdHRyIiwiam9pbiIsImNyZWF0ZUJhZGdlIiwiYmFkZ2UiLCJtZW51IiwiY3JlYXRlQnV0dG9uIiwiYnV0dG9uVHlwZSIsInByb3BzIiwibGFiZWwiLCJsYWJlbFByZXNzZWQiLCJpY29uUHJlc3NlZCIsImNvbnRyb2wiLCJidXR0b24iLCJjcmVhdGVSYW5nZSIsInVwZGF0ZVJhbmdlRmlsbCIsImNyZWF0ZVByb2dyZXNzIiwic3VmZml4S2V5IiwicGxheWVkIiwic3VmZml4IiwiY3JlYXRlVGltZSIsImF0dHJzIiwiYmluZE1lbnVJdGVtU2hvcnRjdXRzIiwibWVudUl0ZW0iLCJzdG9wUHJvcGFnYXRpb24iLCJpc1JhZGlvQnV0dG9uIiwic2hvd01lbnVQYW5lbCIsIm5leHRFbGVtZW50U2libGluZyIsImZpcnN0RWxlbWVudENoaWxkIiwicHJldmlvdXNFbGVtZW50U2libGluZyIsImxhc3RFbGVtZW50Q2hpbGQiLCJmb2N1c0ZpcnN0TWVudUl0ZW0iLCJjcmVhdGVNZW51SXRlbSIsImxpc3QiLCJjaGVja2VkIiwiZmxleCIsImNoaWxkcmVuIiwibm9kZSIsImJpbmQiLCJjdXJyZW50VHJhY2siLCJmb3JjZUhvdXJzIiwidXBkYXRlVGltZURpc3BsYXkiLCJ1cGRhdGVWb2x1bWUiLCJzZXRSYW5nZSIsIm11dGVkIiwicHJlc3NlZCIsInVwZGF0ZVByb2dyZXNzIiwic2V0UHJvZ3Jlc3MiLCJ2YWwiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsIm5vZGVWYWx1ZSIsImJ1ZmZlcmVkIiwicGVyY2VudCIsInNldFByb3BlcnR5IiwidXBkYXRlU2Vla1Rvb2x0aXAiLCJfdGhpcyRjb25maWckbWFya2VycyIsIl90aGlzJGNvbmZpZyRtYXJrZXJzJCIsInRvb2x0aXBzIiwidGlwRWxlbWVudCIsInZpc2libGUiLCJzaG93IiwiY2xpZW50UmVjdCIsInNjcm9sbExlZnQiLCJwYWdlWCIsInBvaW50IiwibWFya2VycyIsInBvaW50cyIsImluc2VydEFkamFjZW50SFRNTCIsInRpbWVVcGRhdGUiLCJpbnZlcnQiLCJpbnZlcnRUaW1lIiwic2Vla2luZyIsImR1cmF0aW9uVXBkYXRlIiwiaGFzRHVyYXRpb24iLCJkaXNwbGF5RHVyYXRpb24iLCJzZXRNYXJrZXJzIiwidG9nZ2xlTWVudUJ1dHRvbiIsInNldHRpbmciLCJ1cGRhdGVTZXR0aW5nIiwicGFuZSIsInBhbmVscyIsImRlZmF1bHQiLCJnZXRMYWJlbCIsInNldFF1YWxpdHlNZW51IiwiY2hlY2tNZW51IiwiZ2V0QmFkZ2UiLCJzb3J0IiwiYiIsInNvcnRpbmciLCJzZXRDYXB0aW9uc01lbnUiLCJ0cmFja3MiLCJnZXRUcmFja3MiLCJ0b2dnbGVkIiwibGFuZ3VhZ2UiLCJ1bnNoaWZ0Iiwic2V0U3BlZWRNZW51IiwibWluaW11bVNwZWVkIiwibWF4aW11bVNwZWVkIiwidmFsdWVzIiwic29tZSIsInBvcHVwIiwicCIsImZpcnN0SXRlbSIsInRvZ2dsZU1lbnUiLCJjb21wb3NlZFBhdGgiLCJpc01lbnVJdGVtIiwiZ2V0TWVudVNpemUiLCJ0YWIiLCJjbG9uZSIsInBvc2l0aW9uIiwib3BhY2l0eSIsInJlbW92ZUF0dHJpYnV0ZSIsInNjcm9sbFdpZHRoIiwic2Nyb2xsSGVpZ2h0Iiwic2l6ZSIsInJlc3RvcmUiLCJwcm9wZXJ0eU5hbWUiLCJzZXREb3dubG9hZFVybCIsImRvd25sb2FkIiwiY3JlYXRlIiwiZGVmYXVsdEF0dHJpYnV0ZXMiLCJwcm9ncmVzc0NvbnRhaW5lciIsInN0ZXAiLCJpbm5lciIsImhvbWUiLCJyb2xlIiwiYmFja0J1dHRvbiIsImhyZWYiLCJ1cmxzIiwiaXNFbWJlZCIsImluamVjdCIsInNlZWt0aW1lIiwiaW5zZXJ0TWV0aG9kIiwiYWRkUHJvcGVydHkiLCJjb250cm9sUHJlc3NlZCIsImxhYmVscyIsInNldE1lZGlhTWV0YWRhdGEiLCJtZWRpYVNlc3Npb24iLCJtZXRhZGF0YSIsIk1lZGlhTWV0YWRhdGEiLCJtZWRpYU1ldGFkYXRhIiwiYXJ0aXN0IiwiYWxidW0iLCJhcnR3b3JrIiwiX3RoaXMkY29uZmlnJG1hcmtlcnMyIiwiX3RoaXMkY29uZmlnJG1hcmtlcnMzIiwiY29udGFpbmVyRnJhZ21lbnQiLCJwb2ludHNGcmFnbWVudCIsInRpcFZpc2libGUiLCJ0b2dnbGVUaXAiLCJtYXJrZXJFbGVtZW50IiwibWFya2VyIiwidGlwIiwicGFyc2VVcmwiLCJzYWZlIiwicGFyc2VyIiwiYnVpbGRVcmxQYXJhbXMiLCJwYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJpc1lvdVR1YmUiLCJwcm90b2NvbCIsImJsb2IiLCJjcmVhdGVPYmplY3RVUkwiLCJicm93c2VyTGFuZ3VhZ2VzIiwibGFuZ3VhZ2VzIiwidXNlckxhbmd1YWdlIiwidHJhY2tFdmVudHMiLCJtZXRhIiwiY3VycmVudFRyYWNrTm9kZSIsImxhbmd1YWdlRXhpc3RzIiwibW9kZSIsInVwZGF0ZUN1ZXMiLCJzZXRMYW5ndWFnZSIsImFjdGl2ZUNsYXNzIiwiZmluZFRyYWNrIiwiZW5hYmxlVGV4dFRyYWNrIiwiaGFzIiwic29ydElzRGVmYXVsdCIsInNvcnRlZCIsImdldEN1cnJlbnRUcmFjayIsImN1ZXMiLCJhY3RpdmVDdWVzIiwiZ2V0Q3VlQXNIVE1MIiwiY3VlVGV4dCIsImNoYW5nZWQiLCJjYXB0aW9uIiwiZGVmYXVsdHMiLCJhdXRvcGxheSIsImF1dG9wYXVzZSIsInRvZ2dsZUludmVydCIsImNsaWNrVG9QbGF5IiwiaGlkZUNvbnRyb2xzIiwicmVzZXRPbkVuZCIsImRpc2FibGVDb250ZXh0TWVudSIsImxvb3AiLCJzZWxlY3RlZCIsImtleWJvYXJkIiwiZm9jdXNlZCIsImdsb2JhbCIsImZhbGxiYWNrIiwiaW9zTmF0aXZlIiwic2Vla0xhYmVsIiwidW5tdXRlIiwiZW5hYmxlQ2FwdGlvbnMiLCJkaXNhYmxlQ2FwdGlvbnMiLCJlbnRlckZ1bGxzY3JlZW4iLCJleGl0RnVsbHNjcmVlbiIsImZyYW1lVGl0bGUiLCJtZW51QmFjayIsIm5vcm1hbCIsImVuZCIsImFsbCIsInJlc2V0IiwiYWR2ZXJ0aXNlbWVudCIsInF1YWxpdHlCYWRnZSIsInNkayIsImlmcmFtZSIsImdvb2dsZUlNQSIsImVkaXRhYmxlIiwiZW1iZWRDb250YWluZXIiLCJwb3N0ZXIiLCJwb3N0ZXJFbmFibGVkIiwiYWRzIiwicGxheWluZyIsInN0b3BwZWQiLCJsb2FkaW5nIiwiaG92ZXIiLCJpc1RvdWNoIiwidWlTdXBwb3J0ZWQiLCJub1RyYW5zaXRpb24iLCJwcmV2aWV3VGh1bWJuYWlscyIsInRodW1iQ29udGFpbmVyIiwidGh1bWJDb250YWluZXJTaG93biIsImltYWdlQ29udGFpbmVyIiwidGltZUNvbnRhaW5lciIsInNjcnViYmluZ0NvbnRhaW5lciIsInNjcnViYmluZ0NvbnRhaW5lclNob3duIiwiaGFzaCIsInB1Ymxpc2hlcklkIiwidGFnVXJsIiwiYnlsaW5lIiwicG9ydHJhaXQiLCJ0cmFuc3BhcmVudCIsImN1c3RvbUNvbnRyb2xzIiwicmVmZXJyZXJQb2xpY3kiLCJyZWwiLCJzaG93aW5mbyIsIml2X2xvYWRfcG9saWN5IiwibW9kZXN0YnJhbmRpbmciLCJub0Nvb2tpZSIsImluYWN0aXZlIiwicHJvdmlkZXJzIiwidHlwZXMiLCJnZXRQcm92aWRlckJ5VXJsIiwibm9vcCIsIkNvbnNvbGUiLCJjb25zb2xlIiwiRnVsbHNjcmVlbiIsIl93aW5kb3ckc2Nyb2xsWCIsIl93aW5kb3ckc2Nyb2xsWSIsInNjcm9sbFBvc2l0aW9uIiwic2Nyb2xsWCIsInNjcm9sbFkiLCJzY3JvbGxUbyIsIm92ZXJmbG93Iiwidmlld3BvcnQiLCJoZWFkIiwicHJvcGVydHkiLCJoYXNQcm9wZXJ0eSIsImNsZWFudXBWaWV3cG9ydCIsInBhcnQiLCJhY3RpdmVFbGVtZW50IiwiZm9jdXNhYmxlIiwiZmlyc3QiLCJsYXN0Iiwic2hpZnRLZXkiLCJmb3JjZUZhbGxiYWNrIiwibmF0aXZlU3VwcG9ydGVkIiwicmVxdWVzdEZ1bGxzY3JlZW4iLCJ3ZWJraXRFbnRlckZ1bGxzY3JlZW4iLCJ0b2dnbGVGYWxsYmFjayIsIm5hdmlnYXRpb25VSSIsImNhbmNlbEZ1bGxTY3JlZW4iLCJhY3Rpb24iLCJlbnRlciIsImV4aXQiLCJwcm94eSIsInRyYXBGb2N1cyIsImZ1bGxzY3JlZW5FbmFibGVkIiwid2Via2l0RnVsbHNjcmVlbkVuYWJsZWQiLCJtb3pGdWxsU2NyZWVuRW5hYmxlZCIsIm1zRnVsbHNjcmVlbkVuYWJsZWQiLCJwcmVmaXhlcyIsInByZSIsImdldFJvb3ROb2RlIiwiZnVsbHNjcmVlbkVsZW1lbnQiLCJzaGFkb3dSb290IiwiX3RoaXMkcGxheWVyJGVsZW1lbnRzIiwibG9hZEltYWdlIiwibWluV2lkdGgiLCJpbWFnZSIsIkltYWdlIiwiaGFuZGxlciIsIm9ubG9hZCIsIm9uZXJyb3IiLCJuYXR1cmFsV2lkdGgiLCJhZGRTdHlsZUhvb2siLCJidWlsZCIsImNoZWNrUGxheWluZyIsInNldFRpdGxlIiwic2V0UG9zdGVyIiwidG9nZ2xlUG9zdGVyIiwiZW5hYmxlIiwiYmFja2dyb3VuZEltYWdlIiwiYmFja2dyb3VuZFNpemUiLCJ0b2dnbGVDb250cm9scyIsImNoZWNrTG9hZGluZyIsImNsZWFyVGltZW91dCIsInRpbWVycyIsImNvbnRyb2xzRWxlbWVudCIsInJlY2VudFRvdWNoU2VlayIsImxhc3RTZWVrVGltZSIsIkRhdGUiLCJub3ciLCJtaWdyYXRlU3R5bGVzIiwiZ2V0UHJvcGVydHlWYWx1ZSIsInJlbW92ZVByb3BlcnR5IiwiTGlzdGVuZXJzIiwiX3BsYXllciIsImhhbmRsZUtleSIsImZpcnN0VG91Y2giLCJzZXRHdXR0ZXIiLCJ1c2VOYXRpdmVBc3BlY3RSYXRpbyIsIm1heFdpZHRoIiwibWFyZ2luIiwidmlld3BvcnRXaWR0aCIsInZpZXdwb3J0SGVpZ2h0IiwicmVzaXplZCIsImlzQXVkaW8iLCJlbmRlZCIsInRvZ2dsZVBsYXkiLCJwcm94eUV2ZW50cyIsImRlZmF1bHRIYW5kbGVyIiwiY3VzdG9tSGFuZGxlcktleSIsImN1c3RvbUhhbmRsZXIiLCJoYXNDdXN0b21IYW5kbGVyIiwicmV0dXJuZWQiLCJpbnB1dEV2ZW50IiwiZm9yd2FyZCIsInRvZ2dsZUNhcHRpb25zIiwicmVjdCIsImN1cnJlbnRUYXJnZXQiLCJhdHRyaWJ1dGUiLCJoYXNBdHRyaWJ1dGUiLCJkb25lIiwic2Vla1RvIiwibG9hZGVkIiwic3RhcnRNb3ZlIiwiZW5kTW92ZSIsInN0YXJ0U2NydWJiaW5nIiwiZW5kU2NydWJiaW5nIiwid2Via2l0RGlyZWN0aW9uSW52ZXJ0ZWRGcm9tRGV2aWNlIiwiZGVsdGFYIiwiZGVsdGFZIiwiZGlyZWN0aW9uIiwic2lnbiIsImluY3JlYXNlVm9sdW1lIiwibGFzdEtleSIsImZvY3VzVGltZXIiLCJsYXN0S2V5RG93biIsImFsdEtleSIsImN0cmxLZXkiLCJtZXRhS2V5IiwicmVwZWF0Iiwic2Vla0J5SW5jcmVtZW50IiwiaW5jcmVtZW50IiwiZGVjcmVhc2VWb2x1bWUiLCJ1c2luZ05hdGl2ZSIsImdldERlZmF1bHRFeHBvcnRGcm9tQ2pzIiwiX19lc01vZHVsZSIsImhhc093blByb3BlcnR5IiwibG9hZGpzX3VtZCQxIiwiZXhwb3J0cyIsImxvYWRqc191bWQiLCJoYXNSZXF1aXJlZExvYWRqc191bWQiLCJyZXF1aXJlTG9hZGpzX3VtZCIsIm1vZHVsZSIsInJvb3QiLCJmYWN0b3J5IiwiZGV2bnVsbCIsImJ1bmRsZUlkQ2FjaGUiLCJidW5kbGVSZXN1bHRDYWNoZSIsImJ1bmRsZUNhbGxiYWNrUXVldWUiLCJzdWJzY3JpYmUiLCJidW5kbGVJZHMiLCJjYWxsYmFja0ZuIiwiZGVwc05vdEZvdW5kIiwibnVtV2FpdGluZyIsImZuIiwiYnVuZGxlSWQiLCJxIiwicGF0aHNOb3RGb3VuZCIsInB1Ymxpc2giLCJzcGxpY2UiLCJleGVjdXRlQ2FsbGJhY2tzIiwic3VjY2VzcyIsImxvYWRGaWxlIiwibnVtVHJpZXMiLCJkb2MiLCJhc3luYyIsIm1heFRyaWVzIiwibnVtUmV0cmllcyIsImJlZm9yZUNhbGxiYWNrRm4iLCJiZWZvcmUiLCJwYXRobmFtZSIsInBhdGhTdHJpcHBlZCIsImlzTGVnYWN5SUVDc3MiLCJoYXNNb2R1bGVTdXBwb3J0IiwicmVsTGlzdCIsImFzIiwib25iZWZvcmVsb2FkIiwiZXYiLCJzaGVldCIsImNzc1RleHQiLCJjb2RlIiwiZGVmYXVsdFByZXZlbnRlZCIsImxvYWRGaWxlcyIsInBhdGhzIiwibG9hZGpzIiwiYXJnMSIsImFyZzIiLCJsb2FkRm4iLCJyZXR1cm5Qcm9taXNlIiwiZGVwcyIsImlzRGVmaW5lZCIsImxvYWRqc191bWRFeHBvcnRzIiwibG9hZFNjcmlwdCIsInBhcnNlSWQkMSIsInJlZ2V4IiwicGFyc2VIYXNoIiwiZm91bmQiLCJhc3N1cmVQbGF5YmFja1N0YXRlJDEiLCJoYXNQbGF5ZWQiLCJWaW1lbyIsImZyYW1lUGFyYW1zIiwiaGFzaFBhcmFtIiwic2lkZWRvY2siLCJnZXN0dXJlIiwidGh1bWJuYWlsX3VybCIsIlBsYXllciIsImRpc2FibGVUZXh0VHJhY2siLCJzdG9wIiwicmVzdG9yZVBhdXNlIiwic2V0Vm9sdW1lIiwic2V0Q3VycmVudFRpbWUiLCJzZXRQbGF5YmFja1JhdGUiLCJzZXRNdXRlZCIsInNldExvb3AiLCJjdXJyZW50U3JjIiwiZ2V0VmlkZW9VcmwiLCJnZXRWaWRlb1dpZHRoIiwiZ2V0VmlkZW9IZWlnaHQiLCJkaW1lbnNpb25zIiwic2V0QXV0b3BhdXNlIiwic3RhdGUiLCJnZXRWaWRlb1RpdGxlIiwiZ2V0Q3VycmVudFRpbWUiLCJnZXREdXJhdGlvbiIsImdldFRleHRUcmFja3MiLCJzdHJpcHBlZEN1ZXMiLCJnZXRQYXVzZWQiLCJmcmFtZSIsInNlY29uZHMiLCJwYXJzZUlkIiwiYXNzdXJlUGxheWJhY2tTdGF0ZSIsImdldEhvc3QiLCJZVCIsIm9uWW91VHViZUlmcmFtZUFQSVJlYWR5IiwiZ2V0VGl0bGUiLCJ2aWRlb0lkIiwiY3VycmVudElkIiwicG9zdGVyU3JjIiwicGxheWVyVmFycyIsImhsIiwiZGlzYWJsZWtiIiwiY2NfbG9hZF9wb2xpY3kiLCJjY19sYW5nX3ByZWYiLCJ3aWRnZXRfcmVmZXJyZXIiLCJvbkVycm9yIiwibWVzc2FnZSIsIm9uUGxheWJhY2tSYXRlQ2hhbmdlIiwiaW5zdGFuY2UiLCJnZXRQbGF5YmFja1JhdGUiLCJvblJlYWR5IiwicGxheVZpZGVvIiwicGF1c2VWaWRlbyIsInN0b3BWaWRlbyIsInNwZWVkcyIsImdldEF2YWlsYWJsZVBsYXliYWNrUmF0ZXMiLCJjbGVhckludGVydmFsIiwiYnVmZmVyaW5nIiwic2V0SW50ZXJ2YWwiLCJnZXRWaWRlb0xvYWRlZEZyYWN0aW9uIiwibGFzdEJ1ZmZlcmVkIiwib25TdGF0ZUNoYW5nZSIsInNlZWtlZCIsInVuTXV0ZSIsImRlc3Ryb3kiLCJtYW5hZ2VyIiwiZGlzcGxheUNvbnRhaW5lciIsInJlbW92ZSIsIkFkcyIsImdvb2dsZSIsImltYSIsInN0YXJ0U2FmZXR5VGltZXIiLCJtYW5hZ2VyUHJvbWlzZSIsImNsZWFyU2FmZXR5VGltZXIiLCJzZXR1cElNQSIsInNldFZwYWlkTW9kZSIsIkltYVNka1NldHRpbmdzIiwiVnBhaWRNb2RlIiwiRU5BQkxFRCIsInNldExvY2FsZSIsInNldERpc2FibGVDdXN0b21QbGF5YmFja0ZvcklPUzEwUGx1cyIsIkFkRGlzcGxheUNvbnRhaW5lciIsImxvYWRlciIsIkFkc0xvYWRlciIsIkFkc01hbmFnZXJMb2FkZWRFdmVudCIsIlR5cGUiLCJBRFNfTUFOQUdFUl9MT0FERUQiLCJvbkFkc01hbmFnZXJMb2FkZWQiLCJBZEVycm9yRXZlbnQiLCJBRF9FUlJPUiIsIm9uQWRFcnJvciIsInJlcXVlc3RBZHMiLCJBZHNSZXF1ZXN0IiwiYWRUYWdVcmwiLCJsaW5lYXJBZFNsb3RXaWR0aCIsImxpbmVhckFkU2xvdEhlaWdodCIsIm5vbkxpbmVhckFkU2xvdFdpZHRoIiwibm9uTGluZWFyQWRTbG90SGVpZ2h0IiwiZm9yY2VOb25MaW5lYXJGdWxsU2xvdCIsInNldEFkV2lsbFBsYXlNdXRlZCIsImNvdW50ZG93blRpbWVyIiwiZ2V0UmVtYWluaW5nVGltZSIsIkFkc1JlbmRlcmluZ1NldHRpbmdzIiwicmVzdG9yZUN1c3RvbVBsYXliYWNrU3RhdGVPbkFkQnJlYWtDb21wbGV0ZSIsImVuYWJsZVByZWxvYWRpbmciLCJnZXRBZHNNYW5hZ2VyIiwiY3VlUG9pbnRzIiwiZ2V0Q3VlUG9pbnRzIiwiQWRFdmVudCIsIm9uQWRFdmVudCIsImN1ZVBvaW50Iiwic2Vla0VsZW1lbnQiLCJjdWVQZXJjZW50YWdlIiwiYWQiLCJnZXRBZCIsImFkRGF0YSIsImdldEFkRGF0YSIsIkxPQURFRCIsInBvbGxDb3VudGRvd24iLCJpc0xpbmVhciIsIlNUQVJURUQiLCJBTExfQURTX0NPTVBMRVRFRCIsImxvYWRBZHMiLCJjb250ZW50Q29tcGxldGUiLCJDT05URU5UX1BBVVNFX1JFUVVFU1RFRCIsInBhdXNlQ29udGVudCIsIkNPTlRFTlRfUkVTVU1FX1JFUVVFU1RFRCIsInJlc3VtZUNvbnRlbnQiLCJMT0ciLCJhZEVycm9yIiwiZ2V0TWVzc2FnZSIsImNhbmNlbCIsImFkZEN1ZVBvaW50cyIsInNlZWtlZFRpbWUiLCJkaXNjYXJkQWRCcmVhayIsInJlc2l6ZSIsIlZpZXdNb2RlIiwiTk9STUFMIiwiaW5pdGlhbGl6ZSIsImluaXRpYWxpemVkIiwiekluZGV4IiwiaGFuZGxlcnMiLCJzYWZldHlUaW1lciIsIkFWX1BVQkxJU0hFUklEIiwiQVZfQ0hBTk5FTElEIiwiQVZfVVJMIiwiY2IiLCJBVl9XSURUSCIsIkFWX0hFSUdIVCIsIkFWX0NESU0yIiwiYmFzZSIsImNsYW1wIiwibWluIiwicGFyc2VWdHQiLCJ2dHREYXRhU3RyaW5nIiwicHJvY2Vzc2VkTGlzdCIsImZyYW1lcyIsImxpbmVzIiwibGluZSIsInN0YXJ0VGltZSIsIm1hdGNoVGltZXMiLCJlbmRUaW1lIiwibGluZVNwbGl0IiwiZml0UmF0aW8iLCJvdXRlciIsInRhcmdldFJhdGlvIiwiUHJldmlld1RodW1ibmFpbHMiLCJnZXRUaHVtYm5haWxzIiwicmVuZGVyIiwiZGV0ZXJtaW5lQ29udGFpbmVyQXV0b1NpemluZyIsInNvcnRBbmRSZXNvbHZlIiwidGh1bWJuYWlscyIsInByb21pc2VzIiwiZ2V0VGh1bWJuYWlsIiwidGh1bWJuYWlsIiwidXJsUHJlZml4Iiwic3Vic3RyaW5nIiwibGFzdEluZGV4T2YiLCJ0ZW1wSW1hZ2UiLCJuYXR1cmFsSGVpZ2h0IiwiX3RoaXMkcGxheWVyJGNvbmZpZyRtIiwiX3RoaXMkcGxheWVyJGNvbmZpZyRtMiIsInBlcmNlbnRhZ2UiLCJtb3VzZVBvc1giLCJ0aHVtYiIsInNob3dJbWFnZUF0Q3VycmVudFRpbWUiLCJ0b2dnbGVUaHVtYkNvbnRhaW5lciIsIm1vdXNlRG93biIsInRvZ2dsZVNjcnViYmluZ0NvbnRhaW5lciIsImNlaWwiLCJsYXN0VGltZSIsInNjcnViYmluZyIsInNldFNjcnViYmluZ0NvbnRhaW5lclNpemUiLCJzZXRUaHVtYkNvbnRhaW5lclNpemVBbmRQb3MiLCJ0aHVtYk51bSIsImZpbmRJbmRleCIsImhhc1RodW1iIiwicXVhbGl0eUluZGV4IiwibG9hZGVkSW1hZ2VzIiwic2hvd2luZ1RodW1iIiwidGh1bWJGaWxlbmFtZSIsInRodW1iVXJsIiwiY3VycmVudEltYWdlRWxlbWVudCIsImRhdGFzZXQiLCJmaWxlbmFtZSIsImxvYWRpbmdJbWFnZSIsInVzaW5nU3ByaXRlcyIsInByZXZpZXdJbWFnZSIsInNob3dpbmdUaHVtYkZpbGVuYW1lIiwic2hvd0ltYWdlIiwicmVtb3ZlT2xkSW1hZ2VzIiwibmV3SW1hZ2UiLCJzZXRJbWFnZVNpemVBbmRPZmZzZXQiLCJjdXJyZW50SW1hZ2VDb250YWluZXIiLCJwcmVsb2FkTmVhcmJ5IiwiZ2V0SGlnaGVyUXVhbGl0eSIsImN1cnJlbnRJbWFnZSIsInRhZ05hbWUiLCJyZW1vdmVEZWxheSIsImRlbGV0aW5nIiwib2xkVGh1bWJGaWxlbmFtZSIsInRodW1ibmFpbHNDbG9uZSIsImZvdW5kT25lIiwibmV3VGh1bWJGaWxlbmFtZSIsInRodW1iVVJMIiwiY3VycmVudFF1YWxpdHlJbmRleCIsInByZXZpZXdJbWFnZUhlaWdodCIsInRodW1iQ29udGFpbmVySGVpZ2h0IiwiY2xlYXJTaG93aW5nIiwic2l6ZVNwZWNpZmllZEluQ1NTIiwidGh1bWJBc3BlY3RSYXRpbyIsInRodW1iSGVpZ2h0Iiwic2V0VGh1bWJDb250YWluZXJQb3MiLCJzY3J1YmJlclJlY3QiLCJjb250YWluZXJSZWN0IiwicmlnaHQiLCJjbGFtcGVkIiwibXVsdGlwbGllciIsImxhc3RNb3VzZU1vdmVUaW1lIiwiY3VycmVudFNjcnViYmluZ0ltYWdlRWxlbWVudCIsImN1cnJlbnRUaHVtYm5haWxJbWFnZUVsZW1lbnQiLCJpbnNlcnRFbGVtZW50cyIsImNoYW5nZSIsImNyb3Nzb3JpZ2luIiwiUGx5ciIsIndlYmtpdFNob3dQbGF5YmFja1RhcmdldFBpY2tlciIsImlzSGlkZGVuIiwiaGlkaW5nIiwiZXZlbnROYW1lIiwic29mdCIsIm9yaWdpbmFsIiwidW5sb2FkIiwiZmFpbGVkIiwialF1ZXJ5IiwiX3R5cGUiLCJzZWFyY2giLCJ0cnV0aHkiLCJzZWFyY2hQYXJhbXMiLCJpbnB1dElzVmFsaWQiLCJmYXV4RHVyYXRpb24iLCJyZWFsRHVyYXRpb24iLCJJbmZpbml0eSIsImhhc0F1ZGlvIiwibW96SGFzQXVkaW8iLCJ3ZWJraXRBdWRpb0RlY29kZWRCeXRlQ291bnQiLCJhdWRpb1RyYWNrcyIsInVwZGF0ZVN0b3JhZ2UiLCJ3ZWJraXRTZXRQcmVzZW50YXRpb25Nb2RlIiwicmVxdWVzdFBpY3R1cmVJblBpY3R1cmUiLCJleGl0UGljdHVyZUluUGljdHVyZSIsIndlYmtpdFByZXNlbnRhdGlvbk1vZGUiLCJwaWN0dXJlSW5QaWN0dXJlRWxlbWVudCIsInNldFByZXZpZXdUaHVtYm5haWxzIiwidGh1bWJuYWlsU291cmNlIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/plyr/dist/plyr.mjs\n");

/***/ })

};
;